[
  {
    "text_1": "invoked by the edt to paint the dirty regions",
    "text_2": "public void paint Dirty ( ) { int size = NUM ; synchronized ( display Lock ) { size = paint Queue Fill ; Animation [ ] array = paint Queue ; paint Queue = paint Queue Temp ; paint Queue Temp = array ; paint Queue Fill = NUM ; } if ( size > NUM ) { Graphics wrapper = get Codename One Graphics ( ) ; int d width = get Display Width ( ) ; int d height = get Display Height ( ) ; int top X = d width ; int top Y = d height ; int bottom X = NUM ; int bottom Y = NUM ; for ( int iter = NUM ; iter < size ; iter + + ) { Animation ani = paint Queue Temp [ iter ] ; if ( ani = = null ) { continue ; } paint Queue Temp [ iter ] = null ; wrapper . translate ( - wrapper . get Translate X ( ) , - wrapper . get Translate Y ( ) ) ; wrapper . set Clip ( NUM , NUM , d width , d height ) ; if ( ani instanceof Component ) { Component cmp = ( Component ) ani ; Rectangle dirty = cmp . get Dirty Region ( ) ; if ( dirty ! = null ) { Dimension d = dirty . get Size ( ) ; wrapper . set Clip ( dirty . get X ( ) , dirty . get Y ( ) , d . get Width ( ) , d . get Height ( ) ) ; cmp . set Dirty Region ( null ) ; } cmp . paint Component ( wrapper ) ; get Paintable Bounds ( cmp , paint Dirty Tmp Rect ) ; int cmp Abs X = paint Dirty Tmp Rect . get X ( ) ; top X = Math . min ( cmp Abs X , top X ) ; bottom X = Math . max ( cmp Abs X + paint Dirty Tmp Rect . get Width ( ) , bottom X ) ; int cmp Abs Y = paint Dirty Tmp Rect . get Y ( ) ; top Y = Math . min ( cmp Abs Y , top Y ) ; bottom Y = Math . max ( cmp Abs Y + paint Dirty Tmp Rect . get Height ( ) , bottom Y ) ; } else { bottom X = d width ; bottom Y = d height ; top X = NUM ; top Y = NUM ; ani . paint ( wrapper ) ; } } paint Overlay ( wrapper ) ; flush Graphics ( top X , top Y , bottom X - top X , bottom Y - top Y ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a horizontal bar chart with sample data in the range - 3 to + 3 .",
    "text_2": "private static J Free Chart create Chart ( ) { XY Series series NUM = new XY Series ( STRING ) ; series NUM . add ( NUM , NUM ) ; series NUM . add ( NUM , NUM ) ; series NUM . add ( NUM , NUM ) ; XY Dataset dataset = new XY Series Collection ( series NUM ) ; return Chart Factory . create XY Step Chart ( STRING , STRING , STRING , dataset , Plot Orientation . VERTICAL , BOOL , BOOL , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize the internal frame close button settings .",
    "text_2": "private void define Internal Frame Close Buttons ( UI Defaults d ) { String p = STRING ; String c = PAINTER PREFIX + STRING ; d . put ( p + STRING , STRING ) ; d . put ( p + STRING , new Title Pane Close Button Window Not Focused State ( ) ) ; d . put ( p + STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND MOUSEOVER ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND PRESSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND ENABLED WINDOW NOT FOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND MOUSEOVER ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND PRESSED WINDOW NOT FOCUSED ) ) ; d . put ( p + STRING , new Sea Glass Icon ( p , STRING , NUM , NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "for upgrade patch , patch file version can ' t equal old version or new version in old patch info for repair patch , old patch info can ' t be null , and patch file version must equal with old version and new version",
    "text_2": "@ Override public void on Patch Version Check Fail ( File patch File , Share Patch Info old Patch Info , String patch File Version , boolean is Upgrade Patch ) { Tinker Log . i ( TAG , STRING , patch File . get Absolute Path ( ) , patch File Version , is Upgrade Patch ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if , at this time , the object will accept a connection via the named event",
    "text_2": "@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) & & ! event Name . equals ( STRING ) & & ! event Name . equals ( STRING ) & & ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee ! = null ) { return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "concatenates a list of int arrays into a single array .",
    "text_2": "public static int [ ] concat All Int ( int [ ] . . . arrays ) { int total Length = NUM ; final int sub Array Count = arrays . length ; for ( int i = NUM ; i < sub Array Count ; + + i ) { total Length + = arrays [ i ] . length ; } int [ ] result = Arrays . copy Of ( arrays [ NUM ] , total Length ) ; int offset = arrays [ NUM ] . length ; for ( int i = NUM ; i < sub Array Count ; + + i ) { System . arraycopy ( arrays [ i ] , NUM , result , offset , arrays [ i ] . length ) ; offset + = arrays [ i ] . length ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "todo add method documentation",
    "text_2": "protected Abstract Io Session ( Io Service service ) { this . service = service ; this . handler = service . get Handler ( ) ; long current Time = System . current Time Millis ( ) ; creation Time = current Time ; last Throughput Calculation Time = current Time ; last Read Time = current Time ; last Write Time = current Time ; last Idle Time For Both = current Time ; last Idle Time For Read = current Time ; last Idle Time For Write = current Time ; close Future . add Listener ( SCHEDULED COUNTER RE SETTER ) ; session Id = id Generator . increment And Get ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks whether a string is a memory access identifier string .",
    "text_2": "private static boolean is Memory Access ( final String value ) { return value . equals ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "stops communication with and closes all connections to the remote http server ( service ) .",
    "text_2": "@ Override public void stop ( ) { if ( executor Service ! = null ) { executor Service . shutdown ( ) ; } rest Template = null ; }",
    "label": 1
  },
  {
    "text_1": "adds a method to be displayed later in this sub - tree .",
    "text_2": "public void add Method To Display ( Method Ident method Ident ) { methods . add ( method Ident ) ; }",
    "label": 1
  },
  {
    "text_1": "normalize a string representing an ipv 4 address to the canonical representation with four decimal octets ( d . d . d . d ) .",
    "text_2": "public static String normalize Inet NUM Address ( String ip NUM String ) { final int [ ] octets = parse Inet NUM Address ( ip NUM String ) ; if ( octets = = null ) { return null ; } String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < NUM ; i + + ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( octets [ i ] ) ; } return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a new trust source containing the same trusted cas as this trust source , plus zero or more cas contained in the pem - encoded file . the file may contain multiple certificates and may contain comments or other non - pem - encoded text , as long as the pem - encoded certificates are delimited by appropriate begin certificate and end certificate text blocks . the file may contain utf - 8 characters , but the pem - encoded certificate data itself must be us - ascii .",
    "text_2": "public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File = = null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }",
    "label": 1
  },
  {
    "text_1": "this method works according to the specification of implemented class .",
    "text_2": "@ Override public void close ( ) throws IO Exception { if ( logger ! = null ) { logger . println ( STRING + socket was closed ) ; } if ( ! socket was closed ) { if ( handshake started ) { alert Protocol . alert ( Alert Protocol . WARNING , Alert Protocol . CLOSE NOTIFY ) ; try { output . write ( alert Protocol . wrap ( ) ) ; } catch ( IO Exception ex ) { } alert Protocol . set Processed ( ) ; } shutdown ( ) ; close Transport Layer ( ) ; socket was closed = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "test for equality , cop ing with nulls .",
    "text_2": "private static boolean eq ( Object o1 , Object o2 ) { return ( o1 = = null ? o2 = = null : o1 . equals ( o2 ) ) ; }",
    "label": 1
  },
  {
    "text_1": "check if any direction key is in \" pressed \" state .",
    "text_2": "public boolean direction Key Is Pressed ( ) { return pressed State Keys . contains ( Key Event . VK UP ) | | pressed State Keys . contains ( Key Event . VK DOWN ) | | pressed State Keys . contains ( Key Event . VK LEFT ) | | pressed State Keys . contains ( Key Event . VK RIGHT ) | | pressed State Keys . contains ( Key Event . VK KP LEFT ) | | pressed State Keys . contains ( Key Event . VK KP RIGHT ) | | pressed State Keys . contains ( Key Event . VK KP UP ) | | pressed State Keys . contains ( Key Event . VK KP DOWN ) ; }",
    "label": 1
  },
  {
    "text_1": "reads a \" int \" value from an inputstream . the value is converted to the opposed endian system while reading .",
    "text_2": "private static int read Swapped Integer ( final Data Input Stream input ) throws IO Exception { final int value NUM = input . read Byte ( ) ; final int value NUM = input . read Byte ( ) ; final int value NUM = input . read Byte ( ) ; final int value NUM = input . read Byte ( ) ; return ( ( value NUM & NUM ) < < NUM ) + ( ( value NUM & NUM ) < < NUM ) + ( ( value NUM & NUM ) < < NUM ) + ( ( value NUM & NUM ) < < NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "clear out the keys registered so far .",
    "text_2": "public void reset ( ) { m Codes . clear ( ) ; m Is First Char Capitalized = BOOL ; m Preferred Word = null ; m Typed Word . set Length ( NUM ) ; m Caps Count = NUM ; }",
    "label": 1
  },
  {
    "text_1": "parse css , find all defined variables & replace them .",
    "text_2": "private String parse Css ( final String css ) { final Map < String , String > map = new Hash Map < String , String > ( ) ; final String Buffer sb = new String Buffer ( ) ; final Matcher m = PATTERN VARIABLES DEFINITION . matcher ( css ) ; while ( m . find ( ) ) { final String variables Body = m . group ( NUM ) ; map . put All ( extract Variables ( variables Body ) ) ; m . append Replacement ( sb , STRING ) ; } m . append Tail ( sb ) ; return replace Variables ( sb . to String ( ) , map ) ; }",
    "label": 1
  },
  {
    "text_1": "selects the most suitable preview and picture size , given the desired width and height . even though we may only need the preview size , it ' s necessary to find both the preview size and the picture size of the camera together , because these need to have the same aspect ratio . on some hardware , if you would only set the preview size , you will get a distorted image .",
    "text_2": "private static Size Pair select Size Pair ( Camera camera , int desired Width , int desired Height ) { List < Size Pair > valid Preview Sizes = generate Valid Preview Size List ( camera ) ; Size Pair selected Pair = null ; int min Diff = Integer . MAX VALUE ; for ( Size Pair size Pair : valid Preview Sizes ) { Size size = size Pair . preview Size ( ) ; int diff = Math . abs ( size . get Width ( ) - desired Width ) + Math . abs ( size . get Height ( ) - desired Height ) ; if ( diff < min Diff ) { selected Pair = size Pair ; min Diff = diff ; } } return selected Pair ; }",
    "label": 1
  },
  {
    "text_1": "locates the guacamole home directory by checking , in order : the guacamole . home system property , the guacamole home environment variable , and finally the . guacamole directory in the home directory of the user running the servlet container .",
    "text_2": "private static File find Guacamole Home ( ) { File gu ac Home ; String desired Dir = System . get Property ( STRING ) ; if ( desired Dir = = null ) desired Dir = System . getenv ( STRING ) ; if ( desired Dir ! = null ) gu ac Home = new File ( desired Dir ) ; else gu ac Home = new File ( System . get Property ( STRING ) , STRING ) ; return gu ac Home ; }",
    "label": 1
  },
  {
    "text_1": "from the display changedlistener interface . this method handles a display change - either when the display settings are changed , or when the window has been dragged onto a different display . called after a change in the display mode . this event triggers replacing the surfacedata object ( since that object reflects the current display depth information , which has just changed ) .",
    "text_2": "@ Override public void display Changed ( ) { update GC ( ) ; }",
    "label": 1
  },
  {
    "text_1": "determine if the key exists .",
    "text_2": "public boolean is Exists Key ( Connection connection , Object [ ] keys ) { String Builder builder = new String Builder ( ) ; builder . append ( STRING ) ; builder . append ( table Name ) ; builder . append ( STRING ) ; String delimiter = STRING ; for ( String key Field : key Field Names ) { builder . append ( delimiter ) ; builder . append ( key Field ) ; builder . append ( STRING ) ; delimiter = STRING ; } String query = builder . to String ( ) ; Prepared Statement statement = null ; try { if ( ( Execution Path Debug Log . is Debug Enabled ) & & ( log . is Debug Enabled ( ) ) ) { log . debug ( STRING + query + STRING + print ( keys ) + STRING ) ; } statement = connection . prepare Statement ( query ) ; for ( int i = NUM ; i < keys . length ; i + + ) { statement . set Object ( i + NUM , keys [ i ] ) ; } Result Set rs = statement . execute Query ( ) ; if ( ! rs . next ( ) ) { return BOOL ; } return BOOL ; } catch ( SQL Exception ex ) { String message = STRING + query + STRING + ex . get Message ( ) ; log . error ( message , ex ) ; store Exception Handler . handle ( message , ex ) ; throw new Store Exception DB Rel ( message , ex ) ; } finally { try { if ( statement ! = null ) statement . close ( ) ; } catch ( SQL Exception e ) { } } }",
    "label": 1
  },
  {
    "text_1": "cleaning text to detect ( eliminate url , e - mail address and latin sentence if it is not written in latin alphabet )",
    "text_2": "private void cleaning Text ( ) { int latin Count = NUM , non Latin Count = NUM ; for ( int i = NUM ; i < text . length ( ) ; + + i ) { char c = text . char At ( i ) ; if ( c < = STRING & & c > = STRING ) { + + latin Count ; } else if ( c > = STRING & & Unicode Block . of ( c ) ! = Unicode Block . LATIN EXTENDED ADDITIONAL ) { + + non Latin Count ; } } if ( latin Count * NUM < non Latin Count ) { String Buffer text Without Latin = new String Buffer ( ) ; for ( int i = NUM ; i < text . length ( ) ; + + i ) { char c = text . char At ( i ) ; if ( c > STRING | | c < STRING ) text Without Latin . append ( c ) ; } text = text Without Latin ; } }",
    "label": 1
  },
  {
    "text_1": "create a program that satisfies an op check multisig program .",
    "text_2": "public static Script create Multi Sig Input Script ( Transaction Signature . . . signatures ) { return create Multi Sig Input Script ( Arrays . as List ( signatures ) ) ; }",
    "label": 1
  },
  {
    "text_1": "change the parameter and return the hast ings ratio .",
    "text_2": "public final double do Operation ( ) throws Operator Failed Exception { int index ; if ( update Map = = null ) { index = Math Utils . next Int ( parameter . get Dimension ( ) ) ; } else { index = update Map . get ( Math Utils . next Int ( update Map Size ) ) ; } double draw = ( NUM * Math Utils . next Double ( ) - NUM ) * window Size ; double new Value = parameter . get Parameter Value ( index ) + draw ; final Bounds < Double > bounds = parameter . get Bounds ( ) ; final double lower = ( lower Operator Bound = = null ? bounds . get Lower Limit ( index ) : Math . max ( bounds . get Lower Limit ( index ) , lower Operator Bound ) ) ; final double upper = ( upper Operator Bound = = null ? bounds . get Upper Limit ( index ) : Math . min ( bounds . get Upper Limit ( index ) , upper Operator Bound ) ) ; if ( condition = = Boundary Condition . refl ecting ) { new Value = reflect Value ( new Value , lower , upper ) ; } else if ( condition = = Boundary Condition . absor bing & & ( new Value < lower | | new Value > upper ) ) { return NUM ; } else if ( new Value < lower | | new Value > upper ) { throw new Operator Failed Exception ( STRING ) ; } parameter . set Parameter Value ( index , new Value ) ; return NUM ; }",
    "label": 1
  },
  {
    "text_1": "the smallest value , of all values inside the array , only work when all values are numeric",
    "text_2": "public static double min ( Array array ) throws Page Exception { if ( array . get Dimension ( ) > NUM ) throw new Expression Exception ( STRING ) ; if ( array . size ( ) = = NUM ) return NUM ; double rtn = to Double Value ( array , NUM ) ; int len = array . size ( ) ; try { for ( int i = NUM ; i < = len ; i + + ) { double v = to Double Value ( array , i ) ; if ( rtn > v ) rtn = v ; } } catch ( Page Exception e ) { throw new Expression Exception ( STRING + e . get Message ( ) ) ; } return rtn ; }",
    "label": 1
  },
  {
    "text_1": "action to be taken , when this state is completed and exited . default function to be overwritten in derived classes . returns the return state of this state .",
    "text_2": "public State Interactive complete ( ) { if ( return state ! = this & & act log ! = null ) { act log . start scope ( Logfile Scope . COMPLETE SCOPE ) ; } return return state ; }",
    "label": 1
  },
  {
    "text_1": "adds all target volumes ' full copies to the target consistency group",
    "text_2": "public Map < URI , List < URI > > add Target Volume Full Copies ( ) { List < URI > full Copies = Lists . new Array List ( ) ; Map < URI , List < URI > > full Copies Map = new Hash Map < > ( ) ; URI target CG = null ; for ( URI volume Id : uris ( volume Ids ) ) { List < URI > targets = get Targets ( volume Id ) ; for ( URI target : targets ) { if ( target CG = = null ) { target CG = get Consistency Group ( target ) ; } List < URI > volume Full Copies = get Full Copies ( target ) ; full Copies . add All ( volume Full Copies ) ; full Copies Map . put ( target , volume Full Copies ) ; } } if ( ! full Copies . is Empty ( ) & & target CG ! = null ) { Block Storage Utils . add Volumes To Consistency Group ( target CG , full Copies ) ; } return full Copies Map ; }",
    "label": 1
  },
  {
    "text_1": "draw a left tab at the given location and size with the given background color .",
    "text_2": "private static void draw Left Tab ( int x , int y , int w , int h , Graphics NUM D g NUM , Color UI Resource color ) { double r Top = Rapid Look And Feel . CORNER TAB RADIUS * NUM ; g NUM . set Color ( color ) ; g NUM . fill ( create Left Tab Shape ( x + NUM , y + NUM , w - NUM , h , r Top , BOOL ) ) ; g NUM . set Color ( Colors . TAB BORDER ) ; g NUM . draw ( create Left Tab Shape ( x , y , w - NUM , h , r Top , BOOL ) ) ; }",
    "label": 1
  },
  {
    "text_1": "encodes an image in png format .",
    "text_2": "@ Override public byte [ ] encode ( Buffered Image buffered Image ) throws IO Exception { Byte Array Output Stream output Stream = new Byte Array Output Stream ( ) ; encode ( buffered Image , output Stream ) ; return output Stream . to Byte Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create a selector of the form . $ class value",
    "text_2": "public static String build Selector From Class ( String class Value ) { String Builder strb = new String Builder ( ) ; strb . append ( CLASS SELECTOR PREFIX ) ; strb . append ( class Value ) ; return strb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "sorts an array of indices to vector of comparable objects into increasing order .",
    "text_2": "public static void sort ( Abstract List array , int [ ] indices ) { for ( int i = NUM ; i < indices . length ; i + + ) { indices [ i ] = i ; } int temp ; int j , n = array . size ( ) ; for ( j = n / NUM ; j > NUM ; j - - ) { adjust ( array , indices , j , n ) ; } for ( j = n - NUM ; j > NUM ; j - - ) { temp = indices [ NUM ] ; indices [ NUM ] = indices [ j ] ; indices [ j ] = temp ; adjust ( array , indices , NUM , j ) ; } }",
    "label": 1
  },
  {
    "text_1": "used to find the last day in the tech datac al end ar week where capacity ! = 0 , ending at day end , day end included .",
    "text_2": "public static Map < String , Object > day End Capacity Available ( Generic Value tech Data Calendar Week , int day End ) { Map < String , Object > result = Fast Map . new Instance ( ) ; int move Day = NUM ; Double capacity = null ; Time start Time = null ; while ( capacity = = null | | capacity . double Value ( ) = = NUM ) { switch ( day End ) { case Calendar . MONDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . TUESDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . WEDNESDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . THURSDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . FRIDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . SATURDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . SUNDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; } if ( capacity = = null | | capacity . double Value ( ) = = NUM ) { move Day - = NUM ; day End = ( day End = = NUM ) ? NUM : day End - NUM ; } } result . put ( STRING , capacity ) ; result . put ( STRING , start Time ) ; result . put ( STRING , Integer . value Of ( move Day ) ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "get an array of types for an array of objects",
    "text_2": "private static Class < ? > [ ] types ( Object . . . values ) { if ( values = = null ) { return new Class [ NUM ] ; } Class < ? > [ ] result = new Class [ values . length ] ; for ( int i = NUM ; i < values . length ; i + + ) { Object value = values [ i ] ; result [ i ] = value = = null ? NULL . class : value . get Class ( ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "push the source of an import href onto the stylesheet stack , obtained from a uriresolver , null if there is no uriresolver , or if that resolver returned null .",
    "text_2": "void push Import Source ( Source source From URI Resolver ) { m import Source Stack . push ( source From URI Resolver ) ; }",
    "label": 1
  },
  {
    "text_1": "extracts protocol from the given url . protocol is a substring from the beginning of the url till \" : / / \" .",
    "text_2": "@ Nullable public static String extract Protocol ( @ Not Null String url ) { int index = url . index Of ( URL Util . SCHEME SEPARATOR ) ; if ( index < NUM ) return null ; return url . substring ( NUM , index ) ; }",
    "label": 1
  },
  {
    "text_1": "fill single payment with data",
    "text_2": "private Pair < Big Decimal , Big Decimal > fill Payment ( final Customer Order order , final Customer Order Delivery delivery , final Payment payment , final boolean single Pay , final Big Decimal running Total , final Big Decimal running Total Tax , final boolean last Delivery ) { if ( payment . get Transaction Reference Id ( ) = = null ) { payment . set Transaction Reference Id ( delivery . get Delivery Num ( ) ) ; } payment . set Order Shipment ( single Pay ? order . get Order num ( ) : delivery . get Delivery Num ( ) ) ; fill Payment Items ( delivery , payment ) ; fill Payment Shipment ( order , delivery , payment ) ; return fill Payment Amount ( order , delivery , payment , single Pay , running Total , running Total Tax , last Delivery ) ; }",
    "label": 1
  },
  {
    "text_1": "return the rule - internal target - source alignment grid .",
    "text_2": "public int [ ] [ ] e2 f ( ) { int e Dim = tgt End Exclusive - tgt Start Inclusive ; int [ ] [ ] e2 f = new int [ e Dim ] [ ] ; for ( int i = tgt Start Inclusive ; i < tgt End Exclusive ; + + i ) { int local Idx = i - tgt Start Inclusive ; int [ ] e2 f I = sentence Pair . e2 f ( i ) ; int src Align Dim = e2 f I . length ; e2 f [ local Idx ] = new int [ src Align Dim ] ; if ( src Align Dim > NUM ) { System . arraycopy ( e2 f I , NUM , e2 f [ local Idx ] , NUM , src Align Dim ) ; for ( int j = NUM ; j < src Align Dim ; + + j ) { e2 f [ local Idx ] [ j ] - = src Start Inclusive ; } } } return e2 f ; }",
    "label": 1
  },
  {
    "text_1": "find the fields constant that matches fieldid , or null if its not found .",
    "text_2": "public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ID ; case NUM : return CREATE TIME ; case NUM : return UPDATE TIME ; case NUM : return OPERATION ; case NUM : return STATUS ; case NUM : return SRC PATH ; case NUM : return SRC CLUSTER ; case NUM : return SRC DB ; case NUM : return SRC TABLE ; case NUM : return SRC PARTI TIONS ; case NUM : return SRC MODIFIED TIME ; case NUM : return RENAME TO DB ; case NUM : return RENAME TO TABLE ; case NUM : return RENAME TO PATH ; case NUM : return EXTRAS ; case NUM : return WAITING ON JOBS ; default : return null ; } }",
    "label": 1
  },
  {
    "text_1": "method for beancontextchild interface .",
    "text_2": "public void add Property Change Listener ( String property Name , Property Change Listener in pcl ) { pc Support . add Property Change Listener ( property Name , in pcl ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a sqlquery using the specified type and expression .",
    "text_2": "public SQL Query ( String type Name , String sql Expression ) { this ( sql Expression , type Name , null , DEFAULT QUERY RESULT TYPE , null ) ; }",
    "label": 1
  },
  {
    "text_1": "appends a new entry at the end of the table .",
    "text_2": "public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new Exception Table Entry ( start , end , handler , type ) ) ; }",
    "label": 1
  },
  {
    "text_1": "removes association for given key , returning value previously associated with key , or null if none .",
    "text_2": "public Object remove ( Object key ) { process Queue ( ) ; return map . remove ( Key . create ( key , null ) ) ; }",
    "label": 1
  },
  {
    "text_1": "finds the class with the specified binary name , from . class files .",
    "text_2": "private Class < ? > find Class Non Dal vik ( String name ) throws Class Not Found Exception { String path Name = CLASS PATH + name + STRING ; File path = new File ( path Name ) ; Random Access File raf ; try { raf = new Random Access File ( path , STRING ) ; } catch ( File Not Found Exception fnfe ) { throw new Class Not Found Exception ( STRING + path Name ) ; } byte [ ] file Data ; try { file Data = new byte [ ( int ) raf . length ( ) ] ; raf . read Fully ( file Data ) ; } catch ( IO Exception ioe ) { throw new Class Not Found Exception ( STRING + path Name ) ; } finally { try { raf . close ( ) ; } catch ( IO Exception ioe ) { } } try { return define Class ( name , file Data , NUM , file Data . length ) ; } catch ( Throwable th ) { throw new Class Not Found Exception ( STRING , th ) ; } }",
    "label": 1
  },
  {
    "text_1": "print an error to printstream",
    "text_2": "public void error ( String msg ) { print ( STRING + msg , out . err ) ; }",
    "label": 1
  },
  {
    "text_1": "builds the sort query",
    "text_2": "private Query Builder build Sort ( ) { Query Builder builder = new Query Builder ( ) ; Iterator < String > sort Iterator = m Sorting Order List . iterator ( ) ; while ( sort Iterator . has Next ( ) ) { builder . append ( sort Iterator . next ( ) ) ; if ( sort Iterator . has Next ( ) ) builder . append ( STRING ) ; } return builder ; }",
    "label": 1
  },
  {
    "text_1": "loads a class from a string classname",
    "text_2": "public static Object load Instance ( Class clazz , Object default Value ) { try { return clazz . new Instance ( ) ; } catch ( Throwable t ) { return default Value ; } }",
    "label": 1
  },
  {
    "text_1": "initializes this static object with the context of the calling activity .",
    "text_2": "public static void init ( Context context ) { if ( camera Manager = = null ) { camera Manager = new Camera Manager ( context ) ; } }",
    "label": 1
  },
  {
    "text_1": "formats an archive timestamp in way consistent with gemfire log dates . it will also be formatted to reflect the time zone the archive was created in .",
    "text_2": "public String format Time Millis ( long ts ) { synchronized ( time Formatter ) { return time Formatter . format ( new Date ( ts ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "tokenize the given string based on the seperator and put the tokens into an array of strings",
    "text_2": "public String [ ] tokenize ( String raw String ) { Vector < String > result = new Vector < String > ( ) ; String Tokenizer tk = new String Tokenizer ( raw String , m Seperator ) ; while ( tk . has More Tokens ( ) ) { result . add Element ( tk . next Token ( ) ) ; } String [ ] new Strings = new String [ result . size ( ) ] ; for ( int i = NUM ; i < result . size ( ) ; i + + ) { new Strings [ i ] = result . element At ( i ) ; } return new Strings ; }",
    "label": 1
  },
  {
    "text_1": "find all of the display elements descending from this element",
    "text_2": "static protected void expand Element ( Element el , List < Element > list ) { list . add All ( el . get Children ( STRING ) ) ; List < Element > children = el . get Children ( ) ; for ( int i = NUM ; i < children . size ( ) ; i + + ) { expand Element ( children . get ( i ) , list ) ; } }",
    "label": 1
  },
  {
    "text_1": "extract a substring terminated by a comma ( or end of string ) . commas in brackets are ignored as terminated with bracket nesting understood gracefully . if the returned string would being and end with a bracket then strip off the brackets . given a string like \" ( a , 3 ( b , c ) , d ) , x , y ) \" return \" a , 3 ( b , c ) , d \" . give a string like \" 3a , 2c \" return \" 3a \" .",
    "text_2": "protected String extract Substring ( String psz Src ) { int n Bracket = NUM ; int i ; String psz Return ; for ( i = NUM ; i < psz Src . length ( ) & & ( n Bracket > NUM | | psz Src . char At ( i ) ! = STRING ) ; i + + ) { if ( psz Src . char At ( i ) = = STRING ) { n Bracket + + ; } else if ( psz Src . char At ( i ) = = STRING ) { n Bracket - - ; } } if ( psz Src . char At ( NUM ) = = STRING ) { psz Return = psz Src . substring ( NUM , i - NUM ) ; } else { psz Return = psz Src . substring ( NUM , i ) ; } return psz Return ; }",
    "label": 1
  },
  {
    "text_1": "pre - load an icon into the persistent cache . queries for a component that does not exist in the package manager will be answered by the persistent cache .",
    "text_2": "public static void preload Icon ( Context context , Component Name component Name , Bitmap icon , int dpi ) { try { Package Manager package Manager = context . get Package Manager ( ) ; package Manager . get Activity Icon ( component Name ) ; return ; } catch ( Package Manager . Name Not Found Exception e ) { } final String key = component Name . flatten To String ( ) ; File Output Stream resource File = null ; try { resource File = context . open File Output ( get Resource Filename ( component Name ) , Context . MODE PRIVATE ) ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; if ( icon . compress ( android . graphics . Bitmap . Compress Format . PNG , NUM , os ) ) { byte [ ] buffer = os . to Byte Array ( ) ; resource File . write ( buffer , NUM , buffer . length ) ; } else { Log . w ( TAG , STRING + key ) ; return ; } } catch ( File Not Found Exception e ) { Log . w ( TAG , STRING + key , e ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING + key , e ) ; } finally { if ( resource File ! = null ) { try { resource File . close ( ) ; } catch ( IO Exception e ) { Log . d ( TAG , STRING + key , e ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "initialize the field definition from the information in the dd r record . this is called by d df module . open ( ) .",
    "text_2": "public boolean initialize ( DDF Module po Module In , String psz Tag In , byte [ ] pach Field Area ) { int i FD Offset = po Module In . field Control Length ; po Module = po Module In ; psz Tag = psz Tag In ; data struct code = Data Struct Code . get ( ( char ) pach Field Area [ NUM ] ) ; data type code = Data Type Code . get ( ( char ) pach Field Area [ NUM ] ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + psz Tag In + STRING + data struct code + STRING + data type code + STRING + i FD Offset ) ; } byte [ ] temp Data = new byte [ pach Field Area . length - i FD Offset ] ; System . arraycopy ( pach Field Area , i FD Offset , temp Data , NUM , pach Field Area . length - i FD Offset ) ; Mutable Int n Chars Consumed = new Mutable Int ( ) ; field Name = DDF Utils . fetch Variable ( temp Data , temp Data . length , DDF UNIT TERMINATOR , DDF FIELD TERMINATOR , n Chars Consumed ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + psz Tag In + STRING + field Name ) ; } i FD Offset + = n Chars Consumed . value ; temp Data = new byte [ pach Field Area . length - i FD Offset ] ; System . arraycopy ( pach Field Area , i FD Offset , temp Data , NUM , pach Field Area . length - i FD Offset ) ; array Descr = DDF Utils . fetch Variable ( temp Data , temp Data . length , DDF UNIT TERMINATOR , DDF FIELD TERMINATOR , n Chars Consumed ) ; i FD Offset + = n Chars Consumed . value ; temp Data = new byte [ pach Field Area . length - i FD Offset ] ; System . arraycopy ( pach Field Area , i FD Offset , temp Data , NUM , pach Field Area . length - i FD Offset ) ; format Controls = DDF Utils . fetch Variable ( temp Data , temp Data . length , DDF UNIT TERMINATOR , DDF FIELD TERMINATOR , n Chars Consumed ) ; if ( data struct code ! = Data Struct Code . ELE MENTARY ) { if ( ! build Subfield Defns ( array Descr ) ) { return BOOL ; } if ( ! apply Formats ( format Controls ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "remove the widget from the current selection",
    "text_2": "public void remove ( Constraint Widget widget ) { Element to Unselect = null ; for ( Element selection : m Selected Widgets ) { if ( selection . widget = = widget ) { to Unselect = selection ; break ; } } if ( to Unselect ! = null ) { m Selected Widgets . remove ( to Unselect ) ; } selection Has Changed ( ) ; }",
    "label": 1
  },
  {
    "text_1": "queue contains all elements of collection used to initialize",
    "text_2": "public void test Constructor NUM ( ) { Integer [ ] ints = new Integer [ SIZE ] ; for ( int i = NUM ; i < SIZE ; + + i ) ints [ i ] = new Integer ( i ) ; Linked Blocking Queue q = new Linked Blocking Queue ( Arrays . as List ( ints ) ) ; for ( int i = NUM ; i < SIZE ; + + i ) assert Equals ( ints [ i ] , q . poll ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "basic test of the concurrent create and discovery of a kb .",
    "text_2": "public void test concurrent KB Create And Discovery ( ) throws Exception { final String namespace = get Name ( ) ; final Properties properties = get Properties ( ) ; Journal jnl = null ; try { jnl = new Journal ( properties ) ; do Concurrent Create And Discovery Test ( jnl , namespace ) ; } finally { if ( jnl ! = null ) jnl . destroy ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "receive bytes transmitted from connection at remote endpoint .",
    "text_2": "void receive ( int length , Data Input Stream in ) throws IO Exception { synchronized ( lock ) { if ( ( pos > NUM ) & & ( ( buffer . length - present ) < length ) ) { System . arraycopy ( buffer , pos , buffer , NUM , present - pos ) ; present - = pos ; pos = NUM ; } if ( ( buffer . length - present ) < length ) throw new IO Exception ( STRING ) ; in . read Fully ( buffer , present , length ) ; present + = length ; requested - = length ; lock . notify All ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "hashcode ( ) for unequal bigdecimals",
    "text_2": "public void test Hash Code Unequal ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; assert True ( STRING , a Number . hash Code ( ) ! = b Number . hash Code ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "replace the last array length parameter types with the component type of arraytype .",
    "text_2": "Method Type as S pre ader Type ( Class < ? > array Type , int array Length ) { assert ( parameter Count ( ) > = array Length ) ; int spread Pos = ptypes . length - array Length ; if ( array Length = = NUM ) return this ; if ( array Type = = Object [ ] . class ) { if ( is Generic ( ) ) return this ; if ( spread Pos = = NUM ) { Method Type res = generic Method Type ( array Length ) ; if ( rtype ! = Object . class ) { res = res . change Return Type ( rtype ) ; } return res ; } } Class < ? > elem Type = array Type . get Component Type ( ) ; assert ( elem Type ! = null ) ; for ( int i = spread Pos ; i < ptypes . length ; i + + ) { if ( ptypes [ i ] ! = elem Type ) { Class < ? > [ ] fixed P types = ptypes . clone ( ) ; Arrays . fill ( fixed P types , i , ptypes . length , elem Type ) ; return method Type ( rtype , fixed P types ) ; } } return this ; }",
    "label": 1
  },
  {
    "text_1": "reads all the data from the supplied inputstream into a byte array .",
    "text_2": "public static byte [ ] read Data ( final Input Stream input ) throws IO Exception { final byte [ ] input Buffer = new byte [ BUFFER LENGTH ] ; final Byte Array Output Stream byte Output = new Byte Array Output Stream ( BUFFER LENGTH ) ; int bytes Read ; while ( ( bytes Read = input . read ( input Buffer ) ) ! = - NUM ) { byte Output . write ( input Buffer , NUM , bytes Read ) ; } final byte [ ] r = byte Output . to Byte Array ( ) ; byte Output . close ( ) ; return r ; }",
    "label": 1
  },
  {
    "text_1": "removes the given dataset from this data object . also recalculates all minimum and maximum values . returns true if a dataset was removed , false if no dataset could be removed .",
    "text_2": "public boolean remove Data Set ( T d ) { if ( d = = null ) return BOOL ; boolean removed = m Data Sets . remove ( d ) ; if ( removed ) { mY Val Count - = d . get Entry Count ( ) ; mY Value Sum - = d . get Y Value Sum ( ) ; calc Min Max ( m Data Sets ) ; } return removed ; }",
    "label": 1
  },
  {
    "text_1": "transforms all rows from the cursor and put them in a read - only set .",
    "text_2": "public < Result T > Set < Result T > to Set ( Converter < Result T > converter ) { try { if ( is Empty ( cursor ) ) { return Collections . empty Set ( ) ; } return populate ( converter , new Hash Set < Result T > ( cursor . get Count ( ) ) ) ; } finally { close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "initializes a new point ( x , y ) .",
    "text_2": "public Point NUM D ( double x , double y ) { if ( Double . is Infinite ( x ) | | Double . is Infinite ( y ) ) throw new Illegal Argument Exception ( STRING ) ; if ( Double . is Na N ( x ) | | Double . is Na N ( y ) ) throw new Illegal Argument Exception ( STRING ) ; if ( x = = NUM ) this . x = NUM ; else this . x = x ; if ( y = = NUM ) this . y = NUM ; else this . y = y ; }",
    "label": 1
  },
  {
    "text_1": "write the specified characters from a string .",
    "text_2": "@ Override public void write ( String str , int st , int end ) throws IO Exception { out . write ( str , st , end ) ; }",
    "label": 1
  },
  {
    "text_1": "pass mouseevent straight through to delegate",
    "text_2": "@ Override public void mouse Moved ( Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }",
    "label": 1
  },
  {
    "text_1": "listen for updates to the update manager .",
    "text_2": "public void add Listener ( Update Manager Listener listener ) { listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "returns original with all occurrences of old substring replaced by new substring",
    "text_2": "public static String replace All ( String original , String old Substring , String new Substring ) { return replace ( original , old Substring , new Substring , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "load the model found in the filename . its dependencies can be loaded subsequently .",
    "text_2": "public E Object load Model ( String filename , String cwd ) { URI file URI = normalize URI ( URI . create URI ( filename ) ) ; URI cwd URI = normalize URI ( URI . create URI ( cwd ) ) ; return load Model ( file URI , cwd URI ) ; }",
    "label": 1
  },
  {
    "text_1": "validate the passed request object it should have site id and file path",
    "text_2": "@ Override public void validate Request ( Generic Attribute Resolve Request request ) throws Bad Attribute Resolve Request Exception { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING ) ; String site Id = request . get Site ( ) ; if ( null = = site Id ) throw new Bad Attribute Resolve Request Exception ( HDFS Resource Constants . HDFS RESOURCE RESOLVE FORMAT HINT ) ; String file Path = request . get Query ( ) ; if ( null = = file Path | | ! file Path . starts With ( STRING ) ) throw new Bad Attribute Resolve Request Exception ( HDFS Resource Constants . HDFS RESOURCE RESOLVE FORMAT HINT ) ; if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "initially , set to the top level goals",
    "text_2": "private void initialize Name Goals ( Map < Test Case , Set < Test Fitness Function > > test To Goals ) { for ( Map . Entry < Test Case , Set < Test Fitness Function > > entry : test To Goals . entry Set ( ) ) { Set < Test Fitness Function > goals = new Linked Hash Set < > ( ) ; List < Test Fitness Function > top Goals = get Top Goals ( entry . get Value ( ) ) ; if ( top Goals . is Empty ( ) ) { } else if ( top Goals . size ( ) < = MAX SIMI LAR GO ALS ) { for ( Test Fitness Function goal : top Goals ) { goals . add ( goal ) ; String goal Name = get Test Name ( entry . get Key ( ) , goals ) ; if ( goal Name . length ( ) > MAX CHARS ) { goals . remove ( goal ) ; break ; } } } else { goals . add ( choose Representative Goal ( entry . get Key ( ) , top Goals ) ) ; } test To Goals . put ( entry . get Key ( ) , goals ) ; } }",
    "label": 1
  },
  {
    "text_1": "determines and returns the conservative approximation for the knn distances of this node as the maximum of the conservative approximat ions of all entries .",
    "text_2": "protected Approximation Line conserv ative Knn Distance Approximation ( int k max ) { int k NUM = k max ; double y NUM = Double . NEGATIVE INFINITY ; double y kmax = Double . NEGATIVE INFINITY ; for ( int i = NUM ; i < get Num Entries ( ) ; i + + ) { Mk Co P Entry entry = get Entry ( i ) ; Approximation Line approx = entry . get Con serv ative Knn Distance Approximation ( ) ; k NUM = Math . min ( approx . get K NUM ( ) , k NUM ) ; } for ( int i = NUM ; i < get Num Entries ( ) ; i + + ) { Mk Co P Entry entry = get Entry ( i ) ; Approximation Line approx = entry . get Con serv ative Knn Distance Approximation ( ) ; double entry y NUM = approx . get Value At ( k NUM ) ; double entry y kmax = approx . get Value At ( k max ) ; if ( ! Double . is Infinite ( entry y NUM ) ) { y NUM = Math . max ( entry y NUM , y NUM ) ; } if ( ! Double . is Infinite ( entry y kmax ) ) { y kmax = Math . max ( entry y kmax , y kmax ) ; } } double m = ( y kmax - y NUM ) / ( Math . log ( k max ) - Math . log ( k NUM ) ) ; double t = y NUM - m * Math . log ( k NUM ) ; return new Approximation Line ( k NUM , m , t ) ; }",
    "label": 1
  },
  {
    "text_1": "reads model from given virtual file .",
    "text_2": "public static Model read From ( Virtual File file ) throws Server Exception , Forbidden Exception , IO Exception { require Non Null ( file , STRING ) ; return fetch Model ( XML Tree . from ( file . get Content ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "return the passed in value as an unsigned byte array .",
    "text_2": "public static byte [ ] as Unsigned Byte Array ( Big Integer value ) { byte [ ] bytes = value . to Byte Array ( ) ; if ( bytes [ NUM ] = = NUM ) { byte [ ] tmp = new byte [ bytes . length - NUM ] ; System . arraycopy ( bytes , NUM , tmp , NUM , tmp . length ) ; return tmp ; } return bytes ; }",
    "label": 1
  },
  {
    "text_1": "closes ' closeable ' , ignoring any checked exceptions . does nothing if ' closeable ' is null .",
    "text_2": "public static void close Quietly ( Closeable closeable ) { if ( closeable ! = null ) { try { closeable . close ( ) ; } catch ( Runtime Exception re thrown ) { throw re thrown ; } catch ( Exception ignored ) { } } }",
    "label": 1
  },
  {
    "text_1": "support for reporting changes for constrained integer properties . this method can be called before a constrained property will be changed and it will send the appropriate propertychangeevent to any registered vetoablechange listeners .",
    "text_2": "protected final void fire Vetoable Change ( String property Name , int old Value , int new Value ) throws Property Veto Exception { Vetoable Change Support a Veto Support = this . veto Support ; if ( a Veto Support = = null ) { return ; } a Veto Support . fire Vetoable Change ( property Name , Integer . value Of ( old Value ) , Integer . value Of ( new Value ) ) ; }",
    "label": 1
  },
  {
    "text_1": "checks basic prediction of the scheme , for simple non - trouble some datasets .",
    "text_2": "protected boolean [ ] can Predict ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean predictor Missing = BOOL , class Missing = BOOL ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a component that is used to configure a setting .",
    "text_2": "private static void add Component ( final J Panel panel , final Component component , final String description , final String hint ) { final J Panel setting Panel = new J Panel ( new Border Layout ( ) ) ; setting Panel . set Border ( STANDARD EMPTY BORDER ) ; setting Panel . add ( new J Label ( description ) , Border Layout . CENTER ) ; final J Panel inner Panel = new J Panel ( new Border Layout ( ) ) ; inner Panel . add ( component , Border Layout . CENTER ) ; final J Hint Icon hint Popup = new J Hint Icon ( hint ) ; hint Popup . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; inner Panel . add ( hint Popup , Border Layout . EAST ) ; setting Panel . add ( inner Panel , Border Layout . EAST ) ; panel . add ( setting Panel ) ; }",
    "label": 1
  },
  {
    "text_1": "called when the user presses the back key . this is only going to be called on phone .",
    "text_2": "public boolean on Back Pressed ( ) { if ( does Drawer Exist ( ) ) { if ( m Drawer . is Drawer Visible ( Gravity . START ) ) { m Drawer . close Drawer ( Gravity . START ) ; return BOOL ; } } if ( m Content View . on Back Pressed ( ) ) return BOOL ; if ( ! m State Stack . empty ( ) ) { m State Stack . pop ( ) ; if ( ! m State Stack . empty ( ) ) { set State ( m State Stack . pop ( ) ) ; return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "update program args for project gwt > = 2 . 7 use this for dev mode - no super dev mode and nothing for super dev mode .",
    "text_2": "private void update Gwt NUM On ( I Java Project java Project , List < String > program Args , int index Disabled , int index Enabled , boolean super Dev Mode Enabled ) { if ( index Enabled > - NUM ) { program Args . remove ( index Enabled ) ; } if ( index Disabled > - NUM ) { program Args . remove ( index Disabled ) ; } if ( ! super Dev Mode Enabled ) { program Args . add ( NUM , SUPER DEV MODE DISABLED ARG ) ; } }",
    "label": 1
  },
  {
    "text_1": "peforms an operation log restore for a member .",
    "text_2": "private void perform Restore ( File member Dir , File backup Dir ) throws Exception { List < File > if Files = File Util . find All ( member Dir , STRING ) ; for ( File file : if Files ) { file . delete ( ) ; } List < File > op logs = File Util . find All ( member Dir , OP LOG REGEX ) ; for ( File file : op logs ) { file . delete ( ) ; } File restore Script = new File ( backup Dir , STRING ) ; if ( ! restore Script . exists ( ) ) { restore Script = new File ( backup Dir , STRING ) ; } assert True ( restore Script . exists ( ) ) ; assert Equals ( NUM , execute ( restore Script . get Absolute Path ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "removes all text edits from this group .",
    "text_2": "public void clear Text Edits ( ) { f Edits . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "append css definition to a stream",
    "text_2": "public void append CSS Definition ( String Builder buf ) { buf . append ( STRING ) ; buf . append ( name ) ; buf . append ( STRING ) ; for ( Pair < String , String > pair : statements ) { buf . append ( pair . get First ( ) ) ; buf . append ( STRING ) ; buf . append ( pair . get Second ( ) ) ; buf . append ( STRING ) ; } buf . append ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the best parse , the one with maximum expected labelled recall . assumes that the max c arrays have been filled .",
    "text_2": "public Tree < String > extract Best Max Rule Parse ( int start , int end , List < String > sentence ) { return extract Best Max Rule Parse NUM ( start , end , NUM , sentence ) ; }",
    "label": 1
  },
  {
    "text_1": "writes chars of the given string to the current position of this buffer , and increases the position by the number of chars written .",
    "text_2": "public Char Buffer put ( String str , int start , int end ) { if ( is Read Only ( ) ) { throw new Read Only Buffer Exception ( ) ; } if ( start < NUM | | end < start | | end > str . length ( ) ) { throw new Index Out Of Bounds Exception ( STRING + str . length ( ) + STRING + start + STRING + end ) ; } if ( end - start > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = start ; i < end ; i + + ) { put ( str . char At ( i ) ) ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "indicates a mouse wheel event .",
    "text_2": "public boolean is Wheel Event ( ) { return is Wheel Event ; }",
    "label": 1
  },
  {
    "text_1": "checks if specified mime type matches one of the fileformat ' s mime types . the mime types are compared ignoring upper / lower - case differences .",
    "text_2": "public boolean has MIME Type ( String mime Type ) { if ( mime Type = = null ) return BOOL ; String type = mime Type ; if ( mime Type . index Of ( STRING ) > NUM ) { type = mime Type . substring ( NUM , mime Type . index Of ( STRING ) ) ; } for ( String mt : this . mime Types ) { if ( mt . equals Ignore Case ( mime Type ) ) { return BOOL ; } if ( mime Type ! = type & & mt . equals Ignore Case ( type ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "assert that the onsubscribe method hasn ' t been called at all .",
    "text_2": "public final Test Subscriber assert Not Subscribed ( ) { String prefix = STRING ; if ( done . get Count ( ) ! = NUM ) { prefix = STRING ; } if ( subscription . get ( ) ! = null ) { fail ( prefix , STRING , errors ) ; } else if ( ! errors . is Empty ( ) ) { fail ( prefix , STRING , errors ) ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "get details for the host v center change method note : in order to maintain backwards compatibility , do not change the signature of this method .",
    "text_2": "@ Suppress Warnings ( STRING ) public List < String > host Vcenter Change Details ( URI host Id , URI cluster Id , URI datacenter Id , boolean is Vcenter ) { List < String > result = Lists . new Array List ( ) ; Host host = db Client . query Object ( Host . class , host Id ) ; Vcenter Data Center datacenter = db Client . query Object ( Vcenter Data Center . class , datacenter Id ) ; if ( host ! = null & & datacenter ! = null ) { result . add ( Compute System Dialog Properties . get Message ( STRING , host . get Label ( ) , datacenter . get Label ( ) ) ) ; result . add All ( host Cluster Change Details ( host Id , cluster Id , datacenter Id , is Vcenter ) ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "return null if token is malformed or expired",
    "text_2": "public List < byte [ ] > try Decode ( final String target Token ) { final Byte Buffer payload Buf = extract Valid Payload Fields ( target Token ) ; if ( payload Buf = = null ) { return null ; } final List < byte [ ] > fields = new Array List < > ( ) ; try { byte [ ] field = null ; while ( ( field = try Read Payload Next Field ( payload Buf ) ) . length > NUM ) { fields . add ( field ) ; if ( fields . size ( ) > MAX FIELD SIZE ) { return null ; } } return fields ; } catch ( final Buffer Underflow Exception e ) { return null ; } }",
    "label": 1
  },
  {
    "text_1": "continues a multiple - part encryption / decryption operation . the data is encrypted or decrypted , depending on how this cipher was initialized .",
    "text_2": "@ Override public int update ( Byte Buffer in Buffer , Byte Buffer out Buffer ) throws Short Buffer Exception { return cipher . update ( in Buffer , out Buffer ) ; }",
    "label": 1
  },
  {
    "text_1": "read the properties file and unregister its configurable jam on jmx beans . note if the file has changed since the server was brought up the beans unregistered might not match those that were loaded .",
    "text_2": "private static void unregister M beans From Props File ( M Bean Server m Bean Server ) throws Exception { Jam on Properties Loader loader = new Jam on Properties Loader ( ) ; List < String > jam on Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jam on Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m X bean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m X bean ) ) ; Monitor MX Bean m X bean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m X bean Delta ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "strips any tabs which are at the beginning on",
    "text_2": "public static String clean Tabs ( String yaml ) { if ( yaml . contains ( STRING ) ) { LOGGER . warn ( STRING + STRING + STRING , TAB AS SPACES . length ( ) ) ; List < String > lines = NEWLINE SPLITTER . split To List ( yaml ) ; String Builder sb = new String Builder ( ) ; for ( String line : lines ) { String clean Line = replace Starting Tabs With Spaces ( line ) ; sb . append ( clean Line ) ; sb . append ( STRING ) ; } return sb . to String ( ) ; } else { return yaml ; } }",
    "label": 1
  },
  {
    "text_1": "im it ates a click on the search button to initiate a search .",
    "text_2": "public void search ( ) { perform Search ( ) ; }",
    "label": 1
  },
  {
    "text_1": "if this occurrence update is called from within a declaration update ( i . e . , to update the call inside the newly created delegate ) , the old node does not yet exist and therefore cannot be a move target . normally , always use create move target as this has the advantage of being able to add changes inside changed nodes ( for example , a method call within a method call , see test case 4 ) and preserving comments inside calls .",
    "text_2": "protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }",
    "label": 1
  },
  {
    "text_1": "set a conditional expression that restricts which rows will cause statements to be performed when the trigger is activated . by default , the statements will execute for every row affected by the statement that activates the trigger .",
    "text_2": "public Trigger when ( Criterion criterion ) { if ( criterion ! = null ) { criterions . add ( criterion ) ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "try to replace source of field with all possible choices",
    "text_2": "@ Override public boolean mutate ( Test Case test , Test Factory factory ) { if ( Randomness . next Double ( ) > = Properties . P CHANGE PARAMETER ) return BOOL ; if ( ! is Static ( ) ) { Variable Reference source = get Source ( ) ; List < Variable Reference > objects = test . get Objects ( source . get Type ( ) , get Position ( ) ) ; objects . remove ( source ) ; if ( ! objects . is Empty ( ) ) { set Source ( Randomness . choice ( objects ) ) ; return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "the real guts of par sen etwork response . broken out for readability .",
    "text_2": "private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; Bitmap bitmap = null ; if ( m Max Width = = NUM & & m Max Height = = NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width ) ; decode Options . in Just Decode Bounds = BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap ! = null & & ( temp Bitmap . get Width ( ) > desired Width | | temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap = = null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "two arguments arct ang ent function",
    "text_2": "public static double atan NUM ( double y , double x ) { if ( Double . is Na N ( x ) | | Double . is Na N ( y ) ) { return Double . Na N ; } if ( y = = NUM ) { final double result = x * y ; final double inv x = NUM / x ; final double in vy = NUM / y ; if ( inv x = = NUM ) { if ( x > NUM ) { return y ; } else { return copy Sign ( Math . PI , y ) ; } } if ( x < NUM | | inv x < NUM ) { if ( y < NUM | | in vy < NUM ) { return - Math . PI ; } else { return Math . PI ; } } else { return result ; } } if ( y = = Double . POSITIVE INFINITY ) { if ( x = = Double . POSITIVE INFINITY ) { return Math . PI * F NUM NUM ; } if ( x = = Double . NEGATIVE INFINITY ) { return Math . PI * F NUM NUM ; } return Math . PI * F NUM NUM ; } if ( y = = Double . NEGATIVE INFINITY ) { if ( x = = Double . POSITIVE INFINITY ) { return - Math . PI * F NUM NUM ; } if ( x = = Double . NEGATIVE INFINITY ) { return - Math . PI * F NUM NUM ; } return - Math . PI * F NUM NUM ; } if ( x = = Double . POSITIVE INFINITY ) { if ( y > NUM | | NUM / y > NUM ) { return NUM ; } if ( y < NUM | | NUM / y < NUM ) { return - NUM ; } } if ( x = = Double . NEGATIVE INFINITY ) { if ( y > NUM | | NUM / y > NUM ) { return Math . PI ; } if ( y < NUM | | NUM / y < NUM ) { return - Math . PI ; } } if ( x = = NUM ) { if ( y > NUM | | NUM / y > NUM ) { return Math . PI * F NUM NUM ; } if ( y < NUM | | NUM / y < NUM ) { return - Math . PI * F NUM NUM ; } } final double r = y / x ; if ( Double . is Infinite ( r ) ) { return atan ( r , NUM , x < NUM ) ; } double ra = double High Part ( r ) ; double rb = r - ra ; final double xa = double High Part ( x ) ; final double xb = x - xa ; rb + = ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; final double temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; if ( ra = = NUM ) { ra = copy Sign ( NUM , y ) ; } final double result = atan ( ra , rb , x < NUM ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "parses the current node and returns the number of elements added .",
    "text_2": "protected int parse And Add Node ( Xml Resource Parser parser , Hash Map < String , Tag Parser > tag Parser Map , Array List < Long > screen Ids ) throws Xml Pull Parser Exception , IO Exception { if ( TAG INCLUDE . equals ( parser . get Name ( ) ) ) { final int res Id = get Attribute Resource Value ( parser , ATTR WORKSPACE , NUM ) ; if ( res Id ! = NUM ) { return parse Layout ( res Id , screen Ids ) ; } else { return NUM ; } } m Values . clear ( ) ; parse Container And Screen ( parser , m Temp ) ; final long container = m Temp [ NUM ] ; final long screen Id = m Temp [ NUM ] ; m Values . put ( Launcher Settings . Favorites . CONTAINER , container ) ; m Values . put ( Launcher Settings . Favorites . SCREEN , screen Id ) ; m Values . put ( Launcher Settings . Favorites . CELL X , convert To Distance From End ( get Attribute Value ( parser , ATTR X ) , m Column Count ) ) ; m Values . put ( Launcher Settings . Favorites . CEL LY , convert To Distance From End ( get Attribute Value ( parser , ATTR Y ) , m Row Count ) ) ; Tag Parser tag Parser = tag Parser Map . get ( parser . get Name ( ) ) ; if ( tag Parser = = null ) { if ( LOGD ) Log . d ( TAG , STRING + parser . get Name ( ) ) ; return NUM ; } long new Element Id = tag Parser . parse And Add ( parser ) ; if ( new Element Id > = NUM ) { if ( ! screen Ids . contains ( screen Id ) & & container = = Launcher Settings . Favorites . CONTAINER DESKTOP ) { screen Ids . add ( screen Id ) ; } return NUM ; } return NUM ; }",
    "label": 1
  },
  {
    "text_1": "removes the specified attribute values from am sdk organization . the organ zi ation attribute names are defined in the id repo service .",
    "text_2": "void remove Attribute Values ( String attr Name , Set values ) throws SMS Exception { if ( attr Name ! = null ) { Map attrs = get Attributes ( ) ; Set orig Values = ( Set ) attrs . get ( attr Name ) ; if ( orig Values ! = null & & ! orig Values . is Empty ( ) ) { Set new Values = new Hash Set ( orig Values ) ; new Values . remove All ( values ) ; if ( new Values . is Empty ( ) ) { remove Attribute ( attr Name ) ; } else { Map new Attrs = new Hash Map ( ) ; new Attrs . put ( attr Name , new Values ) ; set Attributes ( new Attrs ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "produce a string from a number .",
    "text_2": "public static String number To String ( Number number ) throws JSON Exception { if ( number = = null ) { throw new JSON Exception ( STRING ) ; } test Validity ( number ) ; String string = number . to String ( ) ; if ( string . index Of ( STRING ) > NUM & & string . index Of ( STRING ) < NUM & & string . index Of ( STRING ) < NUM ) { while ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } if ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } } return string ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the object ' o ' is an instance of any class in the collection",
    "text_2": "private static boolean instance Of Any ( Object o , Collection < Class > classes ) { for ( Class c : classes ) { if ( c . is Instance ( o ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "- does basic verification of the file - reads the header table for this font ( within a collection ) - reads the names ( full , family ) . - determines the style of the font . - initializes the cmap",
    "text_2": "public True Type Font ( String plat name , Object native Names , int f Index , boolean java Raster izer , boolean use File Pool ) throws Font Format Exception { super ( plat name , native Names ) ; use Java Raster izer = java Raster izer ; font Rank = Font NUM D . TTF RANK ; try { verify ( use File Pool ) ; init ( f Index ) ; if ( ! use File Pool ) { close ( ) ; } } catch ( Throwable t ) { close ( ) ; if ( t instanceof Font Format Exception ) { throw ( Font Format Exception ) t ; } else { throw new Font Format Exception ( STRING ) ; } } Disposer . add Object Record ( this , disposer Record ) ; }",
    "label": 1
  },
  {
    "text_1": "returns all the keys assigned statically , e . g . by param or literal .",
    "text_2": "@ Override public void fill Assigned Keys ( Set < String > keys ) { keys . add ( key Column . name ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "remove an incremental classifier listener",
    "text_2": "public synchronized void remove Incremental Classifier Listener ( Incremental Classifier Listener cl ) { m incremental Classifier Listeners . remove ( cl ) ; }",
    "label": 1
  },
  {
    "text_1": "decode the base 64 - encoded data in input and return the data in a new byte array . the padding ' = ' characters at the end are considered optional , but if any are present , there must be the correct number of them .",
    "text_2": "public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * NUM / NUM ] ) ; if ( ! decoder . process ( input , offset , len , BOOL ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( decoder . op = = decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM , temp , NUM , decoder . op ) ; return temp ; }",
    "label": 1
  },
  {
    "text_1": "steps through the ordered ' strength ' array , and compares it with the ' supported ciphers ' array . the cipher returned represents the best possible cipher based on the strength preference and the available ciphers on both the server and client environments .",
    "text_2": "private String find Cipher And Strength ( byte [ ] supported Ciphers , String [ ] tokens ) { byte s ; for ( int i = NUM ; i < strength . length ; i + + ) { if ( ( s = strength [ i ] ) ! = NUM ) { for ( int j = NUM ; j < supported Ciphers . length ; j + + ) { if ( s = = supported Ciphers [ j ] & & ( specified Cipher = = null | | specified Cipher . equals ( tokens [ j ] ) ) ) { switch ( s ) { case HIGH STRENGTH : negotiated Strength = STRING ; break ; case MEDIUM STRENGTH : negotiated Strength = STRING ; break ; case LOW STRENGTH : negotiated Strength = STRING ; break ; } return tokens [ j ] ; } } } } return null ; }",
    "label": 1
  },
  {
    "text_1": "parse the attributes passed to the view from the xml",
    "text_2": "private void parse Attributes ( Typed Array a ) { bar Width = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Bar Width , bar Width ) ; rim Width = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Rim Width , rim Width ) ; spin Speed = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Spin Speed , spin Speed ) ; bar Length = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Bar Length , bar Length ) ; delay Millis = a . get Integer ( R . styleable . Progress Wheel pw Delay Millis , delay Millis ) ; if ( delay Millis < NUM ) { delay Millis = NUM ; } if ( a . has Value ( R . styleable . Progress Wheel pw Text ) ) { set Text ( a . get String ( R . styleable . Progress Wheel pw Text ) ) ; } bar Color = a . get Color ( R . styleable . Progress Wheel pw Bar Color , bar Color ) ; text Color = a . get Color ( R . styleable . Progress Wheel pw Text Color , text Color ) ; rim Color = a . get Color ( R . styleable . Progress Wheel pw Rim Color , rim Color ) ; circle Color = a . get Color ( R . styleable . Progress Wheel pw Circle Color , circle Color ) ; contour Color = a . get Color ( R . styleable . Progress Wheel pw Contour Color , contour Color ) ; text Size = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Text Size , text Size ) ; contour Size = a . get Dimension ( R . styleable . Progress Wheel pw Contour Size , contour Size ) ; a . recycle ( ) ; }",
    "label": 1
  },
  {
    "text_1": "find the fields constant that matches fieldid , or null if its not found .",
    "text_2": "public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return HOST ; case NUM : return PORT ; case NUM : return ID ; case NUM : return STATE ; case NUM : return TIMESTAMP ; case NUM : return VERSION ; default : return null ; } }",
    "label": 1
  },
  {
    "text_1": "check whether the given string is a valid identifier according to the java language specifications . see the java language specification second edition , section 3 . 8 for the definition of what is a valid identifier .",
    "text_2": "public final static boolean is Valid Java Identifier ( String s ) { if ( s = = null | | s . length ( ) = = NUM ) { return BOOL ; } char [ ] c = s . to Char Array ( ) ; if ( ! Character . is Java Identifier Start ( c [ NUM ] ) ) { return BOOL ; } for ( int i = NUM ; i < c . length ; i + + ) { if ( ! Character . is Java Identifier Part ( c [ i ] ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "returns whether two type references refer to the same type . note that a parameterized type will not match its corresponding raw type ( but a generic definition will match its raw type ) .",
    "text_2": "public static boolean are Equivalent ( final Type Reference a , final Type Reference b ) { return are Equivalent ( a , b , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "return single logout service element for castle as idp .",
    "text_2": "private Element create Single Log Out For Castle As IDP ( String binding ) throws Exception { String entity ID = idm Client . get Entity ID ( tenant Name ) ; String sso Loc = convert To IPV NUM Short Form ( entity ID ) ; if ( sso Loc = = null ) { sso Loc = tenant Name ; } String slo Loc = sso Loc . replace All ( STRING , STRING ) ; Element s los Ele = create End Point ( SAML Names . SLO S , binding , slo Loc , null ) ; return s los Ele ; }",
    "label": 1
  },
  {
    "text_1": "check if all parameters have been set .",
    "text_2": "protected void check Parameters ( ) { if ( parameters ! = null ) { for ( int i = NUM , size = parameters . size ( ) ; i < size ; i + + ) { Parameter param = parameters . get ( i ) ; param . check Set ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "method which renders the text of the current button .",
    "text_2": "protected void paint Text ( Graphics g , Abstract Button b , Rectangle text Rect , String text ) { paint Text ( g , ( J Component ) b , text Rect , text ) ; }",
    "label": 1
  },
  {
    "text_1": "returns items whose bounds intersect the given bounds .",
    "text_2": "public List query ( double x1 , double x2 ) { return super . query ( new Interval ( Math . min ( x1 , x2 ) , Math . max ( x1 , x2 ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "adds each element of ' assignments ' to ' p ' , treating each element as an assignment in the form \" key = value \" .",
    "text_2": "private static void parse Property Assignments ( Properties p , String [ ] assignments ) { for ( String assignment : assignments ) { int split = assignment . index Of ( STRING ) ; String key = assignment . substring ( NUM , split ) ; String value = assignment . substring ( split + NUM ) ; p . put ( key , value ) ; } }",
    "label": 1
  },
  {
    "text_1": "checks if the object is mutable",
    "text_2": "public boolean is Mutable ( ) { return mutable ; }",
    "label": 1
  },
  {
    "text_1": "remove the specific name registration . other registration of the same stream scope may still exist . no - op if name is not registered .",
    "text_2": "public synchronized void unregister ( String name ) { Stream Scope < ? > stream Scope = by Name Map . remove ( name ) ; if ( stream Scope = = null ) return ; List < String > names = by Stream Scope Map . get ( stream Scope ) ; names . remove ( name ) ; if ( names . is Empty ( ) ) by Stream Scope Map . remove ( stream Scope ) ; }",
    "label": 1
  },
  {
    "text_1": "formats the given number into one where thousands are separated by a space .",
    "text_2": "public static String format Number ( final long number ) { long divided = number ; final String Buffer sb = new String Buffer ( ) ; while ( divided > NUM ) { long rest = divided % NUM ; sb . insert ( NUM , STRING + String . format ( STRING , rest ) ) ; divided = divided / NUM ; } long rest = divided % NUM ; sb . insert ( NUM , rest ) ; return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a new us re like through the frontend , but also does activates the account to do sso see the methods to create a hash and use those ones !",
    "text_2": "public Long add New User ( String SID , String username , String userpass , String lastname , String firstname , String email , String addition al name , String street , String zip , String fax , long states id , String town , long language id , String base URL ) throws Axis Fault { try { Long users id = session Management . check Session ( SID ) ; Long user level = user Management . get User Level By ID ( users id ) ; if ( auth Level Management . check Web Service Level ( user level ) ) { Configuration conf = cfg Management . get Conf Key ( NUM , STRING ) ; String j Name time Zone = STRING ; if ( conf ! = null ) { j Name time Zone = conf . get Conf value ( ) ; } Long user id = user Management . register User ( username , userpass , lastname , firstname , email , new Date ( ) , street , addition al name , fax , zip , states id , town , language id , STRING , base URL , BOOL , j Name time Zone ) ; if ( user id = = null | | user id < NUM ) { return user id ; } Users user = user Management . get User By Id ( user id ) ; user . set Status ( NUM ) ; user . set Updat etime ( new Date ( ) ) ; user Management . update User ( user ) ; return user id ; } else { return new Long ( - NUM ) ; } } catch ( Exception err ) { log . error ( STRING , err ) ; throw new Axis Fault ( err . get Message ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "ensures that the capacity of the buffer is at least equal to the specified minimum . if the current capacity of this string buffer is less than the argument , then a new internal buffer is allocated with greater capacity . the new capacity is the larger of : the minimum capacity argument . twice the old capacity , plus 2 . if the minimum capacity argument is non positive , this method takes no action and simply returns .",
    "text_2": "public void ensure Capacity ( int minimum Capacity ) { if ( minimum Capacity > value . length ) { int our Min = value . length * NUM + NUM ; enlarge Buffer ( Math . max ( our Min , minimum Capacity ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "load up information for this network problem .",
    "text_2": "public Optimized ( int n , int s , int t , Iterator < Edge Info > edges ) { super ( n , s , t ) ; queue = new int [ n ] ; QUEUE SIZE = n ; capacity = new int [ n ] [ n ] ; flow = new int [ n ] [ n ] ; previous = new int [ n ] ; visited = new int [ n ] ; while ( edges . has Next ( ) ) { Edge Info ei = edges . next ( ) ; capacity [ ei . start ] [ ei . end ] = ei . capacity ; } }",
    "label": 1
  },
  {
    "text_1": "return true if the this type has a field that the other type does not have .",
    "text_2": "public boolean has Extra Fields ( Pdx Type other ) { for ( Pdx Field ft : this . fields ) { if ( ! ft . is Deleted ( ) & & other . get Pdx Field ( ft . get Field Name ( ) ) = = null ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "remove a rtcp event listener",
    "text_2": "public void remove Rtcp Listener ( Rtcp Event Listener listener ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } m Listeners . remove Element ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "find repeating terms and assign them ordinal values",
    "text_2": "private Linked Hash Map < Term , Integer > repeating Terms ( ) { Linked Hash Map < Term , Integer > t ord = new Linked Hash Map < > ( ) ; Hash Map < Term , Integer > t cnt = new Hash Map < > ( ) ; for ( Phrase Positions pp : phrase Positions ) { for ( Term t : pp . terms ) { Integer cnt NUM = t cnt . get ( t ) ; Integer cnt = cnt NUM = = null ? new Integer ( NUM ) : new Integer ( NUM + cnt NUM . int Value ( ) ) ; t cnt . put ( t , cnt ) ; if ( cnt = = NUM ) { t ord . put ( t , t ord . size ( ) ) ; } } } return t ord ; }",
    "label": 1
  },
  {
    "text_1": "should be invoked after processing each child representation element , in order to apply consistency checks .",
    "text_2": "public void end Representation ( ) { if ( ! representation Prot ections Set ) { if ( current Representation Prot ections ! = null ) { Collections . sort ( current Representation Prot ections , this ) ; } representation Prot ections = current Representation Prot ections ; representation Prot ections Set = BOOL ; } else { if ( current Representation Prot ections = = null ) { Assertions . check State ( representation Prot ections = = null ) ; } else { Collections . sort ( current Representation Prot ections , this ) ; Assertions . check State ( current Representation Prot ections . equals ( representation Prot ections ) ) ; } } current Representation Prot ections = null ; }",
    "label": 1
  },
  {
    "text_1": "recursively go up the file system tree to find parent project with settings . gradle and then obtain collection of siblings from that file .",
    "text_2": "private static Map < String , Virtual File > find Siblings ( @ Nullable Virtual File directory , Project project , Set < Virtual File > seen ) { if ( directory = = null ) { return Collections . empty Map ( ) ; } else { if ( seen . contains ( directory ) ) { return find Siblings ( null , project , seen ) ; } seen . add ( directory ) ; Virtual File settings = directory . find Child ( Sdk Constants . FN SETTINGS GRAD LE ) ; if ( settings = = null ) { return find Siblings ( directory . get Parent ( ) , project , seen ) ; } else { return Gradle Module Importer . get Sub Projects ( settings , project ) ; } } }",
    "label": 1
  },
  {
    "text_1": "find the fields constant that matches fieldid , or null if its not found .",
    "text_2": "public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return STRING THING ; case NUM : return BYTE THING ; case NUM : return I32 THING ; case NUM : return I 64 THING ; default : return null ; } }",
    "label": 1
  },
  {
    "text_1": "create a new property value editor which will read from the provided application console .",
    "text_2": "public Property Value Editor ( Console Application app , Management Context context ) { this . app = app ; this . context = context ; }",
    "label": 1
  },
  {
    "text_1": "creates a new type instance instance and stores it in the database .",
    "text_2": "public synchronized Type Instance create Instance ( final String name , final String comment , final Base Type base Type , final Section section , final long section Offset ) throws Couldnt Save Data Exception , Couldnt Load Data Exception { Preconditions . check Not Null ( name , STRING ) ; Preconditions . check Argument ( comment = = null | | ! comment . is Empty ( ) , STRING ) ; Preconditions . check Not Null ( base Type , STRING ) ; Preconditions . check Not Null ( section , STRING ) ; Preconditions . check Argument ( section Offset > = NUM , STRING ) ; Preconditions . check Argument ( ! instances By Address . contains Key ( new Type Instance Address ( section . get Start Address ( ) , section Offset ) ) ) ; final Type Instance instance = backend . create Type Instance ( name , comment , base Type , section , section Offset ) ; instances By Address . put ( instance . get Address ( ) , instance ) ; instances . add ( instance ) ; notify Instance Added ( instance ) ; return instance ; }",
    "label": 1
  },
  {
    "text_1": "adds view to specified cache . creates a cache list if it is null .",
    "text_2": "private List < View > add View ( View view , List < View > cache ) { if ( cache = = null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }",
    "label": 1
  },
  {
    "text_1": "prepares the result for display .",
    "text_2": "private List < Map < String , Object > > prepare Res ul ts for Display ( Collection < Scored Result > scored Results ) { Array List < Map < String , Object > > output = new Array List < Map < String , Object > > ( scored Results . size ( ) ) ; for ( Scored Result result : scored Results ) { Map < String , Object > result Map = new Hash Map < String , Object > ( ) ; if ( result . track ! = null ) { prepare Track For Display ( result . track , result Map ) ; } else { prepare Marker For Display ( result . waypoint , result Map ) ; } output . add ( result Map ) ; } return output ; }",
    "label": 1
  },
  {
    "text_1": "test ensure valid throws exception after close",
    "text_2": "public void test Invalid After Close ( ) throws IO Exception { Path temp Path = create Temp Dir ( ) ; Directory dir = get Directory ( temp Path ) ; Lock l = dir . obtain Lock ( STRING ) ; l . close ( ) ; expect Throws ( Already Closed Exception . class , null ) ; dir . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "description of the method",
    "text_2": "public static String replace ( String source , String target , String replacement ) { String Buffer output = new String Buffer ( ) ; int n = NUM ; while ( BOOL ) { int off = source . index Of ( target , n ) ; if ( off = = - NUM ) { output . append ( source . substring ( n ) ) ; break ; } output . append ( source . substring ( n , off ) ) ; output . append ( replacement ) ; n = off + target . length ( ) ; } return output . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "close a database connection",
    "text_2": "private void close Database Connection ( Connection connection ) { if ( connection = = null ) return ; try { connection . close ( ) ; } catch ( SQL Exception e ) { } connection = null ; return ; }",
    "label": 1
  },
  {
    "text_1": "ends the formal type parameters section of the signature .",
    "text_2": "private void end Formals ( ) { if ( has Formals ) { has Formals = BOOL ; buf . append ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "only support auto load lib / ar me abi - v7 a library from patch . in some process , you may not want to install tin ker and you can load patch dex and library without install tin ker !",
    "text_2": "public static void load Arm V NUM a Library ( Application Like application Like , String lib Name ) { if ( lib Name = = null | | lib Name . is Empty ( ) | | application Like = = null ) { throw new Tinker Runtime Exception ( STRING ) ; } if ( Tinker Application Helper . is Tinker Enable For Native Lib ( application Like ) ) { if ( Tinker Application Helper . load Library From Tinker ( application Like , STRING , lib Name ) ) { return ; } } System . load Library ( lib Name ) ; }",
    "label": 1
  },
  {
    "text_1": "remove all references to this client",
    "text_2": "protected void remove From Maps ( String client Type ) { Client client = ( Client ) client Type Map . get ( client Type ) ; external Client Data . remove ( client Type ) ; Map map = ( Map ) internal Client Data . get ( client Type ) ; if ( map = = null ) { remove From Client Map ( client Type , client ) ; } else { handle Parent Change ( client Type , map ) ; } unload Client ( client Type ) ; }",
    "label": 1
  },
  {
    "text_1": "construct sms m ms message for get m ms details ( ) - fetched from the mms database table",
    "text_2": "public Sms Mms Message ( Context context , long message Id , long thread Id , long timestamp , String message Body , int unread Count , int message Type ) { context = context ; message Id = message Id ; thread Id = thread Id ; timestamp = timestamp ; message Body = message Body ; unread Count = unread Count ; message Type = message Type ; from Address = Sms Popup Utils . get Mms Address ( context , message Id ) ; from Email Gateway = BOOL ; contact Name = Phone Number Utils . format Number ( from Address ) ; Contact Identification contact Identify = Sms Popup Utils . get Person Id From Phone Number ( context , from Address ) ; if ( contact Identify = = null ) { contact Identify = Sms Popup Utils . get Person Id From Email ( context , from Address ) ; if ( contact Identify ! = null ) { from Email Gateway = BOOL ; } } if ( contact Identify ! = null ) { contact Id = contact Identify . contact Id ; contact Lookup Key = contact Identify . contact Lookup ; contact Name = contact Identify . contact Name ; } }",
    "label": 1
  },
  {
    "text_1": "get invoice paid ( allocated ) amount . - invo i cep aid",
    "text_2": "public static Big Decimal paid To Date ( int p C Invoice ID , int p C Currency ID , int p Multiplier AP , Timestamp Date Acct ) throws SQL Exception { if ( p C Invoice ID = = NUM | | p C Currency ID = = NUM ) return null ; Big Decimal Multiplier AP = new Big Decimal ( ( double ) p Multiplier AP ) ; if ( p Multiplier AP = = NUM ) Multiplier AP = Adempiere . ONE ; int C Conversion Type ID = NUM ; Big Decimal payment Amt = allocated Amt To Date ( p C Invoice ID , p C Currency ID , C Conversion Type ID , Multiplier AP , Date Acct ) ; return Currency . round ( payment Amt , p C Currency ID , null ) ; }",
    "label": 1
  },
  {
    "text_1": "determine if track will service a specific receive load name .",
    "text_2": "public boolean accepts Load Name ( String load ) { if ( load Option . equals ( ALL LOADS ) ) { return BOOL ; } if ( load Option . equals ( INCLUDE LOADS ) ) { return load List . contains ( load ) ; } return ! load List . contains ( load ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new tur tle writer that will write to the supplied outputstream .",
    "text_2": "public Turtle Writer ( Output Stream out ) { this ( new Output Stream Writer ( out , Charset . for Name ( STRING ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the over views base . xml from the templates folder and creates a temporary over views . xml in the output folder",
    "text_2": "public static void create Over views ( AS Doc Configuration config ) throws Compiler Exception { String templates Path = config . get Templates Path ( ) ; String dita Path = config . get Output ( ) + STRING + File . separator ; Buffered Writer writer = null ; Reader reader = null ; try { writer = new Buffered Writer ( new File Writer ( dita Path + STRING ) ) ; if ( config . get Package Description File ( ) ! = null ) { reader = new Buffered Reader ( new File Reader ( config . get Package Description File ( ) ) ) ; } else { reader = new Buffered Reader ( new File Reader ( templates Path + STRING ) ) ; } Over views Handler h = new Over views Handler ( writer , config ) ; Input Source source = new Input Source ( reader ) ; SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( source , h ) ; } catch ( Exception e ) { if ( Trace . error ) e . print Stack Trace ( ) ; Compiler Message c = new Could Not Create ( STRING , e . get Message ( ) ) ; Thread Local Toolkit . log ( c ) ; throw c ; } finally { if ( writer ! = null ) { try { writer . close ( ) ; } catch ( IO Exception ioe ) { } } if ( reader ! = null ) { try { reader . close ( ) ; } catch ( IO Exception ioe ) { } } } }",
    "label": 1
  },
  {
    "text_1": "dam ages a randomly determined bay door on the entity , if one exists",
    "text_2": "public String damage Bay Door ( ) { String bay Type = STRING ; Vector < Bay > potential ; potential = new Vector < Bay > ( ) ; Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . has More Elements ( ) ) { Transporter next = iter . next Element ( ) ; if ( next instanceof Bay ) { Bay next Bay = ( Bay ) next ; if ( next Bay . get Do ors ( ) > NUM ) { potential . add ( next Bay ) ; } } } if ( potential . size ( ) > NUM ) { Bay chosen Bay = potential . element At ( Compute . random Int ( potential . size ( ) ) ) ; chosen Bay . destroy Door ( ) ; chosen Bay . reset Do ors ( ) ; chosen Bay . set Do ors ( chosen Bay . get Do ors ( ) - NUM ) ; bay Type = chosen Bay . get Type ( ) ; } return bay Type ; }",
    "label": 1
  },
  {
    "text_1": "returns a string representation of the given url string . this converts escaped sequences ( % . . ) in the url into the appropriate characters . note : due to class visibility there is a copy of this method in internal bootloader",
    "text_2": "protected String decode ( String url String ) { try { Class clazz = URL Decoder . class ; Method method = clazz . get Declared Method ( STRING , new Class [ ] { String . class , String . class } ) ; if ( url String . index Of ( STRING ) > = NUM ) { int len = url String . length ( ) ; String Buffer buf = new String Buffer ( len ) ; for ( int i = NUM ; i < len ; i + + ) { char c = url String . char At ( i ) ; if ( c = = STRING ) buf . append ( STRING ) ; else buf . append ( c ) ; } url String = buf . to String ( ) ; } Object result = method . invoke ( null , new Object [ ] { url String , STRING } ) ; if ( result ! = null ) return ( String ) result ; } catch ( Exception e ) { } boolean replaced = BOOL ; byte [ ] encoded Bytes = url String . get Bytes ( ) ; int encoded Length = encoded Bytes . length ; byte [ ] decoded Bytes = new byte [ encoded Length ] ; int decoded Length = NUM ; for ( int i = NUM ; i < encoded Length ; i + + ) { byte b = encoded Bytes [ i ] ; if ( b = = STRING ) { if ( i + NUM > = encoded Length ) throw new Illegal Argument Exception ( STRING + url String + STRING ) ; byte enc NUM = encoded Bytes [ + + i ] ; byte enc NUM = encoded Bytes [ + + i ] ; b = ( byte ) ( ( hex To Byte ( enc NUM ) < < NUM ) + hex To Byte ( enc NUM ) ) ; replaced = BOOL ; } decoded Bytes [ decoded Length + + ] = b ; } if ( ! replaced ) return url String ; try { return new String ( decoded Bytes , NUM , decoded Length , STRING ) ; } catch ( Unsupported Encoding Exception e ) { return new String ( decoded Bytes , NUM , decoded Length ) ; } }",
    "label": 1
  },
  {
    "text_1": "pops up the modal dialog and waits for cancel or a selection .",
    "text_2": "public int show Dialog ( ) { m Result = CANCEL OPTION ; int [ ] orig Selected = m List . get Selected Indices ( ) ; set Visible ( BOOL ) ; if ( m Result = = CANCEL OPTION ) { m List . set Selected Indices ( orig Selected ) ; } return m Result ; }",
    "label": 1
  },
  {
    "text_1": "loads the history properties of the sql viewer in the user ' s home directory .",
    "text_2": "protected void load History ( boolean set ) { Buffered Input Stream str ; File file ; int width ; int height ; try { file = new File ( get History Filename ( ) ) ; if ( file . exists ( ) ) { str = new Buffered Input Stream ( new File Input Stream ( get History Filename ( ) ) ) ; m History . load ( str ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } if ( set ) { m Connection Panel . set History ( string To Model ( m History . get Property ( Connection Panel . HISTORY NAME , STRING ) ) ) ; m Query Panel . set History ( string To Model ( m History . get Property ( Query Panel . HISTORY NAME , STRING ) ) ) ; m Query Panel . set Max Rows ( Integer . parse Int ( m History . get Property ( Query Panel . MAX ROWS , STRING ) ) ) ; width = Integer . parse Int ( m History . get Property ( WIDTH , STRING ) ) ; height = Integer . parse Int ( m History . get Property ( HEIGHT , STRING ) ) ; if ( ( width ! = NUM ) & & ( height ! = NUM ) ) { set Preferred Size ( new Dimension ( width , height ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "free function that parses a f nt file a place it on the cache",
    "text_2": "public static CC Bitmap Font Configuration F NT Config Load File ( String fnt File ) { CC Bitmap Font Configuration ret = null ; if ( configurations = = null ) configurations = new Hash Map < String , CC Bitmap Font Configuration > ( ) ; ret = configurations . get ( fnt File ) ; if ( ret = = null ) { ret = CC Bitmap Font Configuration . configuration ( fnt File ) ; configurations . put ( fnt File , ret ) ; } return ret ; }",
    "label": 1
  },
  {
    "text_1": "returns true to indicate the window is empty , or false if the view is not empty .",
    "text_2": "public boolean is Empty ( ) { return window . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "clamp the magnitude of value for absmin and absmax . if the value is below the minimum , it will be clamped to zero . if the value is above the maximum , it will be clamped to the maximum .",
    "text_2": "private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }",
    "label": 1
  },
  {
    "text_1": "constructs a new instance of this class with the given class loader as its parent .",
    "text_2": "protected Class Loader ( Class Loader parent Loader ) { Security Manager sc = System . get Security Manager ( ) ; if ( sc ! = null ) { sc . check Create Class Loader ( ) ; } parent Class Loader = parent Loader ; defined Packages = new Hash Map < String , Package > ( ) ; loaded Classes = new Hash Map < String , Class < ? > > ( ) ; package Certificates = new Hashtable < String , Certificate [ ] > ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the given token filter .",
    "text_2": "public Builder add Token Filter ( String name , Map < String , String > params ) throws IO Exception { Objects . require Non Null ( name , STRING ) ; token Filters . add ( apply Resource Loader ( Token Filter Factory . for Name ( name , apply Default Params ( params ) ) ) ) ; components Added = BOOL ; return this ; }",
    "label": 1
  },
  {
    "text_1": "find out if a particular node is connected",
    "text_2": "public boolean is Connected ( short node Id ) { Node Connection nc = connections . get ( node Id ) ; return ( nc ! = null & & nc . state = = Node Connection State . CONNECTED ) ; }",
    "label": 1
  },
  {
    "text_1": "swaps cursor for calendar events for given month closes previously bound cursor , unregisters observer if any",
    "text_2": "void swap Cursor ( long month Millis , @ Nullable Event Cursor cursor , Content Observer content Observer ) { for ( int i = NUM ; i < m Months . size ( ) ; i + + ) { if ( Calendar Utils . same Month ( month Millis , m Months . get ( i ) ) ) { swap Cursor ( i , cursor , content Observer ) ; break ; } } }",
    "label": 1
  },
  {
    "text_1": "checks if the app has been installed on the system .",
    "text_2": "public static boolean is Installed ( Package Manager package Manager , String package Name ) { List < Package Info > packs = package Manager . get Installed Packages ( NUM ) ; for ( int i = NUM ; i < packs . size ( ) ; i + + ) { if ( Text Utils . equals ( packs . get ( i ) . package Name , package Name ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "handles add provider resource id mapper request .",
    "text_2": "public void handle Tbl Provider Resource Id Mapper Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SM Discovery Provider Resource Id Mapper Add View Bean vb = ( SM Discovery Provider Resource Id Mapper Add View Bean ) get View Bean ( SM Discovery Provider Resource Id Mapper Add View Bean . class ) ; remove Page Session Attribute ( SM Discovery Provider Resource Id Mapper Add View Bean . PROPERTY ATTRIBUTE ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a new parameter to be used in the post request body .",
    "text_2": "public void add Parameter ( Name Value Pair param ) throws Illegal Argument Exception { log . trace ( STRING ) ; if ( param = = null ) { throw new Illegal Argument Exception ( STRING ) ; } add Parameter ( param . get Name ( ) , param . get Value ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the resource of the given kind and name from the collection or null",
    "text_2": "public static < T > T find Resource By Name ( Iterable < Has Metadata > entities , Class < T > clazz , String name ) { if ( entities ! = null ) { for ( Has Metadata entity : entities ) { if ( clazz . is Instance ( entity ) & & Objects . equals ( name , get Name ( entity ) ) ) { return clazz . cast ( entity ) ; } } } return null ; }",
    "label": 1
  },
  {
    "text_1": "verifies certificates against a list of crls and ocsp responses .",
    "text_2": "public List < Verification OK > verify ( X509 Certificate sign Cert , X509 Certificate issuer Cert , Date sign Date ) throws General Security Exception , IO Exception { Root Store Verifier root Store Verifier = new Root Store Verifier ( verifier ) ; root Store Verifier . set Root Store ( root Store ) ; CRL Verifier crl Verifier = new CRL Verifier ( root Store Verifier , get CR Ls From DSS ( ) ) ; crl Verifier . set Root Store ( root Store ) ; crl Verifier . set Online Checking Allowed ( latest Revision | | online Checking Allowed ) ; OCSP Verifier ocsp Verifier = new OCSP Verifier ( crl Verifier , get OCSP Responses From DSS ( ) ) ; ocsp Verifier . set Root Store ( root Store ) ; ocsp Verifier . set Online Checking Allowed ( latest Revision | | online Checking Allowed ) ; return ocsp Verifier . verify ( sign Cert , issuer Cert , sign Date ) ; }",
    "label": 1
  },
  {
    "text_1": "reads until the array is full or until the stream ends",
    "text_2": "public static int read All ( Input Stream i , byte b [ ] ) throws IO Exception { int len = b . length ; int n = NUM ; while ( n < len ) { int count = i . read ( b , n , len - n ) ; if ( count < NUM ) { return n ; } n + = count ; } return n ; }",
    "label": 1
  },
  {
    "text_1": "detects programs from $ desktop session",
    "text_2": "public static Object detect Linux Default File Browser ( Map < String , Object > file Browsers ) { Array List < String > command = new Array List < String > ( ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; if ( file Browsers = = null ) { file Browsers = new Hash Map < String , Object > ( ) ; file Browsers . put ( STRING , STRING ) ; } return Utils . is Expected Command Output ( command , file Browsers ) ; }",
    "label": 1
  },
  {
    "text_1": "read the facet node in .",
    "text_2": "@ Override public void read External ( Object Input in ) throws IO Exception , Class Not Found Exception { super . read External ( in ) ; this . facet Name = in . read UTF ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a summary of the time that the stopwatch has recorded as a string .",
    "text_2": "public String to String ( ) { return String . value Of ( stop Time Millis - start Time Millis ) + STRING ; }",
    "label": 1
  },
  {
    "text_1": "simple , original bri cs implementation of determin ize ( ) determin izes the given automaton using the given set of initial states .",
    "text_2": "public static Automaton determin ize Simple ( Automaton a , Set < Integer > initial set ) { if ( a . get Num States ( ) = = NUM ) { return a ; } int [ ] points = a . get Start Points ( ) ; Map < Set < Integer > , Set < Integer > > sets = new Hash Map < > ( ) ; Linked List < Set < Integer > > worklist = new Linked List < > ( ) ; Map < Set < Integer > , Integer > newstate = new Hash Map < > ( ) ; sets . put ( initial set , initial set ) ; worklist . add ( initial set ) ; Automaton . Builder result = new Automaton . Builder ( ) ; result . create State ( ) ; newstate . put ( initial set , NUM ) ; Transition t = new Transition ( ) ; while ( worklist . size ( ) > NUM ) { Set < Integer > s = worklist . remove First ( ) ; int r = newstate . get ( s ) ; for ( int q : s ) { if ( a . is Accept ( q ) ) { result . set Accept ( r , BOOL ) ; break ; } } for ( int n = NUM ; n < points . length ; n + + ) { Set < Integer > p = new Hash Set < > ( ) ; for ( int q : s ) { int count = a . init Transition ( q , t ) ; for ( int i = NUM ; i < count ; i + + ) { a . get Next Transition ( t ) ; if ( t . min < = points [ n ] & & points [ n ] < = t . max ) { p . add ( t . dest ) ; } } } if ( ! sets . contains Key ( p ) ) { sets . put ( p , p ) ; worklist . add ( p ) ; newstate . put ( p , result . create State ( ) ) ; } int q = newstate . get ( p ) ; int min = points [ n ] ; int max ; if ( n + NUM < points . length ) { max = points [ n + NUM ] - NUM ; } else { max = Character . MAX CODE POINT ; } result . add Transition ( r , q , min , max ) ; } } return Operations . remove Dead States ( result . finish ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "atomically removes all of the elements from this delay queue . the queue will be empty after this call returns . elements with an un expired delay are not waited for ; they are simply discarded from the queue .",
    "text_2": "public void clear ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Tenant Queue q : qs . values ( ) ) { q . clear ( ) ; } } finally { lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "run fast - abo d on the data set .",
    "text_2": "@ Override public Outlier Result run ( Database db , Relation < V > relation ) { DBI Ds ids = relation . get DBI Ds ( ) ; Similarity Query < V > sq = db . get Similarity Query ( relation , kernel Function ) ; Kernel Matrix kernel Matrix = new Kernel Matrix ( sq , relation , ids ) ; Writable Double Data Store ab od values = Data Store Util . make Double Storage ( ids , Data Store Factory . HINT STATIC ) ; Double Min Max min max abo d = new Double Min Max ( ) ; Mean Variance s = new Mean Variance ( ) ; KNN Heap nn = DBID Util . new Heap ( k ) ; for ( DBID Iter pA = ids . iter ( ) ; pA . valid ( ) ; pA . advance ( ) ) { final double sim AA = kernel Matrix . get Similarity ( pA , pA ) ; nn . clear ( ) ; for ( DBID Iter nB = relation . iter DBI Ds ( ) ; nB . valid ( ) ; nB . advance ( ) ) { if ( DBID Util . equal ( nB , pA ) ) { continue ; } double sim BB = kernel Matrix . get Similarity ( nB , nB ) ; double sim AB = kernel Matrix . get Similarity ( pA , nB ) ; double sqd AB = sim AA + sim BB - sim AB - sim AB ; if ( ! ( sqd AB > NUM ) ) { continue ; } nn . insert ( sqd AB , nB ) ; } KNN List nl = nn . to KNN List ( ) ; s . reset ( ) ; Double DBID List Iter iB = nl . iter ( ) , iC = nl . iter ( ) ; for ( ; iB . valid ( ) ; iB . advance ( ) ) { double sqd AB = iB . double Value ( ) ; double sim AB = kernel Matrix . get Similarity ( pA , iB ) ; if ( ! ( sqd AB > NUM ) ) { continue ; } for ( iC . seek ( iB . get Offset ( ) + NUM ) ; iC . valid ( ) ; iC . advance ( ) ) { double sqd AC = iC . double Value ( ) ; double sim AC = kernel Matrix . get Similarity ( pA , iC ) ; if ( ! ( sqd AC > NUM ) ) { continue ; } double sim BC = kernel Matrix . get Similarity ( iB , iC ) ; double numerator = sim BC - sim AB - sim AC + sim AA ; double div = NUM / ( sqd AB * sqd AC ) ; s . put ( numerator * div , Math . sqrt ( div ) ) ; } } final double abo f = s . get Naive Variance ( ) ; min max abo d . put ( abo f ) ; ab od values . put Double ( pA , abo f ) ; } Double Relation score Result = new Materialized Double Relation ( STRING , STRING , ab od values , relation . get DBI Ds ( ) ) ; Outlier Score Meta score Meta = new Inverted Outlier Score Meta ( min max abo d . get Min ( ) , min max abo d . get Max ( ) , NUM , Double . POSITIVE INFINITY ) ; return new Outlier Result ( score Meta , score Result ) ; }",
    "label": 1
  },
  {
    "text_1": "support for reporting bound property changes for object properties . this method can be called when a bound property has changed and it will send the appropriate propertychangeevent to any registered propertychangelisteners .",
    "text_2": "protected void fire Property Change ( String property Name , Object old Value , Object new Value ) { property Change Support . fire Property Change ( property Name , old Value , new Value ) ; }",
    "label": 1
  },
  {
    "text_1": "exchange function when aren as enabled . see above for explanation .",
    "text_2": "private final Object arena Exchange ( Object item , boolean timed , long ns ) { Node [ ] a = arena ; Node p = participant . get ( ) ; for ( int i = p . index ; ; ) { int b , m , c ; long j ; Node q = ( Node ) U . get Object Volatile ( a , j = ( i < < AS HI FT ) + AB ASE ) ; if ( q ! = null & & U . compare And Swap Object ( a , j , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w ! = null ) U . unpark ( w ) ; return v ; } else if ( i < = ( m = ( b = bound ) & M MASK ) & & q = = null ) { p . item = item ; if ( U . compare And Swap Object ( a , j , null , p ) ) { long end = ( timed & & m = = NUM ) ? System . nano Time ( ) + ns : NUM ; Thread t = Thread . current Thread ( ) ; for ( int h = p . hash , spins = SPINS ; ; ) { Object v = p . match ; if ( v ! = null ) { U . put Ordered Object ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; } else if ( spins > NUM ) { h ^ = h < < NUM ; h ^ = h > > > NUM ; h ^ = h < < NUM ; if ( h = = NUM ) h = SPINS | ( int ) t . get Id ( ) ; else if ( h < NUM & & ( - - spins & ( ( SPINS > > > NUM ) - NUM ) ) = = NUM ) Thread . yield ( ) ; } else if ( U . get Object Volatile ( a , j ) ! = p ) spins = SPINS ; else if ( ! t . is Interrupted ( ) & & m = = NUM & & ( ! timed | | ( ns = end - System . nano Time ( ) ) > NUM ) ) { U . put Object ( t , B LOCKER , this ) ; p . parked = t ; if ( U . get Object Volatile ( a , j ) = = p ) U . park ( BOOL , ns ) ; p . parked = null ; U . put Object ( t , B LOCKER , null ) ; } else if ( U . get Object Volatile ( a , j ) = = p & & U . compare And Swap Object ( a , j , p , null ) ) { if ( m ! = NUM ) U . compare And Swap Int ( this , BOUND , b , b + SEQ - NUM ) ; p . item = null ; p . hash = h ; i = p . index > > > = NUM ; if ( Thread . interrupted ( ) ) return null ; if ( timed & & m = = NUM & & ns < = NUM ) return TIMED OUT ; break ; } } } else p . item = null ; } else { if ( p . bound ! = b ) { p . bound = b ; p . collides = NUM ; i = ( i ! = m | | m = = NUM ) ? m : m - NUM ; } else if ( ( c = p . collides ) < m | | m = = FULL | | ! U . compare And Swap Int ( this , BOUND , b , b + SEQ + NUM ) ) { p . collides = c + NUM ; i = ( i = = NUM ) ? m : i - NUM ; } else i = m + NUM ; p . index = i ; } } }",
    "label": 1
  },
  {
    "text_1": "translates a column - major ( ie . fortran - type ) array to a row - major ( ie . c - type ) array .",
    "text_2": "static private < E > List < E > to Java List ( List < E > values , int rows , int columns ) { List < E > result = new Array List < > ( values . size ( ) ) ; for ( int i = NUM ; i < values . size ( ) ; i + + ) { int row = i / columns ; int column = i % columns ; E value = values . get ( ( column * rows ) + row ) ; result . add ( value ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "start an apply interval .",
    "text_2": "public void begin Apply Interval ( ) { interval Start Millis = System . current Time Millis ( ) ; end Millis = interval Start Millis ; state = Task State . apply ; }",
    "label": 1
  },
  {
    "text_1": "perform updates if added documents already exist ?",
    "text_2": "public boolean update ( ) { return update ; }",
    "label": 1
  },
  {
    "text_1": "test if the supplied directory already exists .",
    "text_2": "public static boolean validate Output Directory ( File directory ) { if ( directory . exists ( ) ) { Diagnostic . error ( Error Type . DIRECTORY EXISTS , directory . get Path ( ) ) ; return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "constructs a discret ize expression",
    "text_2": "public Discreti ze ( Element discretize , Field Meta Info . Op type op Type , Array List < Attribute > field Defs ) throws Exception { super ( op Type , field Defs ) ; m field Name = discretize . get Attribute ( STRING ) ; m map Missing To = discretize . get Attribute ( STRING ) ; if ( m map Missing To ! = null & & m map Missing To . length ( ) > NUM ) { m map Missing Defined = BOOL ; } m default Value = discretize . get Attribute ( STRING ) ; if ( m default Value ! = null & & m default Value . length ( ) > NUM ) { m default Value Defined = BOOL ; } Node List db L = discretize . get Elements By Tag Name ( STRING ) ; for ( int i = NUM ; i < db L . get Length ( ) ; i + + ) { Node db N = db L . item ( i ) ; if ( db N . get Node Type ( ) = = Node . ELEMENT NODE ) { Element db E = ( Element ) db N ; Discreti ze Bin db = new Discreti ze Bin ( db E , m op Type ) ; m bins . add ( db ) ; } } if ( field Defs ! = null ) { set Up Field ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "forcefully sets the current time for the stopwatch .",
    "text_2": "public void override Current Time ( long time ) { start Time = System . current Time Millis ( ) ; current Time = NUM ; stored Time = time ; }",
    "label": 1
  },
  {
    "text_1": "create a bigdecimal from a negative double value",
    "text_2": "public void test Value Of Double Neg ( ) { double a = - NUM ; Big Decimal result = Big Decimal . value Of ( a ) ; String res = STRING ; int res Scale = NUM ; assert Equals ( STRING , res , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "checks the item after obtaining from the props file . file must exist .",
    "text_2": "@ Override protected boolean check ( File item ) { return item . exists ( ) ; }",
    "label": 1
  },
  {
    "text_1": "this method updates a record in general config table corresponding to object passed .",
    "text_2": "@ Request Mapping ( value = { STRING , STRING } , method = Request Method . POST ) @ Response Body public Rest Wrapper update One Record ( @ Model Attribute ( STRING ) @ Valid General Config general Config , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { if ( general Config . get Required ( ) < = NUM ) { com . wipro . ats . bdre . md . dao . jpa . General Config jpa General Config Update = new com . wipro . ats . bdre . md . dao . jpa . General Config ( ) ; General Config Id jpa General Config Id = new General Config Id ( ) ; jpa General Config Id . set Config Group ( general Config . get Config Group ( ) ) ; jpa General Config Id . set Gc Key ( general Config . get Key ( ) ) ; jpa General Config Update . set Id ( jpa General Config Id ) ; jpa General Config Update . set Default Val ( general Config . get Default Val ( ) ) ; jpa General Config Update . set Description ( general Config . get Description ( ) ) ; jpa General Config Update . set Enabled ( general Config . is Enabled ( ) ) ; jpa General Config Update . set Gc Value ( general Config . get Value ( ) ) ; if ( general Config . get Required ( ) = = NUM ) jpa General Config Update . set Required ( BOOL ) ; else jpa General Config Update . set Required ( BOOL ) ; jpa General Config Update . set Type ( general Config . get Type ( ) ) ; LOGGER . info ( general Config ) ; general Config DAO . update ( jpa General Config Update ) ; rest Wrapper = new Rest Wrapper ( general Config , Rest Wrapper . OK ) ; LOGGER . info ( STRING + jpa General Config Id . get Gc Key ( ) + STRING + jpa General Config Id . get Config Group ( ) + STRING + principal . get Name ( ) ) ; } else { LOGGER . error ( STRING ) ; rest Wrapper = new Rest Wrapper ( STRING , Rest Wrapper . ERROR ) ; } } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }",
    "label": 1
  },
  {
    "text_1": "byte to hex string",
    "text_2": "public static String byte To Hex String ( byte [ ] byte Array ) { String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < byte Array . length ; i + + ) { int byte Code = byte Array [ i ] & NUM ; if ( byte Code < NUM ) { builder . append ( NUM ) ; } builder . append ( Integer . to Hex String ( byte Code ) ) ; } return builder . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "creates an unnamed event and set it as the h event field in the given overlapped structure",
    "text_2": "private void create And Attach Event ( long ov ) throws Windows Exception { long h Event = Create Event ( BOOL , BOOL ) ; UNSAFE . put Address ( ov + OFF SE TOF HE V ENT , h Event ) ; }",
    "label": 1
  },
  {
    "text_1": "see if there ' s anything to write , and if so do it .",
    "text_2": "protected void continue Write ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Iterator < Variable Value > i = variables . iterator ( ) ; while ( i . has Next ( ) ) { Variable Value v = i . next ( ) ; if ( v . is To Write ( ) & & ( ! writing Changes | | v . is Changed ( ) ) ) { am Writing = BOOL ; set Busy ( BOOL ) ; log . debug ( STRING + v . label ( ) + STRING + writing Changes ) ; if ( writing Changes ) { v . write Changes ( ) ; } else { v . write All ( ) ; } log . debug ( STRING ) ; return ; } } am Writing = BOOL ; super . set State ( STORED ) ; set Busy ( BOOL ) ; log . debug ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "write all consists to a file .",
    "text_2": "public void write File ( Array List < Dcc Loco Address > consist List , String file Name ) throws IO Exception { Element root = new Element ( STRING ) ; Document doc = new Document ( root , dtd Location + STRING ) ; Map < String , String > m = new Hash Map < String , String > ( ) ; m . put ( STRING , STRING ) ; m . put ( STRING , xslt Location + STRING ) ; Processing Instruction p = new Processing Instruction ( STRING , m ) ; doc . add Content ( NUM , p ) ; Element roster = new Element ( STRING ) ; for ( int i = NUM ; i < consist List . size ( ) ; i + + ) { Consist new Consist = consist Man . get Consist ( consist List . get ( i ) ) ; roster . add Content ( consist To Xml ( new Consist ) ) ; } root . add Content ( roster ) ; try { if ( ! check File ( file Name ) ) { File file = new File ( file Name ) ; File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { throw ( new IO Exception ( ) ) ; } } if ( ! file . create New File ( ) ) { throw ( new IO Exception ( ) ) ; } } write XML ( find File ( file Name ) , doc ) ; } catch ( IO Exception ioe ) { log . error ( STRING + ioe ) ; throw ( ioe ) ; } }",
    "label": 1
  },
  {
    "text_1": "write the entire buffer to output stream .",
    "text_2": "public void write To ( final Output Stream out ) throws IO Exception { for ( final Block block : blocks ) { out . write ( block . data , NUM , block . limit ) ; } }",
    "label": 1
  },
  {
    "text_1": "hook method which gets executed just before the menu gets updated . default implementation does nothing .",
    "text_2": "protected void pre Update Menu ( ) { }",
    "label": 1
  },
  {
    "text_1": "returns true if communication has already been initiated ( and perhaps completed ) .",
    "text_2": "@ Override public boolean communication Initiated ( ) { return bugs Populated . get Count ( ) = = NUM & & communication Initiated & & network Client . ready ( ) ; }",
    "label": 1
  },
  {
    "text_1": "extract user part phone number from a sip - uri or tel - uri or sip address",
    "text_2": "static String extract Number From Uri Without Formatting ( String uri ) { if ( uri = = null ) { return null ; } int index NUM = uri . index Of ( URI START DELIMITER ) ; if ( index NUM ! = - NUM ) { uri = uri . substring ( index NUM + URI START DELIMITER . length ( ) , uri . index Of ( URI END DELIMITER , index NUM ) ) ; } int index NUM = uri . index Of ( TEL URI HEADER ) ; if ( index NUM ! = - NUM ) { uri = uri . substring ( index NUM + TEL URI HEADER . length ( ) ) ; } index NUM = uri . index Of ( SIP URI HEADER ) ; if ( index NUM ! = - NUM ) { int index NUM = uri . index Of ( STRING , index NUM ) ; uri = uri . substring ( index NUM + SIP URI HEADER . length ( ) , index NUM ) ; } int index NUM = uri . index Of ( STRING ) ; if ( index NUM ! = - NUM ) { uri = uri . substring ( NUM , index NUM ) ; } index NUM = uri . index Of ( STRING ) ; if ( index NUM ! = - NUM ) { uri = uri . substring ( NUM , index NUM ) ; } return uri ; }",
    "label": 1
  },
  {
    "text_1": "helper method to decide whether a model improves the training error enough to be considered . returns always true .",
    "text_2": "private boolean is Model Useful ( Contingency Matrix cm ) { return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "indicates whether the value is null .",
    "text_2": "public boolean is Null Value ( ) { return String Utils . trim To Null ( value ) = = null & & String Utils . trim To Null ( comment ) = = null ; }",
    "label": 1
  },
  {
    "text_1": "get revision number for the line .",
    "text_2": "public Vcs Revision Number original Revision ( int line Number ) { return get Line Revision Number ( line Number ) ; }",
    "label": 1
  },
  {
    "text_1": "this method returns the restriction as a string .",
    "text_2": "@ Override public String to String ( ) { return as String ; }",
    "label": 1
  },
  {
    "text_1": "adds a listener to this check box so that it will be notific ed on certain user actions",
    "text_2": "public Check Box add Listener ( Listener listener ) { if ( listener ! = null & & ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "makes a date from separate strings for month , day , year , hour , minute , and second .",
    "text_2": "public static java . util . Date to Date ( String month Str , String day Str , String year Str , String hour Str , String minute Str , String second Str ) { int month , day , year , hour , minute , second ; try { month = Integer . parse Int ( month Str ) ; day = Integer . parse Int ( day Str ) ; year = Integer . parse Int ( year Str ) ; hour = Integer . parse Int ( hour Str ) ; minute = Integer . parse Int ( minute Str ) ; second = Integer . parse Int ( second Str ) ; } catch ( Exception e ) { return null ; } return to Date ( month , day , year , hour , minute , second ) ; }",
    "label": 1
  },
  {
    "text_1": "called for each response obtained from non master nodes",
    "text_2": "public void on Response ( Discovery Node node ) { boolean found = pending Nodes . remove ( node ) ; assert found : STRING + node + STRING ; latch . count Down ( ) ; }",
    "label": 1
  },
  {
    "text_1": "substracts the trading fee from the player depending on the given price",
    "text_2": "public static boolean substract Trading Fee ( Player player , int price ) { Big Decimal fee = calculate Fee ( player , price ) ; return player . drop ( STRING , fee . int Value ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "utility method - when iterating over the hierarchy , determine if the entry currently being considered is actually matched . if it is , return the corresponding simple entry object so the details can be displayed",
    "text_2": "protected abstract Simple Entry entry Data Matched ( Entry Hierarchy Data eh d ) ;",
    "label": 1
  },
  {
    "text_1": "returns the arraylist stored for a key",
    "text_2": "void insert ( V val , K key ) { Array List < K > list = map . get ( val ) ; if ( list = = null ) { list = new Array List < K > ( NUM ) ; map . put ( clone Value ( val ) , list ) ; } list . add ( key ) ; }",
    "label": 1
  },
  {
    "text_1": "removes all listeners from the set listening to frame updates for this animation .",
    "text_2": "public void remove All Update Listeners ( ) { if ( m Update Listeners = = null ) { return ; } m Update Listeners . clear ( ) ; m Update Listeners = null ; }",
    "label": 1
  },
  {
    "text_1": "hashes bytes in an array .",
    "text_2": "public static int hash ( byte [ ] data , int seed ) { return hash ( Byte Buffer . wrap ( data ) , seed ) ; }",
    "label": 1
  },
  {
    "text_1": "get all on class relations for this property restriction .",
    "text_2": "public Set < Resource > on Class ( ) { Set < Resource > targets = new Hash Set < > ( ) ; for ( Owl Class c : qc Classes ) { targets . add ( c . get URI ( ) ) ; } return targets ; }",
    "label": 1
  },
  {
    "text_1": "add to - be - reconcil ed flow to the queue .",
    "text_2": "@ Override public void reconcile Flow ( OF Match Reconcile ofm Rc In , Event Priority priority ) { if ( ofm Rc In = = null ) return ; OF Match Reconcile my O fm Rc = new OF Match Reconcile ( ofm Rc In ) ; flow Queue . offer ( my O fm Rc , priority ) ; ctr Flow Reconcile Request . increment ( ) ; Date curr Time = new Date ( ) ; long delay = NUM ; if ( curr Time . after ( new Date ( last Reconcile Time . get Time ( ) + NUM ) ) ) { delay = NUM ; } else { delay = FLOW RE CON CI LE DELAY MILLI SEC ; } flow Reconcile Task . reschedule ( delay , Time Unit . MILLISECONDS ) ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING , my O fm Rc . to String ( ) , flow Queue . size ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "parses out the properties of a selector ' s body .",
    "text_2": "private Property [ ] parse Properties ( final String contents ) { final String [ ] parts = contents . split ( STRING ) ; final List < Property > results As List = new Array List < Property > ( ) ; for ( String part : parts ) { try { if ( ! String Utils . is Empty ( part . trim ( ) ) ) { results As List . add ( new Property ( part ) ) ; } } catch ( final Exception e ) { LOG . warn ( e . get Message ( ) , e ) ; } } return results As List . to Array ( new Property [ results As List . size ( ) ] ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the user hits the cancel button in the progress dialog .",
    "text_2": "public boolean is Canceled ( ) { if ( pane = = null ) return BOOL ; Object v = pane . get Value ( ) ; return ( ( v ! = null ) & & ( cancel Option . length = = NUM ) & & ( v . equals ( cancel Option [ NUM ] ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "validates that the given participant ids are equal . this is used to ensure that the payloads received from each round all come from the same participant .",
    "text_2": "public static void validate Participant Ids Equal ( String expected Participant Id , String actual Participant Id ) throws Crypto Exception { if ( ! expected Participant Id . equals ( actual Participant Id ) ) { throw new Crypto Exception ( STRING + actual Participant Id + STRING + expected Participant Id + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "increments the cumulative count of evaluations and recalculates the rate . only synchronizes the count increment , not the whole method .",
    "text_2": "public void increment ( ) { count . increment And Get ( ) ; rate Window . increment For Timestamp ( timer Getter . now ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "subtract two numbers of the same length and different signs . the first is positive . the second is greater in absolute value .",
    "text_2": "public void test Case NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "append a path segment",
    "text_2": "public void add ( XMP Path Segment segment ) { segments . add ( segment ) ; }",
    "label": 1
  },
  {
    "text_1": "concat in ate the iv to the ciphertext using array copy . this is used e . g . before computing mac .",
    "text_2": "public static byte [ ] iv Cipher Concat ( byte [ ] iv , byte [ ] cipher Text ) { byte [ ] combined = new byte [ iv . length + cipher Text . length ] ; System . arraycopy ( iv , NUM , combined , NUM , iv . length ) ; System . arraycopy ( cipher Text , NUM , combined , iv . length , cipher Text . length ) ; return combined ; }",
    "label": 1
  },
  {
    "text_1": "evaluate text in the interpreter at url , returning a possible integer return value .",
    "text_2": "public static int eval ( String url , String text ) throws IO Exception { String return Value = null ; if ( url . starts With ( STRING ) ) { return Value = do Http ( url , text ) ; } else if ( url . starts With ( STRING ) ) { return Value = do Bsh ( url , text ) ; } else throw new IO Exception ( STRING + STRING ) ; try { return Integer . parse Int ( return Value ) ; } catch ( Exception e ) { return NUM ; } }",
    "label": 1
  },
  {
    "text_1": "copies an array of vertices and quads to the current shape . this method converts quads to polygons and then calls the main copy to method .",
    "text_2": "public void copy To ( Position Texture Vertex [ ] verts , Textured Quad [ ] quad ) { Textured Polygon [ ] poly = new Textured Polygon [ quad . length ] ; for ( int idx = NUM ; idx < quad . length ; idx + + ) { poly [ idx ] = new Textured Polygon ( ( Position Texture Vertex [ ] ) quad [ idx ] . vertex Positions ) ; } copy To ( verts , poly ) ; }",
    "label": 1
  },
  {
    "text_1": "dom level 1 did not have a standard mechanism for creating a new document object . this function provides a dom - implementation - independent abstraction for that for that concept . it ' s typically used when outputting a new dom as the result of an operation . todo : this isn ' t directly comp atable with dom level 2 . the level 2 create document call also creates the root element , and thus requires that you know what that element will be before creating the document . we should think about whether we want to change this code , and the callers , so we can use the dom ' s own method . ( it ' s also possible that dom level 3 may relax this sequence , but you may give up some intelligence in the dom by doing so ; the intent was that knowing the document type and root element might let the dom automatically switch to a specialized subclass for particular kinds of documents . )",
    "text_2": "public static Document create Document ( boolean is Secure Processing ) { try { Document Builder Factory d factory = Document Builder Factory . new Instance ( ) ; d factory . set Namespace Aware ( BOOL ) ; Document Builder doc Builder = d factory . new Document Builder ( ) ; Document out Node = doc Builder . new Document ( ) ; return out Node ; } catch ( Parser Configuration Exception pce ) { throw new Runtime Exception ( XML Messages . create XML Message ( XML Error Resources . ER CREATE DOCUMENT NOT SUPPORTED , null ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "create an animation that snaps the view into position vertically .",
    "text_2": "void create Vertical Snap Animation ( boolean visible ) { float translation Y = visible ? NUM : m Total Height ; float y Difference = Math . abs ( translation Y - get Translation Y ( ) ) / m Total Height ; long duration = ( long ) ( MS ANIMATION DURATION * y Difference ) ; create Animation ( NUM , NUM , translation Y , duration ) ; }",
    "label": 1
  },
  {
    "text_1": "extracts specified entries from jar file .",
    "text_2": "void extract ( Input Stream in , String files [ ] ) throws IO Exception { Zip Input Stream zis = new Zip Input Stream ( in ) ; Zip Entry e ; Set < Zip Entry > dirs = new Dir Set ( ) ; while ( ( e = zis . get Next Entry ( ) ) ! = null ) { if ( files = = null ) { dirs . add ( extract File ( zis , e ) ) ; } else { String name = e . get Name ( ) ; for ( String file : files ) { if ( name . starts With ( file ) ) { dirs . add ( extract File ( zis , e ) ) ; break ; } } } } update Last Modified Time ( dirs ) ; }",
    "label": 1
  },
  {
    "text_1": "like grep - v , but in java . unfortunately this will replace any new lines with the current platforms new line .",
    "text_2": "public static String grep Minus V ( String val , String pattern ) { return grep Inner ( val , pattern , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "start the service to process the current event notifications , acquiring the wake lock before returning to ensure that the service will run .",
    "text_2": "public static void begin Starting Service ( Context context , Intent intent ) { synchronized ( m Starting Service Sync ) { if ( m Starting Service = = null ) { Power Manager pm = ( Power Manager ) context . get System Service ( Context . POWER SERVICE ) ; m Starting Service = pm . new Wake Lock ( Power Manager . PARTIAL WAKE LOCK , STRING ) ; m Starting Service . set Reference Counted ( BOOL ) ; } m Starting Service . acquire ( ) ; context . start Service ( intent ) ; } }",
    "label": 1
  },
  {
    "text_1": "add a action to this notification . actions are typically displayed as a button adjacent to the notification content .",
    "text_2": "public void add Action ( Action act ) { if ( act . entry ! = null & & act . entry ! = this ) { Log . e ( TAG , STRING + act . entry . ID + STRING + ID ) ; return ; } if ( m Actions = = null ) { m Actions = new Array List < Action > ( ) ; } if ( m Actions . size ( ) = = NUM ) { Log . w ( TAG , STRING ) ; return ; } act . entry = this ; m Actions . add ( act ) ; }",
    "label": 1
  },
  {
    "text_1": "attempt to login to the lob by server if we could not login , return null .",
    "text_2": "public Lobby Client login ( ) { if ( ! m server Properties . is Server Available ( ) ) { J Option Pane . show Message Dialog ( m parent , m server Properties . server Error Message , STRING , J Option Pane . ERROR MESSAGE ) ; return null ; } if ( m server Properties . port = = - NUM ) { if ( Client File System Helper . are We Old Extra Jar ( ) ) { J Option Pane . show Message Dialog ( m parent , STRING + Url Constants . LATEST GAME DOWNLOAD WEBSITE + STRING + STRING , STRING , J Option Pane . ERROR MESSAGE ) ; } else { J Option Pane . show Message Dialog ( m parent , STRING + Url Constants . LATEST GAME DOWNLOAD WEBSITE + STRING , STRING , J Option Pane . ERROR MESSAGE ) ; } return null ; } return login To Server ( ) ; }",
    "label": 1
  },
  {
    "text_1": "method to convert the given selector into the extracted biginteger partitions",
    "text_2": "public static List < Big Integer > embedded Selector To Partitions ( String selector , String type , Data Partitioner partitioner ) throws PIR Exception { List < Big Integer > parts ; int partition Bits = partitioner . get Bits ( type ) ; if ( partition Bits > NUM ) { int hashed Selector = Keyed Hash . hash ( STRING , NUM , selector , STRING ) ; parts = partitioner . to Partitions ( hashed Selector , Primitive Type Partitioner . INT ) ; } else { parts = partitioner . to Partitions ( selector , type ) ; } return parts ; }",
    "label": 1
  },
  {
    "text_1": "queues a new item to be loaded . thread - safe .",
    "text_2": "public synchronized void add To Queue ( final Image Resource Loader image Resource Loader , final String uri , final Mutable FS Image mf si , final int width , final int height ) { XR Log . general ( Level . FINE , STRING + uri ) ; load Queue . add Last ( new Image Load Item ( image Resource Loader , uri , mf si , width , height ) ) ; notify All ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a forward reference to this label . this method must be called only for a true forward reference , i . e . only if this label is not resolved yet . for backward references , the offset of the reference can be , and must be , computed and stored directly .",
    "text_2": "private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions = = null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count > = src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count + + ] = source Position ; src And Ref Positions [ reference Count + + ] = reference Position ; }",
    "label": 1
  },
  {
    "text_1": "sign alizes that the backlog can proceed with the next item",
    "text_2": "public void proceed ( ) { idle . set ( BOOL ) ; subject . on Next ( null ) ; }",
    "label": 1
  },
  {
    "text_1": "convenient utility method that returns collection of node ids for a given collection of grid nodes . note that this method doesn ' t create a new collection but simply iterates over the input one .",
    "text_2": "public static Collection < UUID > node Ids ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes = = null | | nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , node NUM id ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "process a new port . if link discovery is disabled on the port , then do nothing . if autop ort fast feature is enabled and the port is a fast port , then do nothing . otherwise , send l ldp message . add the port to quarant ine .",
    "text_2": "private void process New Port ( Datapath Id sw , OF Port p ) { if ( is Link Discovery Suppressed ( sw , p ) ) { return ; } IOF Switch iof Switch = switch Service . get Switch ( sw ) ; if ( iof Switch = = null ) { return ; } Node Port Tuple npt = new Node Port Tuple ( sw , p ) ; discover ( sw , p ) ; add To Quarantine Queue ( npt ) ; }",
    "label": 1
  },
  {
    "text_1": "blocks the executing thread until at least one server has started .",
    "text_2": "void wait For Server Start ( ) throws Interrupted Exception { started . await ( get Test Timeout ( ) , Time Unit . MILLISECONDS ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the length of the common prefix between s1 and s2 .",
    "text_2": "public static int prefix Length ( char [ ] s1 , char [ ] s2 ) { int len = NUM ; int max = Math . min ( s1 . length , s2 . length ) ; for ( int i = NUM ; i < max & & s1 [ i ] = = s2 [ i ] ; + + i ) + + len ; return len ; }",
    "label": 1
  },
  {
    "text_1": "creates an asynchronous buffered output stream .",
    "text_2": "public Async Buffered Output Stream ( Output Stream out , int buf Size , int max Buffers ) { super ( out ) ; buffers = new Concurrent Linked Deque < > ( ) ; buf = new byte [ buf Size ] ; flush er Thread . start ( ) ; }",
    "label": 1
  },
  {
    "text_1": "builds a get storage response .",
    "text_2": "private void build Get Storage Response ( Mock Closeable Http Response response , URI uri ) throws JAXB Exception { Pattern pattern = Pattern . compile ( STRING ) ; Matcher matcher = pattern . matcher ( uri . get Path ( ) ) ; if ( matcher . find ( ) ) { Storage storage = get New Storage ( matcher . group ( NUM ) ) ; response . set Entity ( get Http Entity ( storage ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "draws a line graph with the standard deviation high and low lines",
    "text_2": "public Buffered Image draw Bar Graph With Std Dev ( String graph Title , String x Label , String y Label , Hash Map < Comparable Label , Integer [ ] > bar Data Points , String [ ] bar Labels , Long std Dev High , Long std Dev Low , Long graph Max Value ) { Buffered Image bi = new Buffered Image ( this . WIDTH , this . HEIGHT , Buffered Image . TYPE INT ARGB ) ; Graphics NUM D g NUM d = bi . create Graphics ( ) ; Rendering Hints render Hints = new Rendering Hints ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g NUM d . set Rendering Hints ( render Hints ) ; draw Chart And Graph Rectangles ( g NUM d ) ; draw Bar Legend ( g NUM d , STRING , bar Labels , std Dev High , std Dev Low ) ; draw Title And Labels ( g NUM d , graph Title , x Label , y Label ) ; Collection < Integer [ ] > value Collection = bar Data Points . values ( ) ; Set < Comparable Label > date Key Set = bar Data Points . key Set ( ) ; long max Value = NUM ; for ( Integer [ ] int Array : value Collection ) { for ( Integer int Value : int Array ) { if ( max Value < int Value ) { max Value = int Value ; } } } long y Max Mark = NUM ; int y Label X Offset = NUM ; y Max Mark = determine Y Max Mark ( max Value , std Dev High , graph Max Value ) ; draw Y Axis Divisions ( g NUM d , y Max Mark , y Label X Offset ) ; Array List < Comparable Label > ordered Date Set = new Array List < Comparable Label > ( ) ; ordered Date Set . add All ( date Key Set ) ; Collections . sort ( ordered Date Set ) ; draw X Axis Divisions ( g NUM d , ordered Date Set ) ; draw Bars On Graph ( g NUM d , ordered Date Set , bar Data Points , y Max Mark ) ; if ( std Dev High ! = null ) { draw Std Dev Line ( g NUM d , std Dev High , y Max Mark , this . std Dev High Color ) ; } if ( std Dev Low ! = null ) { draw Std Dev Line ( g NUM d , std Dev Low , y Max Mark , this . std Dev Low Color ) ; } return bi ; }",
    "label": 1
  },
  {
    "text_1": "reloads the queue as the user left it the last time they stopped using apollo",
    "text_2": "private void reload Queue ( ) { String q = null ; int id = m Card Id ; if ( m Preferences . contains ( STRING ) ) { id = m Preferences . get Int ( STRING , ~ m Card Id ) ; } if ( id = = m Card Id ) { q = m Preferences . get String ( STRING , STRING ) ; } int qlen = q ! = null ? q . length ( ) : NUM ; if ( qlen > NUM ) { int plen = NUM ; int n = NUM ; int shift = NUM ; for ( int i = NUM ; i < qlen ; i + + ) { final char c = q . char At ( i ) ; if ( c = = STRING ) { ensure Play List Capacity ( plen + NUM ) ; m Play List [ plen ] = n ; plen + + ; n = NUM ; shift = NUM ; } else { if ( c > = STRING & & c < = STRING ) { n + = c - STRING < < shift ; } else if ( c > = STRING & & c < = STRING ) { n + = NUM + c - STRING < < shift ; } else { plen = NUM ; break ; } shift + = NUM ; } } m Play List Len = plen ; final int pos = m Preferences . get Int ( STRING , NUM ) ; if ( pos < NUM | | pos > = m Play List Len ) { m Play List Len = NUM ; return ; } m Play Pos = pos ; update Cursor ( m Play List [ m Play Pos ] ) ; if ( m Cursor = = null ) { System Clock . sleep ( NUM ) ; update Cursor ( m Play List [ m Play Pos ] ) ; } synchronized ( this ) { close Cursor ( ) ; m Open Failed Counter = NUM ; open Current And Next ( ) ; } if ( m Player = = null | | ! m Player . is Initialized ( ) ) { m Play List Len = NUM ; return ; } final long se ek pos = m Preferences . get Long ( STRING , NUM ) ; seek ( se ek pos > = NUM & & se ek pos < duration ( ) ? se ek pos : NUM ) ; if ( D ) { LOG . info ( STRING + position ( ) + STRING + duration ( ) + STRING + se ek pos + STRING ) ; } int rep mode = m Preferences . get Int ( STRING , REPEAT NONE ) ; if ( rep mode ! = REPEAT ALL & & rep mode ! = REPEAT CURRENT ) { rep mode = REPEAT NONE ; } m Repeat Mode = rep mode ; int sh uf mode = m Preferences . get Int ( STRING , SHUFFLE NONE ) ; if ( sh uf mode ! = SHUFFLE AUTO & & sh uf mode ! = SHUFFLE NORMAL ) { sh uf mode = SHUFFLE NONE ; } if ( sh uf mode ! = SHUFFLE NONE ) { q = m Preferences . get String ( STRING , STRING ) ; qlen = q ! = null ? q . length ( ) : NUM ; if ( qlen > NUM ) { n = NUM ; shift = NUM ; m History . clear ( ) ; for ( int i = NUM ; i < qlen ; i + + ) { final char c = q . char At ( i ) ; if ( c = = STRING ) { if ( n > = m Play List Len ) { m History . clear ( ) ; break ; } m History . add ( n ) ; n = NUM ; shift = NUM ; } else { if ( c > = STRING & & c < = STRING ) { n + = c - STRING < < shift ; } else if ( c > = STRING & & c < = STRING ) { n + = NUM + c - STRING < < shift ; } else { m History . clear ( ) ; break ; } shift + = NUM ; } } } } if ( sh uf mode = = SHUFFLE AUTO ) { if ( ! make Auto Shuffle List ( ) ) { sh uf mode = SHUFFLE NONE ; } } m Shuffle Mode = sh uf mode ; } }",
    "label": 1
  },
  {
    "text_1": "write a float from the output stream , byte - swapping as necessary",
    "text_2": "public static void write Float ( Data Output Stream dos , boolean is Big Endian , float val ) throws IO Exception { if ( ! is Big Endian ) { write Little Endian Float ( dos , val ) ; } else { dos . write Float ( val ) ; } }",
    "label": 1
  },
  {
    "text_1": "converts tabul ations to white spaces at the target line ' s indent space .",
    "text_2": "@ Not Null private static Text Range process Spaces ( @ Not Null Helper helper , @ Not Null Text Range range , int tab Width ) { Char Sequence indent = helper . get Current Line Indent ( ) ; int start = Math . max ( NUM , range . get Start Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int end = Math . min ( indent . length ( ) , range . get End Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int tabs Number = NUM ; int indent Offset = end ; for ( int i = start ; i < end ; i + + ) { char c = indent . char At ( i ) ; if ( c = = STRING ) { tabs Number + + ; } else if ( c ! = STRING ) { indent Offset = i ; break ; } } if ( tabs Number > NUM ) { helper . replace ( start , indent Offset , String Util . repeat ( STRING , indent Offset - start - tabs Number + tabs Number * tab Width ) ) ; return Text Range . create ( range . get Start Offset ( ) , range . get End Offset ( ) - tabs Number + tabs Number * tab Width ) ; } else { return range ; } }",
    "label": 1
  },
  {
    "text_1": "write the graphics out to a file",
    "text_2": "public void write Graphics ( String graphics Save File ) throws IO Exception { File Output Stream ostream = new File Output Stream ( graphics Save File ) ; Object Output Stream object stream = new Object Output Stream ( ostream ) ; write Graphics ( object stream ) ; object stream . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the displayed width of a string , taking in account the displayed tab width . the result can be compared against the print margin .",
    "text_2": "private static int calculate Displayed Width ( String string ) { final int tab Width = DEFAULT TAB WIDTH ; int column = NUM ; for ( int i = NUM ; i < string . length ( ) ; i + + ) { if ( STRING = = string . char At ( i ) ) { column + = tab Width - ( column % tab Width ) ; } else { column + + ; } } return column ; }",
    "label": 1
  },
  {
    "text_1": "removes the first instance of a sound from the audio queue .",
    "text_2": "public void dequeue Sound ( Uri uri ) { m Audio Queue . remove ( new Audio Queue Item ( uri , null ) ) ; }",
    "label": 1
  },
  {
    "text_1": "mb per sec is the mb / sec max io rate",
    "text_2": "public Simple Rate Limiter ( double mb Per Sec ) { set MB Per Sec ( mb Per Sec ) ; last NS = System . nano Time ( ) ; }",
    "label": 1
  },
  {
    "text_1": "add a list of exception handler class names .",
    "text_2": "public void add Classes ( List < String > class Names ) { if ( handler Factories = = null ) { handler Factories = new Array List < String > ( ) ; } handler Factories . add All ( class Names ) ; }",
    "label": 1
  },
  {
    "text_1": "reads document from file",
    "text_2": "public static Document read Document ( String file Name ) throws SAX Exception , IO Exception { Document Builder doc Builder ; Document result = null ; Document Builder Factory doc Builder Factory = Document Builder Factory . new Instance ( ) ; doc Builder Factory . set Ignoring Element Content Whitespace ( BOOL ) ; try { doc Builder = doc Builder Factory . new Document Builder ( ) ; } catch ( Parser Configuration Exception e ) { throw new Error ( e ) ; } File source File = new File ( file Name ) ; result = doc Builder . parse ( source File ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "close the single hibernate session instance .",
    "text_2": "public static void close Session ( ) throws Hibernate Exception { Session session = ( Session ) thread Local . get ( ) ; thread Local . set ( null ) ; if ( session ! = null ) { session . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "load an existing model .",
    "text_2": "public Noise Tag L da Model ( Input Stream in ) throws IO Exception { GZIP Input Stream zip in = new GZIP Input Stream ( in ) ; Buffered Input Stream bin = new Buffered Input Stream ( zip in ) ; Data Input Stream dat ain = new Data Input Stream ( bin ) ; num Topics = dat ain . read Int ( ) ; int num Words = dat ain . read Int ( ) ; alpha = dat ain . read Double ( ) ; beta = dat ain . read Double ( ) ; locked = dat ain . read Boolean ( ) ; wn z = new int [ num Topics ] ; Arrays . fill ( wn z , NUM ) ; for ( int i = NUM ; i < num Words ; i + + ) { String word = dat ain . read UTF ( ) ; int [ ] count = new int [ num Topics ] ; for ( int j = NUM ; j < num Topics ; j + + ) { count [ j ] = dat ain . read Int ( ) ; wn z [ j ] + = count [ j ] ; nw + = count [ j ] ; } nw z . put ( word , count ) ; } t nz = new int [ num Topics + NUM ] ; Arrays . fill ( t nz , NUM ) ; int num Tags = dat ain . read Int ( ) ; eta = dat ain . read Double ( ) ; for ( int i = NUM ; i < num Tags ; i + + ) { String word = dat ain . read UTF ( ) ; int [ ] count = new int [ num Topics + NUM ] ; for ( int j = NUM ; j < num Topics + NUM ; j + + ) { count [ j ] = dat ain . read Int ( ) ; t nz [ j ] + = count [ j ] ; nt + = count [ j ] ; } n tz . put ( word , count ) ; } noise = num Topics ; }",
    "label": 1
  },
  {
    "text_1": "log the specified information .",
    "text_2": "public static void log Info ( String message , Object . . . args ) { message = Message Format . format ( message , args ) ; log ( I Status . INFO , I Status . OK , message , null ) ; }",
    "label": 1
  },
  {
    "text_1": "formats the given integer in the format required by a numeric field .",
    "text_2": "public static String format ( Integer i ) { if ( i = = null ) return null ; return i . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "check string is null or empty",
    "text_2": "public static boolean is Empty ( String string ) { return string = = null | | string . length ( ) < = NUM ; }",
    "label": 1
  },
  {
    "text_1": "this is used internally by the framework",
    "text_2": "void set Text ( byte [ ] text ) { this . text = text ; this . props = null ; }",
    "label": 1
  },
  {
    "text_1": "initializes a new instance with the specified regular expression pattern , a type for generated tokens , and a name of a grammar state that should be triggered .",
    "text_2": "public Rule ( String pattern , Object token Type , String next State ) { this . pattern = Pattern . compile ( pattern ) ; this . token Type = token Type ; this . next State = next State ; }",
    "label": 1
  },
  {
    "text_1": "internal : cascade register new for create through mappings that require the cascade",
    "text_2": "@ Override public void cascade Register New If Required ( Object object , Unit Of Work Impl uow , Map visited Objects ) { cascade Register New If Required ( object , uow , visited Objects , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the trigonometric sine of the number .",
    "text_2": "public static Number sin ( Number a ) { return Math . sin ( a . double Value ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method will be used to read int from file from postion ( offset ) , here length will be always 4 bac ause int byte size if 4",
    "text_2": "@ Override public long read Double ( String file Path , long offset ) { File Channel file Channel = update Cache ( file Path ) ; Byte Buffer byte Bffer = read ( file Channel , Carbon Common Constants . LONG SIZE IN BYTE , offset ) ; return byte Bffer . get Long ( ) ; }",
    "label": 1
  },
  {
    "text_1": "add the given shard .",
    "text_2": "public void add Map ( Map < K , V > map , K min , K max ) { if ( min ! = null & & max ! = null & & key Type . compare ( min , max ) > NUM ) { Data Utils . new Illegal Argument Exception ( STRING , min , max ) ; } int len = shards . length + NUM ; Shard < K , V > [ ] new Shards = Arrays . copy Of ( shards , len ) ; Shard < K , V > new Shard = new Shard < K , V > ( ) ; new Shard . map = map ; new Shard . min Including = min ; new Shard . max Excluding = max ; new Shards [ len - NUM ] = new Shard ; shards = new Shards ; }",
    "label": 1
  },
  {
    "text_1": "return the number of processors , always at least one .",
    "text_2": "public int available Processors ( ) { return RVM Thread . available Processors ; }",
    "label": 1
  },
  {
    "text_1": "remove an ap po ffer from the binder when user adds to base plan",
    "text_2": "public void remove App Offer ( Offer offer ) { int index To Remove = get Index ( offer ) ; if ( index To Remove ! = - NUM ) { app Offers . remove ( index To Remove ) ; notify Data Set Changed ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "build a vector of valid qnames from content spec table .",
    "text_2": "private void content Spec Tree ( int content Spec Index , XML Content Spec content Spec , Children List children ) { get Content Spec ( content Spec Index , content Spec ) ; if ( content Spec . type = = XML Content Spec . CONTENTSPECNODE LEAF | | ( content Spec . type & NUM ) = = XML Content Spec . CONTENTSPECNODE ANY | | ( content Spec . type & NUM ) = = XML Content Spec . CONTENTSPECNODE ANY LOCAL | | ( content Spec . type & NUM ) = = XML Content Spec . CONTENTSPECNODE ANY OTHER ) { if ( children . length = = children . qname . length ) { Q Name [ ] new Q Name = new Q Name [ children . length * NUM ] ; System . arraycopy ( children . qname , NUM , new Q Name , NUM , children . length ) ; children . qname = new Q Name ; int [ ] new Type = new int [ children . length * NUM ] ; System . arraycopy ( children . type , NUM , new Type , NUM , children . length ) ; children . type = new Type ; } children . qname [ children . length ] = new Q Name ( null , ( String ) content Spec . value , ( String ) content Spec . value , ( String ) content Spec . other Value ) ; children . type [ children . length ] = content Spec . type ; children . length + + ; return ; } final int left Node = content Spec . value ! = null ? ( ( int [ ] ) ( content Spec . value ) ) [ NUM ] : - NUM ; int right Node = - NUM ; if ( content Spec . other Value ! = null ) right Node = ( ( int [ ] ) ( content Spec . other Value ) ) [ NUM ] ; else return ; if ( content Spec . type = = XML Content Spec . CONTENTSPECNODE CHOICE | | content Spec . type = = XML Content Spec . CONTENTSPECNODE SEQ ) { content Spec Tree ( left Node , content Spec , children ) ; content Spec Tree ( right Node , content Spec , children ) ; return ; } if ( content Spec . type = = XML Content Spec . CONTENTSPECNODE ZERO OR ONE | | content Spec . type = = XML Content Spec . CONTENTSPECNODE ZERO OR MORE | | content Spec . type = = XML Content Spec . CONTENTSPECNODE ONE OR MORE ) { content Spec Tree ( left Node , content Spec , children ) ; return ; } throw new Runtime Exception ( STRING + content Spec . type ) ; }",
    "label": 1
  },
  {
    "text_1": "print a message reporting an input / output error .",
    "text_2": "void io Message ( Throwable ex ) { log . print Lines ( Prefix Kind . JAV AC , STRING ) ; ex . print Stack Trace ( log . get Writer ( Writer Kind . NOTICE ) ) ; }",
    "label": 1
  },
  {
    "text_1": "helper method to process the candidates returned by get potential candidates .",
    "text_2": "private void handle Get Candidate Result ( Placement Task current State , Operation post Operation , Map < String , Server Address > candidates , Stopwatch placement Watch ) { Service Utils . log Info ( this , STRING , placement Watch . elapsed ( Time Unit . MILLISECONDS ) ) ; if ( candidates . is Empty ( ) ) { String msg = String . format ( STRING , current State . resource ) ; Placement Task patch State = build Patch ( Task State . Task Stage . FAILED , current State . task State . is Direct , null ) ; patch State . result Code = Place Result Code . NO SUCH RESOURCE ; patch State . error = msg ; fail Task ( patch State , new Throwable ( msg ) , post Operation ) ; return ; } Service Utils . log Info ( this , STRING , candidates , current State . timeout Ms ) ; Stopwatch score Candidates Stopwatch = Stopwatch . create Started ( ) ; query Hosts For Scores ( current State . resource , candidates , null ) ; }",
    "label": 1
  },
  {
    "text_1": "draws a cubic line .",
    "text_2": "protected void draw Cubic ( Canvas c , Line Data Set data Set , List < Entry > entries ) { Transformer trans = m Chart . get Transformer ( data Set . get Axis Dependency ( ) ) ; Entry entry From = data Set . get Entry For X Index ( m Min X ) ; Entry entry To = data Set . get Entry For X Index ( m Max X ) ; int diff = ( entry From = = entry To ) ? NUM : NUM ; int minx = Math . max ( data Set . get Entry Position ( entry From ) - diff , NUM ) ; int maxx = Math . min ( Math . max ( minx + NUM , data Set . get Entry Position ( entry To ) + NUM ) , entries . size ( ) ) ; float phase X = m Animator . get Phase X ( ) ; float phase Y = m Animator . get Phase Y ( ) ; float intensity = data Set . get Cubic Intensity ( ) ; cubic Path . reset ( ) ; int size = ( int ) Math . ceil ( ( maxx - minx ) * phase X + minx ) ; if ( size - minx > = NUM ) { float prev Dx = NUM ; float prev Dy = NUM ; float cur Dx = NUM ; float cur Dy = NUM ; Entry prev Prev = entries . get ( minx ) ; Entry prev = entries . get ( minx ) ; Entry cur = entries . get ( minx ) ; Entry next = entries . get ( minx + NUM ) ; cubic Path . move To ( cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; prev Dx = ( cur . get X Index ( ) - prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - cur . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - cur . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; for ( int j = minx + NUM , count = Math . min ( size , entries . size ( ) - NUM ) ; j < count ; j + + ) { prev Prev = entries . get ( j = = NUM ? NUM : j - NUM ) ; prev = entries . get ( j - NUM ) ; cur = entries . get ( j ) ; next = entries . get ( j + NUM ) ; prev Dx = ( cur . get X Index ( ) - prev Prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; } if ( size > entries . size ( ) - NUM ) { prev Prev = entries . get ( ( entries . size ( ) > = NUM ) ? entries . size ( ) - NUM : entries . size ( ) - NUM ) ; prev = entries . get ( entries . size ( ) - NUM ) ; cur = entries . get ( entries . size ( ) - NUM ) ; next = cur ; prev Dx = ( cur . get X Index ( ) - prev Prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; } } if ( data Set . is Draw Filled Enabled ( ) ) { cubic Fill Path . reset ( ) ; cubic Fill Path . add Path ( cubic Path ) ; draw Cubic Fill ( m Bitmap Canvas , data Set , cubic Fill Path , trans , entry From . get X Index ( ) , entry From . get X Index ( ) + size ) ; } m Render Paint . set Color ( data Set . get Color ( ) ) ; m Render Paint . set Style ( Paint . Style . STROKE ) ; trans . path Value To Pixel ( cubic Path ) ; m Bitmap Canvas . draw Path ( cubic Path , m Render Paint ) ; m Render Paint . set Path Effect ( null ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the empty list .",
    "text_2": "public static < E > List < E > of ( ) { return Collections . empty List ( ) ; }",
    "label": 1
  },
  {
    "text_1": "convert eg [ \" 1 \" , \" 2 \" ] to [ 1 , 2 ]",
    "text_2": "public static final int [ ] to Int Array ( String s [ ] ) { int u [ ] = new int [ s . length ] ; for ( int j = NUM ; j < s . length ; j + + ) { u [ j ] = Integer . parse Int ( s [ j ] ) ; } return u ; }",
    "label": 1
  },
  {
    "text_1": "creates an element in the xml signature 1 . 1 specification namespace .",
    "text_2": "public static Element create Element In Signature NUM Space ( Document doc , String element Name ) { if ( doc = = null ) { throw new Runtime Exception ( STRING ) ; } if ( ( ds NUM Prefix = = null ) | | ( ds NUM Prefix . length ( ) = = NUM ) ) { return doc . create Element NS ( Constants . Signature Spec NUM NS , element Name ) ; } return doc . create Element NS ( Constants . Signature Spec NUM NS , ds NUM Prefix + STRING + element Name ) ; }",
    "label": 1
  },
  {
    "text_1": "updates the max text width values for the suggestions .",
    "text_2": "public void update Max Text Widths ( float required Width , float match Contents Width ) { m Max Required Width = Math . max ( m Max Required Width , required Width ) ; m Max Match Contents Width = Math . max ( m Max Match Contents Width , match Contents Width ) ; }",
    "label": 1
  },
  {
    "text_1": "process an object retrieved as a bean or attribute . object can be a typed attribute , a string , or anything else . if typed attribute , use associated type . otherwise , apply tostring ( ) on object , and use returned string as a name .",
    "text_2": "public Tag Handler process Object Value ( Object value ) throws Jsp Exception { if ( value instanceof Attribute Definition ) { return process Typed Attribute ( ( Attribute Definition ) value ) ; } else if ( value instanceof Component Definition ) { return process Definition ( ( Component Definition ) value ) ; } return process As Definition Or URL ( value . to String ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "deletes an entry from the keystore .",
    "text_2": "private void do Delete Entry ( String alias ) throws Exception { if ( key Store . contains Alias ( alias ) = = BOOL ) { Message Format form = new Message Format ( rb . get String ( STRING ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } key Store . delete Entry ( alias ) ; }",
    "label": 1
  },
  {
    "text_1": "validates a given resource against a given shape .",
    "text_2": "public Model validate Node Against Shape ( Dataset dataset , URI shapes Graph URI , Node focus Node , Node shape , Resource min Severity , Predicate < SH Constraint > constraint Filter , Function < RDF Node , String > label Function , Progress Monitor monitor ) { Model results = Jena Util . create Memory Model ( ) ; Model old Results = get Current Results Model ( ) ; set Current Results Model ( results ) ; add Resource Violations ( dataset , shapes Graph URI , focus Node , shape , SH ACL Util . get All Constraint Properties ( BOOL ) , min Severity , constraint Filter , results , label Function , monitor ) ; set Current Results Model ( old Results ) ; return results ; }",
    "label": 1
  },
  {
    "text_1": "this class sometimes provides a list of value descriptions .",
    "text_2": "@ Override public boolean has Values Description ( ) { return restriction Class ! = null & & restriction Class ! = Object . class ; }",
    "label": 1
  },
  {
    "text_1": "makes a random cache entry .",
    "text_2": "public static Cache . Entry make Random Cache Entry ( byte [ ] data , boolean is Expired , boolean needs Refresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data ! = null ) { entry . data = data ; } else { entry . data = new byte [ random . next Int ( NUM ) ] ; } entry . etag = String . value Of ( random . next Long ( ) ) ; entry . last Modified = random . next Long ( ) ; entry . ttl = is Expired ? NUM : Long . MAX VALUE ; entry . soft Ttl = needs Refresh ? NUM : Long . MAX VALUE ; return entry ; }",
    "label": 1
  },
  {
    "text_1": "creates a new annotation . if there already exists a class / interface with the same name , the new interface overwrites that previous one .",
    "text_2": "public Ct Class make Annotation ( String name ) throws Runtime Exception { try { Ct Class cc = make Interface ( name , get ( STRING ) ) ; cc . set Modifiers ( cc . get Modifiers ( ) | Modifier . ANNOTATION ) ; return cc ; } catch ( Not Found Exception e ) { throw new Runtime Exception ( e . get Message ( ) , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "checks if child element has same owner document before appending to the parent , and imports it to the parent ' s document if necessary .",
    "text_2": "public static void append Child ( Node parent , Node child ) { Document owner Doc = get Owner Document ( parent ) ; if ( child . get Owner Document ( ) ! = owner Doc ) { parent . append Child ( owner Doc . import Node ( child , BOOL ) ) ; } else { parent . append Child ( child ) ; } }",
    "label": 1
  },
  {
    "text_1": "check that class c does not implement directly or indirectly the same parameterized interface with two different argument lists .",
    "text_2": "void check Class Bounds ( Diagnostic Position pos , Type type ) { check Class Bounds ( pos , new Hash Map < Type Symbol , Type > ( ) , type ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the ascii characters up to but not including the next \" \\ r \\ n \" , or \" \\ n \" .",
    "text_2": "public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM ) ; while ( BOOL ) { int c = in . read ( ) ; if ( c = = - NUM ) { throw new EOF Exception ( ) ; } else if ( c = = STRING ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM & & result . char At ( length - NUM ) = = STRING ) { result . set Length ( length - NUM ) ; } return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if the current state is marked as a list state .",
    "text_2": "protected final boolean is List State ( ) { return state Text Types . char At ( state ) = = STRING ; }",
    "label": 1
  },
  {
    "text_1": "encodes a string into base 64 format . no blanks or line breaks are inserted .",
    "text_2": "public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "sets the current attribute as class attribute , i . e . it moves it to the end of the attributes",
    "text_2": "public void attribute As Class ( ) { Data Sorted Table Model model ; if ( m Current Col = = - NUM ) { return ; } model = ( Data Sorted Table Model ) m Table Data . get Model ( ) ; if ( model . get Attribute At ( m Current Col ) = = null ) { return ; } set Cursor ( Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ) ; model . attribute As Class At ( m Current Col ) ; set Cursor ( Cursor . get Predefined Cursor ( Cursor . DEFAULT CURSOR ) ) ; }",
    "label": 1
  },
  {
    "text_1": "generate final instruction list .",
    "text_2": "@ Override public Insn List generate ( ) { return merge ( generated Instructions . to Array ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "apply mask penalty rule 4 and return the penalty . calculate the ratio of dark cells and give penalty if the ratio is far from 50 % . it gives 10 penalty for 5 % distance . examples : - 0 % = > 100 - 40 % = > 20 - 45 % = > 10 - 50 % = > 0 - 55 % = > 10 - 55 % = > 20 - 100 % = > 100",
    "text_2": "public static int apply Mask Penalty Rule NUM ( Byte Matrix matrix ) { int num Dark Cells = NUM ; byte [ ] [ ] array = matrix . get Array ( ) ; int width = matrix . get Width ( ) ; int height = matrix . get Height ( ) ; for ( int y = NUM ; y < height ; + + y ) { for ( int x = NUM ; x < width ; + + x ) { if ( array [ y ] [ x ] = = NUM ) { num Dark Cells + = NUM ; } } } int num Total Cells = matrix . get Height ( ) * matrix . get Width ( ) ; double dark Ratio = ( double ) num Dark Cells / num Total Cells ; return Math . abs ( ( int ) ( dark Ratio * NUM - NUM ) ) / NUM * NUM ; }",
    "label": 1
  },
  {
    "text_1": "remove a network listener .",
    "text_2": "public void remove Network Listener ( Network Listener network Listener ) { network Listeners . remove ( network Listener ) ; }",
    "label": 1
  },
  {
    "text_1": "\\ fn mat 4 util inplace rotate \\ brief in place rotate using euler radi ans x , euler radi ans y , euler radi ans z \\ param in out matrix [ mat 4 ] \\ param euler radi ans x [ float ] \\ param euler radi ans y [ float ] \\ param euler radi ans z [ float ]",
    "text_2": "private static void mat NUM util inplace rotate ( float [ ] in Out Matrix , float euler Radians X , float euler Radians Y , float euler Radians Z ) { float cos rx = ( float ) Math . cos ( euler Radians X ) ; float cos ry = ( float ) Math . cos ( euler Radians Y ) ; float cos rz = ( float ) Math . cos ( euler Radians Z ) ; float sin rx = ( float ) Math . sin ( euler Radians X ) ; float sin ry = ( float ) Math . sin ( euler Radians Y ) ; float sin rz = ( float ) Math . sin ( euler Radians Z ) ; float b 00 = cos rz * cos ry ; float b 10 = sin rz * cos ry ; float b 20 = - sin ry ; float b 30 = NUM ; float b 01 = - sin rz * cos rx + cos rz * sin ry * sin rx ; float b 11 = cos rz * cos rx + sin rz * sin ry * sin rx ; float b 21 = cos ry * sin rx ; float b 31 = NUM ; float b 02 = sin rz * sin rx + cos rz * sin ry * cos rx ; float b 12 = - cos rz * sin rx + sin rz * sin ry * cos rx ; float b 22 = cos ry * cos rx ; float b 32 = NUM ; float b 03 = NUM ; float b 13 = NUM ; float b 23 = NUM ; float b 33 = NUM ; float a 00 = in Out Matrix [ NUM ] ; float a 10 = in Out Matrix [ NUM ] ; float a 20 = in Out Matrix [ NUM ] ; float a 30 = in Out Matrix [ NUM ] ; float a 01 = in Out Matrix [ NUM ] ; float a11 = in Out Matrix [ NUM ] ; float a21 = in Out Matrix [ NUM ] ; float a31 = in Out Matrix [ NUM ] ; float a 02 = in Out Matrix [ NUM ] ; float a12 = in Out Matrix [ NUM ] ; float a22 = in Out Matrix [ NUM ] ; float a32 = in Out Matrix [ NUM ] ; float a 03 = in Out Matrix [ NUM ] ; float a13 = in Out Matrix [ NUM ] ; float a23 = in Out Matrix [ NUM ] ; float a33 = in Out Matrix [ NUM ] ; in Out Matrix [ NUM ] = a 00 * b 00 + a 01 * b 10 + a 02 * b 20 + a 03 * b 30 ; in Out Matrix [ NUM ] = a 10 * b 00 + a11 * b 10 + a12 * b 20 + a13 * b 30 ; in Out Matrix [ NUM ] = a 20 * b 00 + a21 * b 10 + a22 * b 20 + a23 * b 30 ; in Out Matrix [ NUM ] = a 30 * b 00 + a31 * b 10 + a32 * b 20 + a33 * b 30 ; in Out Matrix [ NUM ] = a 00 * b 01 + a 01 * b 11 + a 02 * b 21 + a 03 * b 31 ; in Out Matrix [ NUM ] = a 10 * b 01 + a11 * b 11 + a12 * b 21 + a13 * b 31 ; in Out Matrix [ NUM ] = a 20 * b 01 + a21 * b 11 + a22 * b 21 + a23 * b 31 ; in Out Matrix [ NUM ] = a 30 * b 01 + a31 * b 11 + a32 * b 21 + a33 * b 31 ; in Out Matrix [ NUM ] = a 00 * b 02 + a 01 * b 12 + a 02 * b 22 + a 03 * b 32 ; in Out Matrix [ NUM ] = a 10 * b 02 + a11 * b 12 + a12 * b 22 + a13 * b 32 ; in Out Matrix [ NUM ] = a 20 * b 02 + a21 * b 12 + a22 * b 22 + a23 * b 32 ; in Out Matrix [ NUM ] = a 30 * b 02 + a31 * b 12 + a32 * b 22 + a33 * b 32 ; in Out Matrix [ NUM ] = a 00 * b 03 + a 01 * b 13 + a 02 * b 23 + a 03 * b 33 ; in Out Matrix [ NUM ] = a 10 * b 03 + a11 * b 13 + a12 * b 23 + a13 * b 33 ; in Out Matrix [ NUM ] = a 20 * b 03 + a21 * b 13 + a22 * b 23 + a23 * b 33 ; in Out Matrix [ NUM ] = a 30 * b 03 + a31 * b 13 + a32 * b 23 + a33 * b 33 ; }",
    "label": 1
  },
  {
    "text_1": "parses xml from the given input stream and fires events on the given sax handler .",
    "text_2": "private static void parse ( Input Stream in , Encoding encoding , Content Handler content Handler ) throws IO Exception , SAX Exception { try { XML Reader reader = new Exp at Reader ( ) ; reader . set Content Handler ( content Handler ) ; Input Source source = new Input Source ( in ) ; source . set Encoding ( encoding . exp at Name ) ; reader . parse ( source ) ; } catch ( IO Exception e ) { throw new Assertion Error ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "add an end bump er point .",
    "text_2": "public void add End Bumper ( ) { num End B um pers + + ; String name = STRING ; boolean duplicate = BOOL ; while ( duplicate ) { name = STRING + num End B um pers ; if ( finder . find Positionable Point By Name ( name ) = = null ) { duplicate = BOOL ; } if ( duplicate ) { num End B um pers + + ; } } Positionable Point o = new Positionable Point ( name , Positionable Point . END BU MP ER , current Point , this ) ; point List . add ( o ) ; set Dirty ( BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "does a execute function on a server using connections from the given pool to communicate with the server .",
    "text_2": "public static void execute ( Pool Impl pool , Function function , Object args , Member Mapped Argument member Mapped Arg , boolean all Servers , byte has Result , boolean is Fn Serialization Re qd , String [ ] groups ) { List servers = null ; Abstract Op op = new Execute Function No Ack Op Impl ( function , args , member Mapped Arg , has Result , is Fn Serialization Re qd , groups , all Servers ) ; try { if ( all Servers & & groups . length = = NUM ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + op . get Message ( ) + STRING + pool ) ; } servers = pool . get Current Servers ( ) ; Iterator i = servers . iterator ( ) ; while ( i . has Next ( ) ) { pool . execute On ( ( Server Location ) i . next ( ) , op ) ; } } else { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + op . get Message ( ) + STRING + pool + STRING + Arrays . to String ( groups ) + STRING + all Servers ) ; } pool . execute ( op , NUM ) ; } } catch ( Exception ex ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + op . get Message ( ) + STRING + pool , ex ) ; } if ( ex . get Message ( ) ! = null ) throw new Function Exception ( ex . get Message ( ) , ex ) ; else throw new Function Exception ( STRING , ex ) ; } }",
    "label": 1
  },
  {
    "text_1": "reads the expected diagnostics for the given configuration and creates a typ echeck result which contains all of the missing and expected diagnostics",
    "text_2": "public Typ echeck Result interpret Results ( Test Configuration config , Compilation Result compilation Result ) { List < Test Diagnostic > expected Diagnostics = read Diagnostics ( config , compilation Result ) ; return Typ echeck Result . from Compilation Results ( config , compilation Result , expected Diagnostics ) ; }",
    "label": 1
  },
  {
    "text_1": "ensures that our long [ ] can hold at least 64 desired long count bits .",
    "text_2": "private void ensure Capacity ( int desired Long Count ) { if ( desired Long Count < = bits . length ) { return ; } int new Length = Math . max ( desired Long Count , bits . length * NUM ) ; long [ ] new Bits = new long [ new Length ] ; System . arraycopy ( bits , NUM , new Bits , NUM , long Count ) ; this . bits = new Bits ; }",
    "label": 1
  },
  {
    "text_1": "in a case the protocol message received was not equal to the messages in our protocol message list , we have to clear our protocol message list .",
    "text_2": "protected void remove Next Protocol Messages ( List < Protocol Message > protocol Messages , int from Index ) { for ( int i = protocol Messages . size ( ) - NUM ; i > = from Index ; i - - ) { protocol Messages . remove ( i ) ; } }",
    "label": 1
  },
  {
    "text_1": "shutdown our receive thread",
    "text_2": "public boolean unbind ( ) { boolean worked = BOOL ; if ( m rx Thread = = null ) worked = BOOL ; else m stop Rx = BOOL ; return worked ; }",
    "label": 1
  },
  {
    "text_1": "paints the background of a toggle button .",
    "text_2": "public void paint Toggle Button Background ( Synth Context context , Graphics g , int x , int y , int w , int h ) { paint Background ( context , g , x , y , w , h , null ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the value for an \" extra \" parameter . it will handle a single unquoted word ( which is technically illegal , but we ' ll allow it ) , a single quoted string , or an open parenthesis followed by a space - delimited set of quoted strings or unquoted words followed by a close parenthesis .",
    "text_2": "static List < String > read Extensions ( final Substring Reader reader ) throws Decode Exception { int length = NUM ; List < String > values ; reader . skip Whitespaces ( ) ; reader . mark ( ) ; try { char c = reader . read ( ) ; if ( c = = STRING ) { reader . mark ( ) ; while ( reader . read ( ) ! = STRING ) { length + + ; } reader . reset ( ) ; values = Collections . singleton List ( reader . read ( length ) ) ; reader . read ( ) ; } else if ( c = = STRING ) { reader . skip Whitespaces ( ) ; reader . mark ( ) ; c = reader . read ( ) ; if ( c = = STRING ) { values = Collections . empty List ( ) ; } else { values = new Array List < > ( ) ; do { reader . reset ( ) ; values . add ( read Quoted String ( reader ) ) ; reader . skip Whitespaces ( ) ; reader . mark ( ) ; } while ( reader . read ( ) ! = STRING ) ; values = Collections . unmodifiable List ( values ) ; } } else { do { length + + ; } while ( reader . read ( ) ! = STRING ) ; reader . reset ( ) ; values = Collections . singleton List ( reader . read ( length ) ) ; } return values ; } catch ( final String Index Out Of Bounds Exception e ) { throw Decode Exception . error ( ERR ATTR SYNTAX TRUN CATED VALUE NUM . get ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "update an item to the database in a specified container .",
    "text_2": "public static void update Item In Database ( Context context , final Item Info item ) { final Content Values values = new Content Values ( ) ; item . on Add To Database ( context , values ) ; update Item In Database Helper ( context , values , item , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a hash code value for this object .",
    "text_2": "@ Override public int hash Code ( ) { return NUM + Arrays . hash Code ( fields ) ; }",
    "label": 1
  },
  {
    "text_1": "calculates a mid entry where to divide the interval",
    "text_2": "long calculate Mid Entry ( long lo Val , long hi Val , final double dfp , long lo Entry , long hi Entry ) { final double dhi = ( double ) hi Entry ; final double d lo = ( double ) lo Entry ; final double dhi Val = ( double ) hi Val ; final double d lo Val = ( double ) lo Val ; long mid Entry = lo Entry + ( long ) ( ( dhi - d lo ) * ( dfp - d lo Val ) / ( dhi Val - d lo Val ) ) ; if ( mid Entry = = hi Entry ) { mid Entry - - ; } return mid Entry ; }",
    "label": 1
  },
  {
    "text_1": "re - measure the loading views height , and adjust internal padding as necessary",
    "text_2": "protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }",
    "label": 1
  },
  {
    "text_1": "fri e value - convert to standardized name",
    "text_2": "public String Fri e Name ( String value ) { if ( value = = null | | value . length ( ) = = NUM ) return STRING ; String ret Value = value ; String SQL = STRING ; try { Prepared Statement pstmt = DB . prepare Statement ( SQL , null ) ; pstmt . set String ( NUM , value ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) ret Value = rs . get String ( NUM ) ; rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , SQL , e ) ; } return ret Value ; }",
    "label": 1
  },
  {
    "text_1": "decode the base 64 - encoded data in input and return the data in a new byte array . the padding ' = ' characters at the end are considered optional , but if any are present , there must be the correct number of them .",
    "text_2": "public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * NUM / NUM ] ) ; if ( ! decoder . process ( input , offset , len , BOOL ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( decoder . op = = decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM , temp , NUM , decoder . op ) ; return temp ; }",
    "label": 1
  },
  {
    "text_1": "creates an rng and seeds it with the specified seed data .",
    "text_2": "public Mersenne Twister RNG ( final byte [ ] seed ) { if ( seed = = null | | seed . length ! = SEED SIZE BYTES ) { throw new Illegal Argument Exception ( STRING ) ; } this . seed = seed . clone ( ) ; final int [ ] seed Ints = convert Bytes To Ints ( this . seed ) ; mt [ NUM ] = BOOTSTRAP SEED ; for ( mt Index = NUM ; mt Index < N ; mt Index + + ) { mt [ mt Index ] = BOOTSTRAP FACTOR * ( mt [ mt Index - NUM ] ^ mt [ mt Index - NUM ] > > > NUM ) + mt Index ; } int i = NUM ; int j = NUM ; for ( int k = Math . max ( N , seed Ints . length ) ; k > NUM ; k - - ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - NUM ] ^ mt [ i - NUM ] > > > NUM ) * SEED FACTOR NUM ) + seed Ints [ j ] + j ; i + + ; j + + ; if ( i > = N ) { mt [ NUM ] = mt [ N - NUM ] ; i = NUM ; } if ( j > = seed Ints . length ) { j = NUM ; } } for ( int k = N - NUM ; k > NUM ; k - - ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - NUM ] ^ mt [ i - NUM ] > > > NUM ) * SEED FACTOR NUM ) - i ; i + + ; if ( i > = N ) { mt [ NUM ] = mt [ N - NUM ] ; i = NUM ; } } mt [ NUM ] = UPPER MASK ; }",
    "label": 1
  },
  {
    "text_1": "creates the schema column entities .",
    "text_2": "private void create Schema Column Entities ( List < Schema Column > schema Columns , boolean is Partition List , Collection < Schema Column Entity > schema Column Entity List , Map < String , Schema Column Entity > schema Column Entity Map , Business Object Format Entity business Object Format Entity ) { if ( ! Collection Utils . is Empty ( schema Columns ) ) { int position = NUM ; for ( Schema Column schema Column : schema Columns ) { Schema Column Entity schema Column Entity = schema Column Entity Map . get ( schema Column . get Name ( ) ) ; if ( schema Column Entity = = null ) { schema Column Entity = create Schema Column Entity ( schema Column , business Object Format Entity ) ; schema Column Entity List . add ( schema Column Entity ) ; schema Column Entity Map . put ( schema Column . get Name ( ) , schema Column Entity ) ; } if ( is Partition List ) { schema Column Entity . set Partition Level ( position + + ) ; } else { schema Column Entity . set Position ( position + + ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "registers a new zap api challenge .",
    "text_2": "public void register Callback ( String challenge , Challenge Callback Plugin plugin , Http Message attack ) { clean Expired Callbacks ( ) ; reg Callbacks . put ( challenge , new Registered Callback ( plugin , attack ) ) ; }",
    "label": 1
  },
  {
    "text_1": "indicates if this thread is running",
    "text_2": "public boolean is Running ( ) { return m Running . get ( ) ; }",
    "label": 1
  },
  {
    "text_1": "find the next clear bit in the bit set .",
    "text_2": "public int next Clear Bit ( int index ) { int i = index > > NUM ; if ( i > = wlen ) return - NUM ; int sub Index = index & NUM ; long word = ~ bits . get ( i ) > > sub Index ; if ( word ! = NUM ) { return ( i < < NUM ) + sub Index + Long . number Of Trailing Zeros ( word ) ; } while ( + + i < wlen ) { word = ~ bits . get ( i ) ; if ( word ! = NUM ) { return ( i < < NUM ) + Long . number Of Trailing Zeros ( word ) ; } } return - NUM ; }",
    "label": 1
  },
  {
    "text_1": "output the internal buffer .",
    "text_2": "synchronized private void output Buffered Chunk ( ) { if ( small Chunks = = null | | chunk Size = = NUM ) { return ; } if ( small Chunks . size ( ) = = NUM ) { output Chunk ( small Chunks . get ( NUM ) ) ; chunk Size = NUM ; small Chunks = null ; return ; } final I Binding Set [ ] chunk = new I Binding Set [ chunk Size ] ; int dest Pos = NUM ; for ( I Binding Set [ ] e : small Chunks ) { System . arraycopy ( e , NUM , chunk , dest Pos , e . length ) ; dest Pos + = e . length ; } output Chunk ( chunk ) ; chunk Size = NUM ; small Chunks = null ; }",
    "label": 1
  },
  {
    "text_1": "construct a strategy that parses a number field",
    "text_2": "Number Strategy ( final int field ) { this . field = field ; }",
    "label": 1
  },
  {
    "text_1": "returns a string created by each element of the array , separated by delimiter .",
    "text_2": "private static String join Array ( String [ ] array , String delimiter ) { String Buffer buffer = new String Buffer ( ) ; for ( int index = NUM ; index < array . length ; index + + ) { buffer . append ( array [ index ] ) ; if ( index < array . length - NUM ) { buffer . append ( delimiter ) ; } } return buffer . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "commit if required and remove all allocated resources",
    "text_2": "public void close ( ) throws Generic Data Source Exception { if ( manual TX ) { if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; commit ( ) ; } sql = null ; if ( rs ! = null ) { try { rs . close ( ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; } catch ( SQL Exception sqle ) { Debug . log Warning ( sqle . get Message ( ) , module ) ; } rs = null ; } if ( ps ! = null ) { try { ps . close ( ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; } catch ( SQL Exception sqle ) { Debug . log Warning ( sqle . get Message ( ) , module ) ; } ps = null ; } if ( ( connection ! = null ) & & b Delete Connection ) { try { connection . close ( ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; } catch ( SQL Exception sqle ) { Debug . log Warning ( sqle . get Message ( ) , module ) ; } connection = null ; } }",
    "label": 1
  },
  {
    "text_1": "updates the audio track latency and playback position parameters .",
    "text_2": "private void maybe Sample Sync Params ( ) { long playback Position Us = audio Track Util . get Playback Head Position Us ( ) ; if ( playback Position Us = = NUM ) { return ; } long system Clock Us = System . nano Time ( ) / NUM ; if ( system Clock Us - last Play head Sample Time Us > = MIN PLAY HEAD OFFSET SAMPLE INTERVAL US ) { play head Offsets [ next Play head Offset Index ] = playback Position Us - system Clock Us ; next Play head Offset Index = ( next Play head Offset Index + NUM ) % MAX PLAY HEAD OFFSET COUNT ; if ( play head Offset Count < MAX PLAY HEAD OFFSET COUNT ) { play head Offset Count + + ; } last Play head Sample Time Us = system Clock Us ; smoothed Play head Offset Us = NUM ; for ( int i = NUM ; i < play head Offset Count ; i + + ) { smoothed Play head Offset Us + = play head Offsets [ i ] / play head Offset Count ; } } if ( ! is Passthrough ( ) & & system Clock Us - last Timestamp Sample Time Us > = MIN TIMESTAMP SAMPLE INTERVAL US ) { audio Timestamp Set = audio Track Util . update Timestamp ( ) ; if ( audio Timestamp Set ) { long audio Timestamp Us = audio Track Util . get Timestamp Nano Time ( ) / NUM ; long audio Timestamp Frame Position = audio Track Util . get Timestamp Frame Position ( ) ; if ( audio Timestamp Us < resume System Time Us ) { audio Timestamp Set = BOOL ; } else if ( Math . abs ( audio Timestamp Us - system Clock Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Sp urious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } Log . w ( TAG , message ) ; audio Timestamp Set = BOOL ; } else if ( Math . abs ( frames To Duration Us ( audio Timestamp Frame Position ) - playback Position Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Sp urious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } Log . w ( TAG , message ) ; audio Timestamp Set = BOOL ; } } if ( get Latency Method ! = null ) { try { latency Us = ( Integer ) get Latency Method . invoke ( audio Track , ( Object [ ] ) null ) * NUM - frames To Duration Us ( bytes To Frames ( buffer Size ) ) ; latency Us = Math . max ( latency Us , NUM ) ; if ( latency Us > MAX LATENCY US ) { Log . w ( TAG , STRING + latency Us ) ; latency Us = NUM ; } } catch ( Exception e ) { get Latency Method = null ; } } last Timestamp Sample Time Us = system Clock Us ; } }",
    "label": 1
  },
  {
    "text_1": "this method clears the region and notifies the other member when complete",
    "text_2": "private static void invoke Remote Clear And Wait ( VM remote VM , VM this VM ) { remote VM . invoke ( null ) ; try { clear Latch . await ( ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "constructs a nal unit consisting of the nal start code followed by the specified data .",
    "text_2": "public static byte [ ] build Nal Unit ( byte [ ] data , int offset , int length ) { byte [ ] nal Unit = new byte [ length + NAL START CODE . length ] ; System . arraycopy ( NAL START CODE , NUM , nal Unit , NUM , NAL START CODE . length ) ; System . arraycopy ( data , offset , nal Unit , NAL START CODE . length , length ) ; return nal Unit ; }",
    "label": 1
  },
  {
    "text_1": "reserve an object , returning true when successfully reserved or false when the object is already reserved .",
    "text_2": "public boolean reserve ( Object object ) { reserved Ids Lock . lock ( ) ; if ( reserved Objects . contains ( object ) ) { reserved Ids Lock . unlock ( ) ; return BOOL ; } reserved Objects . add ( object ) ; reserved Ids Lock . unlock ( ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "serialize the header fields into a byte array . this method serializes all the header fields including the header nonce and tag .",
    "text_2": "public byte [ ] to Byte Array ( ) { if ( header Nonce = = null | | header Tag = = null ) { throw new Aws Crypto Exception ( STRING ) ; } final byte [ ] serialized Fields = serialize Authenticated Fields ( ) ; final int out Len = serialized Fields . length + header Nonce . length + header Tag . length ; final Byte Buffer serialized Bytes = Byte Buffer . allocate ( out Len ) ; serialized Bytes . put ( serialized Fields ) ; serialized Bytes . put ( header Nonce ) ; serialized Bytes . put ( header Tag ) ; return serialized Bytes . array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "decodes base 64 data into oct ects",
    "text_2": "public static byte [ ] decode ( String encoded ) { if ( encoded = = null ) { return null ; } char [ ] base NUM Data = encoded . to Char Array ( ) ; int len = remove White Space ( base NUM Data ) ; if ( len % FOUR BYTE ! = NUM ) { return null ; } int number Quadruple = ( len / FOUR BYTE ) ; if ( number Quadruple = = NUM ) { return new byte [ NUM ] ; } byte decoded Data [ ] = null ; byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; char d1 = NUM , d2 = NUM , d3 = NUM , d4 = NUM ; int i = NUM ; int encoded Index = NUM ; int data Index = NUM ; decoded Data = new byte [ ( number Quadruple ) * NUM ] ; for ( ; i < number Quadruple - NUM ; i + + ) { if ( ! is Data ( ( d1 = base NUM Data [ data Index + + ] ) ) | | ! is Data ( ( d2 = base NUM Data [ data Index + + ] ) ) | | ! is Data ( ( d3 = base NUM Data [ data Index + + ] ) ) | | ! is Data ( ( d4 = base NUM Data [ data Index + + ] ) ) ) { return null ; } b1 = base NUM Alphabet [ d1 ] ; b2 = base NUM Alphabet [ d2 ] ; b3 = base NUM Alphabet [ d3 ] ; b4 = base NUM Alphabet [ d4 ] ; decoded Data [ encoded Index + + ] = ( byte ) ( b1 < < NUM | b2 > > NUM ) ; decoded Data [ encoded Index + + ] = ( byte ) ( ( ( b2 & NUM ) < < NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index + + ] = ( byte ) ( b3 < < NUM | b4 ) ; } if ( ! is Data ( ( d1 = base NUM Data [ data Index + + ] ) ) | | ! is Data ( ( d2 = base NUM Data [ data Index + + ] ) ) ) { return null ; } b1 = base NUM Alphabet [ d1 ] ; b2 = base NUM Alphabet [ d2 ] ; d3 = base NUM Data [ data Index + + ] ; d4 = base NUM Data [ data Index + + ] ; if ( ! is Data ( ( d3 ) ) | | ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) & & is Pad ( d4 ) ) { if ( ( b2 & NUM ) ! = NUM ) { return null ; } byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 < < NUM | b2 > > NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) & & is Pad ( d4 ) ) { b3 = base NUM Alphabet [ d3 ] ; if ( ( b3 & NUM ) ! = NUM ) { return null ; } byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index + + ] = ( byte ) ( b1 < < NUM | b2 > > NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & NUM ) < < NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base NUM Alphabet [ d3 ] ; b4 = base NUM Alphabet [ d4 ] ; decoded Data [ encoded Index + + ] = ( byte ) ( b1 < < NUM | b2 > > NUM ) ; decoded Data [ encoded Index + + ] = ( byte ) ( ( ( b2 & NUM ) < < NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index + + ] = ( byte ) ( b3 < < NUM | b4 ) ; } return decoded Data ; }",
    "label": 1
  },
  {
    "text_1": "override this if any action needs to be done at the end of the conversion .",
    "text_2": "protected abstract void finalize Output ( final int [ ] source Image Pixels , final int image Width , final int image Height ) ;",
    "label": 1
  },
  {
    "text_1": "verify if logging is enabled at that particular level .",
    "text_2": "public boolean is Loggable ( Level lev ) { return logger . is Loggable ( lev ) ; }",
    "label": 1
  },
  {
    "text_1": "helper called by generated code to construct default values for string fields . the protocol compiler does not actually contain a utf - 8 decoder - - it just pushes utf - 8 - encoded text around without touching it . the one place where this presents a problem is when generating java string literals . unicode characters in the string literal would normally need to be encoded using a unicode escape sequence , which would require decoding them . to get around this , proto c instead embeds the utf - 8 bytes into the generated code and leaves it to the runtime library to decode them . it gets worse , though . if proto c just generated a byte array , like : new byte [ ] 0x 12 , 0x 34 , 0x 56 , 0x 78 java actually generates code which allocates an array and then fills in each value . this is much less efficient than just embedding the bytes directly into the bytecode . to get around this , we need another work - around . string literals are embedded directly , so proto c actually generates a string literal corresponding to the bytes . the easiest way to do this is to use the iso - 8859 - 1 character set , which corresponds to the first 256 characters of the unicode range . proto c can then use good old ce scape to generate the string . so we have a string literal which represents a set of bytes which represents another string . this function - - string defaultvalue - - converts from the generated string to the string we actually want . the generated code calls this automatically .",
    "text_2": "public static String string Default Value ( String bytes ) { try { return new String ( bytes . get Bytes ( STRING ) , STRING ) ; } catch ( Unsupported Encoding Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "check if the image size is to big to be stored in the cache .",
    "text_2": "public boolean is Image Cachable ( int w , int h ) { return ( w * h ) < max Single Image Pixel Size ; }",
    "label": 1
  },
  {
    "text_1": "track the specified file , using the provided marker , deleting the file when the marker instance is garbage collected . the spe ified deletion strategy is used .",
    "text_2": "public void track ( File file , Object marker , File Delete Strategy delete Strategy ) { if ( file = = null ) { throw new Null Pointer Exception ( STRING ) ; } add Tracker ( file . get Path ( ) , marker , delete Strategy ) ; }",
    "label": 1
  },
  {
    "text_1": "sleep for a span of time , or mock sleep if enabled",
    "text_2": "public static void sleep ( long millis ) { if ( mock Sleep Queue = = null ) { sleep Uninterruptibly ( millis , Time Unit . MILLISECONDS ) ; } else { try { boolean is Multi Pass = mock Sleep Queue . take ( ) ; roll Mock Clock Millis ( millis ) ; if ( is Multi Pass ) mock Sleep Queue . offer ( BOOL ) ; } catch ( Interrupted Exception e ) { } } }",
    "label": 1
  },
  {
    "text_1": "adds the fields to load and return as part of the search request . if none are specified , the source of the document will be returned .",
    "text_2": "public Search Source Builder fields ( String . . . fields ) { if ( field Names = = null ) { field Names = new Array List < > ( ) ; } Collections . add All ( field Names , fields ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "convert a feature vector into a string representation .",
    "text_2": "public String to Feature String ( Feature Vector fv ) { if ( num Byte Features ! = fv . get Number Of Byte Features ( ) | | num Short Features ! = fv . get Number Of Short Features ( ) | | num Continuous Features ! = fv . get Number Of Continuous Features ( ) ) throw new Illegal Argument Exception ( STRING + fv + STRING ) ; String Builder buf = new String Builder ( ) ; for ( int i = NUM ; i < num Byte Features ; i + + ) { if ( buf . length ( ) > NUM ) buf . append ( STRING ) ; buf . append ( get Feature Value As String ( i , fv . get Byte Feature ( i ) ) ) ; } for ( int i = num Byte Features ; i < num Byte Features + num Short Features ; i + + ) { if ( buf . length ( ) > NUM ) buf . append ( STRING ) ; buf . append ( get Feature Value As String ( i , fv . get Short Feature ( i ) ) ) ; } for ( int i = num Byte Features + num Short Features ; i < num Byte Features + num Short Features + num Continuous Features ; i + + ) { if ( buf . length ( ) > NUM ) buf . append ( STRING ) ; buf . append ( fv . get Continuous Feature ( i ) ) ; } return buf . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs a new sv gra ster izer converter .",
    "text_2": "public SVG Raster izer ( Input Stream istream ) { this . input = new Transcoder Input ( istream ) ; }",
    "label": 1
  },
  {
    "text_1": "reduces the current indent level by two spaces , or crashes if the indent level is zero .",
    "text_2": "public void outdent ( ) { final int length = indent . length ( ) ; if ( length = = NUM ) { throw new Illegal Argument Exception ( STRING ) ; } indent . delete ( length - NUM , length ) ; }",
    "label": 1
  },
  {
    "text_1": "flatten a long [ ] into an xmlserializer . the list can later be read back with read this long array xml ( ) .",
    "text_2": "public static final void write Long Array Xml ( long [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val = = null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name ! = null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i + + ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Long . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "check if we ' ve crossed a reasonable touch slop for the given child view . if the child cannot be dragged along the horizontal or vertical axis , motion along that axis will not count toward the slop check .",
    "text_2": "private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child = = null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal & & check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "runs a normal upload scenario .",
    "text_2": "protected void run Upload ( Integer num Of Threads , Hash Map < String , String > attributes , Boolean create New Version , Boolean force ) throws Exception { run Upload ( num Of Threads , attributes , create New Version , force , null , null ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the size of an instance of this class ( in bytes ) . instances include a header + all fields + padded to 8 bytes . if this is an array , it does not include the size of the elements .",
    "text_2": "public static long size Of ( Class clazz ) { long max Size = header Size ( clazz ) ; while ( clazz ! = Object . class ) { for ( Field f : clazz . get Declared Fields ( ) ) { if ( ( f . get Modifiers ( ) & Modifier . STATIC ) = = NUM ) { long offset = unsafe . object Field Offset ( f ) ; if ( offset > max Size ) { max Size = offset + NUM ; } } } clazz = clazz . get Superclass ( ) ; } return round Up To NUM ( max Size ) ; }",
    "label": 1
  },
  {
    "text_1": "calculate the clustering of the hits",
    "text_2": "protected int cal cn Cluster ( ) { return NUM ; }",
    "label": 1
  },
  {
    "text_1": "all other write methods delegate their work to here .",
    "text_2": "public void write ( Output Stream out , java . util . List < Figure > figures ) throws IO Exception { Rectangle NUM D . Double drawing Rect = null ; for ( Figure f : figures ) { if ( drawing Rect = = null ) { drawing Rect = f . get Bounds ( ) ; } else { drawing Rect . add ( f . get Bounds ( ) ) ; } } Affine Transform tx = new Affine Transform ( ) ; tx . translate ( - Math . min ( NUM , drawing Rect . x ) , - Math . min ( NUM , drawing Rect . y ) ) ; write ( out , figures , tx , new Dimension ( ( int ) ( Math . abs ( drawing Rect . x ) + drawing Rect . width ) , ( int ) ( Math . abs ( drawing Rect . y ) + drawing Rect . height ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if a xml character is well - formed . if there is a problem with the character a non - null character is returned else null is returned .",
    "text_2": "protected Character is W FXML Char ( String char data ) { Character ref Invalid Char ; if ( char data = = null | | ( char data . length ( ) = = NUM ) ) { return null ; } char [ ] dataarray = char data . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XML Version NUM ) { int i = NUM ; while ( i < datalength ) { if ( XML NUM Char . is XML NUM Invalid ( dataarray [ i + + ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) & & i < datalength ) { char ch NUM = dataarray [ i + + ] ; if ( XML Char . is Low Surrogate ( ch NUM ) & & XML Char . is Supplemental ( XML Char . supplemental ( ch , ch NUM ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return ref Invalid Char ; } } } else { int i = NUM ; while ( i < datalength ) { if ( XML Char . is Invalid ( dataarray [ i + + ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) & & i < datalength ) { char ch NUM = dataarray [ i + + ] ; if ( XML Char . is Low Surrogate ( ch NUM ) & & XML Char . is Supplemental ( XML Char . supplemental ( ch , ch NUM ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return ref Invalid Char ; } } } return null ; }",
    "label": 1
  },
  {
    "text_1": "animates the stack scroll into bounds",
    "text_2": "Object Animator animate Bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) ! = NUM ) { animate Scroll ( cur Scroll , new Scroll , null ) ; } return m Scroll Animator ; }",
    "label": 1
  },
  {
    "text_1": "checks whether a string is whitespace , empty or null .",
    "text_2": "public static boolean is Blank ( String s ) { if ( s = = null ) { return BOOL ; } int s Len = s . length ( ) ; for ( int i = NUM ; i < s Len ; i + + ) { if ( ! Character . is Whitespace ( s . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "checks whether mandatory log dir is given",
    "text_2": "static void check Log Dir ( ) { if ( System . get Property ( STRING ) = = null ) { log . error ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "write a string , compressed , if long enough",
    "text_2": "@ Override public void write String ( byte [ ] str , int offset , int length ) throws IO Exception { if ( str = = null ) write Int ( NUM ) ; else { if ( use Compression & & length > = Compressor . MIN SIZE FOR DEFL ATION ) { if ( byte Buffer . length < length ) byte Buffer = new byte [ NUM * length ] ; int number Of Bytes = compressor . deflate String NUM Byte Array ( str , offset , length , byte Buffer ) ; write Int ( number Of Bytes ) ; io . write ( byte Buffer , NUM , Math . abs ( number Of Bytes ) ) ; } else { write Int ( length ) ; io . write ( str , offset , length ) ; } } }",
    "label": 1
  },
  {
    "text_1": "creates a new instance of pids",
    "text_2": "@ Suppress Warnings ( STRING ) public Pids ( ) { Arrays . sort ( PI Ds , pid Comparator ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a reverse line reader with the given block size and encoding .",
    "text_2": "public Grid Reversed Lines File Reader ( final File file , final int block Size , final String encoding ) throws IO Exception { this ( file , block Size , Charset . for Name ( encoding ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the longitude for an y tile",
    "text_2": "public static double tile NUM lat ( int y , int z ) { double n = Math . PI - ( NUM * Math . PI * y ) / Math . pow ( NUM , z ) ; return Math . to Degrees ( Math . atan ( Math . sinh ( n ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "return the index of the next grid to restart .",
    "text_2": "protected int next Grid To Restart ( ) { if ( curr Restart Grid Id = = server Count ( ) ) curr Restart Grid Id = NUM ; return + + curr Restart Grid Id ; }",
    "label": 1
  },
  {
    "text_1": "complex condition 0 for ' l '",
    "text_2": "private boolean condition L NUM ( String value , int index ) { if ( index = = value . length ( ) - NUM & & contains ( value , index - NUM , NUM , STRING , STRING , STRING ) ) { return BOOL ; } else if ( ( contains ( value , index - NUM , NUM , STRING , STRING ) | | contains ( value , value . length ( ) - NUM , NUM , STRING , STRING ) ) & & contains ( value , index - NUM , NUM , STRING ) ) { return BOOL ; } else { return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "replaces the placeholders with concrete values",
    "text_2": "private String replace Placeholders ( String query , Map < String , String > replacements ) { String result Query = query ; for ( Map . Entry < String , String > entry : replacements . entry Set ( ) ) { result Query = result Query . replace ( entry . get Key ( ) , entry . get Value ( ) ) ; } return result Query ; }",
    "label": 1
  },
  {
    "text_1": "method to serialize a path . this method will iterate through the iterator passed in , and write out the base components of the path to the objectoutput",
    "text_2": "public static void serialize Path ( final Object Output os , final Path Iterator pi ) throws IO Exception { os . write Object ( pi . get Winding Rule ( ) ) ; final List < java . io . Serializable > list = new Array List < java . io . Serializable > ( ) ; while ( ! pi . is Done ( ) ) { final float [ ] array = new float [ NUM ] ; final int type = pi . current Segment ( array ) ; list . add ( type ) ; list . add ( array ) ; pi . next ( ) ; } os . write Object ( list ) ; }",
    "label": 1
  },
  {
    "text_1": "calculate the probabilities and scores for each message ' s data after going through all the analyzed intervals . message probability is calculated by dividing the total number of times the message appeared by the total number of analyzed intervals gone through . the message score is calculated by taking the negative log of the message probability . out of cluster probability and out of context score are also calculated .",
    "text_2": "@ Override public void end Of Stream ( ) throws Ade Exception { double min Prob = NUM ; if ( m total Interval Count = = NUM ) { m total Interval Count = NUM ; } for ( Entry < String , Bernoulli Score . Msg Data > entry : m msg Data . entry Set ( ) ) { final Full Bernoulli Msg Data data = ( Full Bernoulli Msg Data ) entry . get Value ( ) ; data . m prob = ( ( double ) data . m count + NUM ) / ( m total Interval Count + NUM ) ; if ( data . m prob < NUM | | data . m prob > = NUM ) { logger . info ( entry . get Key ( ) + STRING + data . m prob + STRING + data . m count + STRING + m total Interval Count + STRING ) ; } if ( data . m prob < min Prob ) { min Prob = data . m prob ; } data . m out Of Cluster Prob = ( ( double ) data . m out Of Cluster Count + NUM ) / ( m total Interval Count + NUM ) ; if ( data . m out Of Cluster Count < min Prob & & data . m out Of Cluster Count > NUM ) { min Prob = data . m out Of Cluster Count ; } } for ( Bernoulli Score . Msg Data data Super : m msg Data . values ( ) ) { final Full Bernoulli Msg Data data = ( Full Bernoulli Msg Data ) data Super ; final double probability = data . m prob ; data . m score = - Math . log ( probability ) ; if ( data . m score > NUM ) { data . m score = NUM ; } final double out Of Context Probability = data . m out Of Cluster Prob ; data . m out Of Context Score = - Math . log ( out Of Context Probability ) ; if ( data . m out Of Context Score > NUM ) { data . m out Of Context Score = NUM ; } } m trained = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "adjusts the axis range to match the data range that the axis is required to display .",
    "text_2": "@ Override protected void auto Adjust Range ( ) { Plot plot = get Plot ( ) ; if ( plot = = null ) { return ; } if ( plot instanceof Value Axis Plot ) { Value Axis Plot v ap = ( Value Axis Plot ) plot ; Range r = v ap . get Data Range ( this ) ; if ( r = = null ) { r = get Default Auto Range ( ) ; } double upper = r . get Upper Bound ( ) ; double lower = Math . max ( r . get Lower Bound ( ) , this . smallest Value ) ; double range = upper - lower ; double fixed Auto Range = get Fixed Auto Range ( ) ; if ( fixed Auto Range > NUM ) { lower = Math . max ( upper - fixed Auto Range , this . smallest Value ) ; } else { double min Range = get Auto Range Minimum Size ( ) ; if ( range < min Range ) { double expand = ( min Range - range ) / NUM ; upper = upper + expand ; lower = lower - expand ; } double log Upper = calculate Log ( upper ) ; double log Lower = calculate Log ( lower ) ; double log Range = log Upper - log Lower ; log Upper = log Upper + get Upper Margin ( ) * log Range ; log Lower = log Lower - get Lower Margin ( ) * log Range ; upper = calculate Value No INF ( log Upper ) ; lower = calculate Value No INF ( log Lower ) ; } set Range ( new Range ( lower , upper ) , BOOL , BOOL ) ; } }",
    "label": 1
  },
  {
    "text_1": "calls the parent method to update the progress - bar in the ui while articles are refreshed .",
    "text_2": "@ Override protected void on Progress Update ( Integer . . . values ) { if ( parent ! = null ) { if ( values [ NUM ] = = ON CACHE END ) { parent . on Cache End ( ) ; } else if ( values [ NUM ] = = ON CACHE INTERRUPTED ) { Log . i ( TAG , STRING ) ; should Be Stopped = BOOL ; parent . on Cache Interrupted ( ) ; } else { parent . on Cache Progress ( task Count , values [ NUM ] ) ; } } }",
    "label": 1
  },
  {
    "text_1": "check the size of the array and increase if needed",
    "text_2": "private void check Size ( final int i ) { if ( i > = max size ) { final int old size = max size ; max size + = increment size ; if ( max size < = i ) { max size = i + increment size + NUM ; } final Rectangle [ ] temp = items ; items = new Rectangle [ max size ] ; System . arraycopy ( temp , NUM , items , NUM , old size ) ; increment size = increment Size ( increment size ) ; } }",
    "label": 1
  },
  {
    "text_1": "divide : local variable exponent is less than zero",
    "text_2": "public void test Divide Exp Less Zero ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND CEILING ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "rescales the interpolated value to make it smoother .",
    "text_2": "private double d amp ( double value ) { return Math . sqrt ( value ) ; }",
    "label": 1
  },
  {
    "text_1": "encodes the this websocket frame into a byte array .",
    "text_2": "public byte [ ] encode Frame ( ) { int length = this . payload . length + frame Length Overhead ; if ( this . payload . length > NUM ) { length + = NUM ; } else if ( this . payload . length > = NUM ) { length + = NUM ; } Byte Buffer buffer = Byte Buffer . allocate ( length ) ; append Fin And Op Code ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generate Masking Key ( ) ; append Length And Mask ( buffer , this . payload . length , mask ) ; for ( int i = NUM ; i < this . payload . length ; i + + ) { buffer . put ( ( byte ) ( this . payload [ i ] ^ = mask [ i % NUM ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "convenience method for testing the validity of an image .",
    "text_2": "public static boolean valid Image ( Image image ) { return ( image ! = null & & image . get Width ( null ) > NUM & & image . get Height ( null ) > NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "divide one by one .",
    "text_2": "public void test Case NUM ( ) { byte r Bytes [ ] = { NUM } ; Big Integer a Number = Big Integer . ONE ; Big Integer b Number = Big Integer . ONE ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "head to the direction of the given point .",
    "text_2": "public final void head To ( Tuple NUM d p ) { double angle = Geometric . angle ( this . location , p ) ; turn To ( Math . to Degrees ( angle ) ) ; }",
    "label": 1
  },
  {
    "text_1": "fill the \" conditional holes \" of the distribution - - that is , the possible conditional assignments y1 , . . . , yn that are not associated with any distribution p ( x1 , . . . , xn | y1 , . . . , yn ) in the table . the method create a default assignment x1 = none , . . . xn = none with probability 1 . 0 for these cases .",
    "text_2": "public void fill Conditional Holes ( ) { Value Range possible Cond Pairs = new Value Range ( table . key Set ( ) ) ; if ( possible Cond Pairs . get Nb Combinations ( ) < NUM ) { Set < Assignment > possible Cond Assignments = possible Cond Pairs . linear ise ( ) ; possible Cond Assignments . remove ( new Assignment ( ) ) ; for ( Assignment possible Cond : possible Cond Assignments ) { if ( ! table . contains Key ( possible Cond ) ) { add Row ( possible Cond , Value Factory . none ( ) , NUM ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "adds the process which enables process dependent functions .",
    "text_2": "public Expression Parser Builder with Process ( Process process ) { this . process = process ; return this ; }",
    "label": 1
  },
  {
    "text_1": "split datab us event keys into event store event ids .",
    "text_2": "static List < String > decode All ( Collection < String > event Keys ) { List < String > event Ids = Lists . new Array List ( ) ; for ( String event Key : event Keys ) { decode To ( event Key , event Ids ) ; } return event Ids ; }",
    "label": 1
  },
  {
    "text_1": "returns a list with the file lines .",
    "text_2": "private static List < String > read File ( File file ) throws IO Exception { File Reader fr = new File Reader ( file ) ; Buffered Reader br = new Buffered Reader ( fr ) ; List < String > lines = new Array List < String > ( ) ; String line ; while ( ( line = br . read Line ( ) ) ! = null ) lines . add ( line ) ; fr . close ( ) ; br . close ( ) ; return lines ; }",
    "label": 1
  },
  {
    "text_1": "sorts an array of comparable objects , returning a new array with the sorted items . the original array is left untouched .",
    "text_2": "public static Comparable [ ] sort Copy ( Comparable [ ] objects ) { int len = objects . length ; Comparable [ ] copy = new Comparable [ len ] ; System . arraycopy ( objects , NUM , copy , NUM , len ) ; sort ( copy ) ; return copy ; }",
    "label": 1
  },
  {
    "text_1": "util method to write an attribute without the ns prefix",
    "text_2": "private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }",
    "label": 1
  },
  {
    "text_1": "easy way to create a string from a bunch of lines .",
    "text_2": "public static String build String From Lines ( String . . . lines ) { int num Chars = lines . length ; for ( String line : lines ) { num Chars + = line . length ( ) ; } String Builder builder = new String Builder ( num Chars ) ; for ( String line : lines ) { builder . append ( line ) ; builder . append ( STRING ) ; } return builder . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a string representation of this object .",
    "text_2": "public String to String ( ) { String Buffer sb = new String Buffer ( STRING ) ; for ( int i = NUM ; i < permissions . length ; i + + ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs a problem provider for rotated problems .",
    "text_2": "public Rotated Problems ( ) { super ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the number of elements in this set ( its cardinality ) .",
    "text_2": "public int size ( ) { return list . size ( ) ; }",
    "label": 1
  },
  {
    "text_1": "clamp the magnitude of value for absmin and absmax . if the value is below the minimum , it will be clamped to zero . if the value is above the maximum , it will be clamped to the maximum .",
    "text_2": "private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }",
    "label": 1
  },
  {
    "text_1": "handles parameters coming in prefixed with \" search feat \" where the parameter value is a product feature id ; meant to be used with text entry boxes or check - boxes and such",
    "text_2": "public static List < String > make Feature Id List From Prefixed ( Map < String , Object > parameters ) { List < String > feature Id List = Fast List . new Instance ( ) ; if ( parameters = = null ) return feature Id List ; for ( Map . Entry < String , Object > entry : parameters . entry Set ( ) ) { String parameter Name = entry . get Key ( ) ; if ( parameter Name . starts With ( STRING ) ) { String product Feature Id = ( String ) entry . get Value ( ) ; if ( Util Validate . is Not Empty ( product Feature Id ) ) { feature Id List . add ( product Feature Id ) ; } } } return feature Id List ; }",
    "label": 1
  },
  {
    "text_1": "formats a date - time object using this formatter . this formats the date - time to a string using the rules of the formatter .",
    "text_2": "public String format ( Temporal Accessor temporal ) { String Builder buf = new String Builder ( NUM ) ; format To ( temporal , buf ) ; return buf . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "compiles the compilation unit from sources .",
    "text_2": "public void compile ( int through Phase ) throws Compilation Failed Exception { goto Phase ( Phases . INITIALIZATION ) ; through Phase = Math . min ( through Phase , Phases . ALL ) ; while ( through Phase > = phase & & phase < = Phases . ALL ) { if ( phase = = Phases . SEMANTIC ANALYSIS ) { do Phase Operation ( resolve ) ; if ( de queued ( ) ) continue ; } process Phase Operations ( phase ) ; process New Phase Operations ( phase ) ; if ( progress Callback ! = null ) progress Callback . call ( this , phase ) ; complete Phase ( ) ; apply To Source Units ( mark ) ; if ( de queued ( ) ) continue ; goto Phase ( phase + NUM ) ; if ( phase = = Phases . CLASS GENERATION ) { sort Classes ( ) ; } } error Collector . fail If Errors ( ) ; }",
    "label": 1
  },
  {
    "text_1": "calculates the value of delta that represents the maximum ripple for the current set of extre mal indices ( l + 2 ) implements op pen he im / sch af er discrete time signal processing , 3e , 2016 , equation 114",
    "text_2": "private void calculate Delta ( double [ ] b ) { double numerator = NUM ; double denominator = NUM ; double sign = NUM ; for ( int k = NUM ; k < b . length ; k + + ) { if ( k < m Extre mal Indices . size ( ) ) { int extre mal Index = m Extre mal Indices . get ( k ) ; numerator + = ( b [ k ] * m Grid . get Desired Response ( ) [ extre mal Index ] ) ; denominator + = b [ k ] * sign / m Grid . get Weight ( ) [ extre mal Index ] ; sign = - sign ; } else { m Log . error ( STRING ) ; } } m Delta = numerator / denominator ; }",
    "label": 1
  },
  {
    "text_1": "get the number of replies for a given comment .",
    "text_2": "public int number Of Replies ( final Resource comment ) { final Iterator < Resource > children = comment . list Children ( ) ; int size = NUM ; while ( children . has Next ( ) ) { children . next ( ) ; size + + ; } return size ; }",
    "label": 1
  },
  {
    "text_1": "verifies that all grid rows are of the same length .",
    "text_2": "private void verify Grid State ( ) { Integer row Length = null ; int row Pos = NUM ; for ( List < Object > row : grid ) { if ( row Length ! = null & & row Length ! = row . size ( ) ) { throw new Illegal State Exception ( STRING + row Length + STRING + row . size ( ) + STRING + row Pos ) ; } row Pos + + ; row Length = row . size ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a point which encodes with point compression .",
    "text_2": "public Fp ( EC Curve curve , EC Field Element x , EC Field Element y ) { this ( curve , x , y , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "creates an ssl test config that does not use ssl or client authentication",
    "text_2": "public SSL Test Config ( ) { this ( BOOL , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "determines whether the specified field name is a property field name .",
    "text_2": "public static boolean is Property Field ( String field Name ) { return ! ID FIELD NAME . equals ( field Name ) & & ! URI FIELD NAME . equals ( field Name ) & & ! TEXT FIELD NAME . equals ( field Name ) & & ! CONTEXT FIELD NAME . equals ( field Name ) & & field Name . char At ( NUM ) ! = STRING ; }",
    "label": 1
  },
  {
    "text_1": "called by the root element to leave dtd mode and if any dtd parts were printer , will return a string with their textual content .",
    "text_2": "@ Override public String leave DTD ( ) { if ( writer = = dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "inserts the specified object at the specified index in the array .",
    "text_2": "public void insert ( T object , int index ) { synchronized ( m Lock ) { m Objects . add ( index , object ) ; } if ( m Notify On Change ) notify Item Inserted ( index ) ; }",
    "label": 1
  },
  {
    "text_1": "resets the components to their preferred sizes .",
    "text_2": "void reset To Preferred Sizes ( int available Size ) { int [ ] test Sizes = get Preferred Sizes ( ) ; int total Size = NUM ; for ( int counter = NUM ; counter < NUM ; counter + + ) { if ( test Sizes [ counter ] ! = - NUM ) { total Size + = test Sizes [ counter ] ; } } if ( total Size > available Size ) { test Sizes = get Minimum Sizes ( ) ; total Size = NUM ; for ( int counter = NUM ; counter < NUM ; counter + + ) { if ( test Sizes [ counter ] ! = - NUM ) { total Size + = test Sizes [ counter ] ; } } } set Sizes ( test Sizes ) ; distribute Space ( available Size - total Size , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "add two equal numbers of different signs",
    "text_2": "public void test Case NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM } ; int a Sign = - NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "if this component has no value formatter or is only equipped with the default one ( no custom set ) , return true .",
    "text_2": "public static boolean needs Default Formatter ( Value Formatter formatter ) { if ( formatter = = null ) return BOOL ; if ( formatter instanceof Default Value Formatter ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "discard upstream media chunks until the queue length is equal to the length specified .",
    "text_2": "private boolean discard Upstream Media Chunks ( int queue Length ) { if ( media Chunks . size ( ) < = queue Length ) { return BOOL ; } long start Time Us = NUM ; long end Time Us = media Chunks . get Last ( ) . end Time Us ; Base Media Chunk removed = null ; while ( media Chunks . size ( ) > queue Length ) { removed = media Chunks . remove Last ( ) ; start Time Us = removed . start Time Us ; } sample Queue . discard Upstream Samples ( removed . get First Sample Index ( ) ) ; notify Upstream Discarded ( start Time Us , end Time Us ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "performs the given action for each remaining element until all elements have been processed or the action throws an exception . actions are performed in the order of iteration , if that order is specified . exceptions thrown by the action are relayed to the caller .",
    "text_2": "default void for Each Remaining ( Int Consumer action ) { Objects . require Non Null ( action ) ; while ( has Next ( ) ) action . accept ( next Int ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "adds an entry to the log of this plug - in for the given status",
    "text_2": "private void log ( I Status status ) { Resources Plugin . log ( status ) ; }",
    "label": 1
  },
  {
    "text_1": "updates the recording track time . also updates the star tid and the stop id . increase the number of points if it is a new and valid track point .",
    "text_2": "private void update Recording Track ( Track track , long last Track Point Id , boolean increase Number Of Points ) { if ( last Track Point Id > = NUM ) { if ( track . get Start Id ( ) < NUM ) { track . set Start Id ( last Track Point Id ) ; } track . set Stop Id ( last Track Point Id ) ; } if ( increase Number Of Points ) { track . set Number Of Points ( track . get Number Of Points ( ) + NUM ) ; } track Trip Statistics Updater . update Time ( System . current Time Millis ( ) ) ; track . set Trip Statistics ( track Trip Statistics Updater . get Trip Statistics ( ) ) ; my Tracks Provider Utils . update Track ( track ) ; }",
    "label": 1
  },
  {
    "text_1": "return a path for a check mark .",
    "text_2": "public Shape create Check Mark ( final int x , final int y , final int w , final int h ) { double xf = w / NUM ; double hf = h / NUM ; path . reset ( ) ; path . move To ( x , y + NUM * hf ) ; path . line To ( x + NUM * xf , y + NUM * hf ) ; path . line To ( x + NUM * xf , y + NUM * hf ) ; path . line To ( x + NUM * xf , y ) ; path . line To ( x + NUM * xf , y ) ; path . line To ( x + NUM * xf , y + NUM * hf ) ; path . close Path ( ) ; return path ; }",
    "label": 1
  },
  {
    "text_1": "add a particular script engine for the executor to instantiate .",
    "text_2": "public Builder add Engine Settings ( final String engine Name , final List < String > imports , final List < String > static Imports , final List < String > scripts , final Map < String , Object > config ) { if ( null = = imports ) throw new Illegal Argument Exception ( STRING ) ; if ( null = = static Imports ) throw new Illegal Argument Exception ( STRING ) ; if ( null = = scripts ) throw new Illegal Argument Exception ( STRING ) ; final Map < String , Object > m = null = = config ? Collections . empty Map ( ) : config ; settings . put ( engine Name , new Engine Settings ( imports , static Imports , scripts , m ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "return an enumeration of the extension field ' s object ids .",
    "text_2": "public Enumeration oids ( ) { return ordering . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a valid list of jdbc query statements . it contains only 1 statement , and the statement is case 1 sql in mock jdbc ( success , result 1 )",
    "text_2": "private List < Jdbc Statement > create Default Query Jdbc Statements ( ) { List < Jdbc Statement > jdbc Statements = new Array List < > ( ) ; { Jdbc Statement jdbc Statement = new Jdbc Statement ( ) ; jdbc Statement . set Type ( Jdbc Statement Type . QUERY ) ; jdbc Statement . set Sql ( Mock Jdbc Operations . CASE NUM SQL ) ; jdbc Statements . add ( jdbc Statement ) ; } return jdbc Statements ; }",
    "label": 1
  },
  {
    "text_1": "remove all illegal moves from move list . \" move list \" is assumed to be a list of pseudo - legal moves . this function removes the moves that don ' t def end from check thre ats .",
    "text_2": "public static final Array List < Move > remove Illegal ( Position pos , Array List < Move > move List ) { Array List < Move > ret = new Array List < Move > ( ) ; Undo Info ui = new Undo Info ( ) ; int ml Size = move List . size ( ) ; for ( int mi = NUM ; mi < ml Size ; mi + + ) { Move m = move List . get ( mi ) ; pos . make Move ( m , ui ) ; pos . set White Move ( ! pos . white Move ) ; if ( ! in Check ( pos ) ) ret . add ( m ) ; pos . set White Move ( ! pos . white Move ) ; pos . un Make Move ( m , ui ) ; } return ret ; }",
    "label": 1
  },
  {
    "text_1": "called whenever a use wh ats to search poke mons on a different position",
    "text_2": "@ Subscribe public void on Event ( Search In Position event ) { List < Lat Lng > list = Map Helper . get Search Area ( event . get Steps ( ) , new Lat Lng ( event . get Position ( ) . latitude , event . get Position ( ) . longitude ) ) ; sn ack Me ( get String ( R . string . toast searching ) ) ; ni antic Manager . get G yms ( event . get Position ( ) . latitude , event . get Position ( ) . longitude , NUM ) ; ni antic Manager . get Poke Stops ( event . get Position ( ) . latitude , event . get Position ( ) . longitude , NUM ) ; ni antic Manager . get Lu red Pokemon ( event . get Position ( ) . latitude , event . get Position ( ) . longitude , NUM ) ; for ( Lat Lng p : list ) { ni antic Manager . get Cat chable Pokemon ( p . latitude , p . longitude , NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "test if the production run exist .",
    "text_2": "public boolean exist ( ) { return production Run ! = null ; }",
    "label": 1
  },
  {
    "text_1": "clears all existing bindings . unset bindings are treated as null .",
    "text_2": "public void clear Bindings ( ) { if ( m Bind Args ! = null ) { Arrays . fill ( m Bind Args , null ) ; } }",
    "label": 1
  },
  {
    "text_1": "remove the last extension of file . if no extension found then return the input file e . g . a . out . log - - > a . out a . diff - - > a",
    "text_2": "public static File remove Extension ( File file ) { String absolute Path = file . get Absolute Path ( ) ; if ( absolute Path . contains ( STRING ) ) { return new File ( absolute Path . substring ( NUM , absolute Path . last Index Of ( STRING ) ) ) ; } else { return file ; } }",
    "label": 1
  },
  {
    "text_1": "validate the given method name . the special names \" & lt ; init & gt ; \" and \" & lt ; clinit & gt ; \" are not valid . the syntax for a method name is defined by identifier of method declarator ( jls 2 8 . 4 ) . for example \" println \" .",
    "text_2": "public static I Status validate Method Name ( String name ) { return validate Method Name ( name , Compiler Options . VERSION NUM NUM , Compiler Options . VERSION NUM NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "recursively copy every file / folder from root to dest",
    "text_2": "public static void copy All ( File root , File dest ) throws IO Exception { if ( root . is Directory ( ) ) { for ( File child : root . list Files ( ) ) { File child Dest = new File ( dest , child . get Name ( ) ) ; if ( child . is Directory ( ) ) { if ( ! child Dest . exists ( ) & & ! mkdirs ( child Dest ) ) throw new IO Exception ( STRING + child Dest . get Path ( ) ) ; copy All ( child , child Dest ) ; } else { Files . copy ( child . to Path ( ) , child Dest . to Path ( ) , Standard Copy Option . COPY ATTRIBUTES ) ; } } } else { File child Dest = new File ( dest , root . get Name ( ) ) ; if ( ! dest . exists ( ) & & ! mkdirs ( dest ) ) throw new IO Exception ( STRING + dest . get Path ( ) ) ; Files . copy ( root . to Path ( ) , child Dest . to Path ( ) , Standard Copy Option . COPY ATTRIBUTES ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "our m column to ps and m column botto ms need to be re - built up to the m sync position - the following layout request will then layout the that position and then fill up and fill down appropriately .",
    "text_2": "private void on Column Sync ( ) { int sync Position = Math . min ( m Sync Position , get Count ( ) - NUM ) ; Sparse Array < Double > position Height Ratios = new Sparse Array < Double > ( sync Position ) ; for ( int pos = NUM ; pos < sync Position ; pos + + ) { final Grid Item Record rec = m Position Data . get ( pos ) ; if ( rec = = null ) break ; Log . d ( TAG , STRING + pos + STRING + rec . height Ratio ) ; position Height Ratios . append ( pos , rec . height Ratio ) ; } m Position Data . clear ( ) ; if ( DBG ) Log . d ( TAG , STRING + m Column Width ) ; for ( int pos = NUM ; pos < sync Position ; pos + + ) { final Grid Item Record rec = get Or Create Record ( pos ) ; final double height Ratio = position Height Ratios . get ( pos ) ; final int height = ( int ) ( m Column Width * height Ratio ) ; rec . height Ratio = height Ratio ; int top ; int bottom ; if ( is Header Or Footer ( pos ) ) { top = get Lowest Positioned Bottom ( ) ; bottom = top + height ; for ( int i = NUM ; i < m Column Count ; i + + ) { m Column Tops [ i ] = top ; m Column Bott oms [ i ] = bottom ; } } else { final int column = get Highest Positioned Bottom Column ( ) ; top = m Column Bott oms [ column ] ; bottom = top + height + get Child Top Margin ( pos ) + get Child Bottom Margin ( ) ; m Column Tops [ column ] = top ; m Column Bott oms [ column ] = bottom ; rec . column = column ; } if ( DBG ) Log . d ( TAG , STRING + pos + STRING + top + STRING + bottom + STRING + height + STRING + height Ratio ) ; } final int sync Column = get Highest Positioned Bottom Column ( ) ; set Position Column ( sync Position , sync Column ) ; int sync To Bottom = m Column Bott oms [ sync Column ] ; int offset = - sync To Bottom + m Specific Top ; offset All Columns Top And Bottom ( offset ) ; m Distance To Top = - sync To Bottom ; System . arraycopy ( m Column Bott oms , NUM , m Column Tops , NUM , m Column Count ) ; }",
    "label": 1
  },
  {
    "text_1": "provides detailed description of this annotation instance , including all member name - values pairs .",
    "text_2": "public String to String ( ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; result . append ( klazz . get Name ( ) ) ; result . append ( STRING ) ; for ( int i = NUM ; i < elements . length ; + + i ) { if ( i ! = NUM ) { result . append ( STRING ) ; } result . append ( elements [ i ] ) ; } result . append ( STRING ) ; return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "260 a ' stream less ' version of encode that simply takes a bytebuffer 261 and returns a string containing the encoded buffer . 262 2 63 the bytebuffer ' s position will be advanced to bytebuffer ' s limit . 264",
    "text_2": "public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the next available reference from the queue , removing it in the process . waits for a reference to become available or the given timeout period to elapse , whichever happens first .",
    "text_2": "public synchronized Reference < ? extends T > remove ( long timeout Millis ) throws Interrupted Exception { if ( timeout Millis < NUM ) { throw new Illegal Argument Exception ( STRING + timeout Millis ) ; } if ( head ! = null ) { return poll ( ) ; } if ( timeout Millis = = NUM | | ( timeout Millis > Long . MAX VALUE / NANOS PER MILLI ) ) { do { wait ( NUM ) ; } while ( head = = null ) ; return poll ( ) ; } long nanos To Wait = timeout Millis * NANOS PER MILLI ; int timeout Nanos = NUM ; long start Time = System . nano Time ( ) ; while ( BOOL ) { wait ( timeout Millis , timeout Nanos ) ; if ( head ! = null ) { break ; } long nanos Elapsed = System . nano Time ( ) - start Time ; long nanos Remaining = nanos To Wait - nanos Elapsed ; if ( nanos Remaining < = NUM ) { break ; } timeout Millis = nanos Remaining / NANOS PER MILLI ; timeout Nanos = ( int ) ( nanos Remaining - timeout Millis * NANOS PER MILLI ) ; } return poll ( ) ; }",
    "label": 1
  },
  {
    "text_1": "paint left content border edge",
    "text_2": "protected void paint Content Border Left Edge ( Graphics g , int tab Placement , int selected Index , int x , int y , int w , int h ) { Rectangle sel Rect = selected Index < NUM ? null : get Tab Bounds ( selected Index , calc Rect ) ; g . set Color ( select Highlight ) ; if ( tab Placement ! = LEFT | | selected Index < NUM | | ( sel Rect . x + sel Rect . width + NUM < x ) | | ( sel Rect . y < y | | sel Rect . y > y + h ) ) { g . draw Line ( x , y , x , y + h - NUM ) ; } else { g . draw Line ( x , y , x , sel Rect . y + NUM ) ; if ( sel Rect . y + sel Rect . height < y + h - NUM ) g . draw Line ( x , sel Rect . y + sel Rect . height + NUM , x , y + h - NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "here we add a textnode and its postion to a list . we also build the paragraph string .",
    "text_2": "private void add ( String text , Text text Node ) { int start Index = builder . length ( ) ; builder . append ( text ) ; int end Index = builder . length ( ) ; text Runs . add ( new Text Run ( text Node , start Index , end Index ) ) ; }",
    "label": 1
  },
  {
    "text_1": "new bigdecimal ( string value ) ; value contains exponent and does not contain decimal point",
    "text_2": "public void test Constr String With Exponent Without Point NUM ( ) { String a = STRING ; int a Scale = NUM ; Big Integer bA = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; assert Equals ( STRING , bA , a Number . unscaled Value ( ) ) ; assert Equals ( STRING , a Scale , a Number . scale ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "create a zip fi an generator for items between min and max ( inclusive ) for the specified zip fi an constant , using the precomputed value of z eta .",
    "text_2": "public Zip fi an Generator ( long min , long max , double zip fi an constant , double zet an ) { items = max - min + NUM ; base = min ; zip fi an constant = zip fi an constant ; theta = zip fi an constant ; zeta NUM theta = zeta ( NUM , theta ) ; alpha = NUM / ( NUM - theta ) ; zet an = zet an ; count for zeta = items ; eta = ( NUM - Math . pow ( NUM / items , NUM - theta ) ) / ( NUM - zeta NUM theta / zet an ) ; next Int ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds all instances with unknown values for given attribute , weighted according to frequency of instances in each bag .",
    "text_2": "public final void add Inst With Unknown ( Instances source , int att Index ) throws Exception { double [ ] probs ; double weight , new Weight ; int class Index ; Instance instance ; int j ; probs = new double [ m per Bag . length ] ; for ( j = NUM ; j < m per Bag . length ; j + + ) { if ( Utils . eq ( to ta L , NUM ) ) { probs [ j ] = NUM / probs . length ; } else { probs [ j ] = m per Bag [ j ] / to ta L ; } } Enumeration < Instance > enu = source . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { instance = enu . next Element ( ) ; if ( instance . is Missing ( att Index ) ) { class Index = ( int ) instance . class Value ( ) ; weight = instance . weight ( ) ; m per Class [ class Index ] = m per Class [ class Index ] + weight ; to ta L = to ta L + weight ; for ( j = NUM ; j < m per Bag . length ; j + + ) { new Weight = probs [ j ] * weight ; m per Class Per Bag [ j ] [ class Index ] = m per Class Per Bag [ j ] [ class Index ] + new Weight ; m per Bag [ j ] = m per Bag [ j ] + new Weight ; } } } }",
    "label": 1
  },
  {
    "text_1": "looks for the particular item in the list and returns the index within the list ( starting from zero ) of that item if it is found , or - 1 otherwise",
    "text_2": "public synchronized int index Of ( V item ) { return items . index Of ( item ) ; }",
    "label": 1
  },
  {
    "text_1": "converts a object to a datetime object , returns null if invalid string",
    "text_2": "public static Date Time to Date Simple ( String str , Time Zone time Zone ) throws Page Exception { Date Time dt = to Date Simple ( str , CONVER TING TYPE OFFSET , BOOL , time Zone , null ) ; if ( dt = = null ) throw new Expression Exception ( STRING + str + STRING ) ; return dt ; }",
    "label": 1
  },
  {
    "text_1": "return the next calendar in the iteration",
    "text_2": "@ Override public Calendar next ( ) { if ( spot . equals ( end Final ) ) { throw new No Such Element Exception ( ) ; } spot . add ( Calendar . DATE , NUM ) ; return ( Calendar ) spot . clone ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the string representation .",
    "text_2": "public String to String ( ) { return Descriptor . to Class Name ( Character . to String ( descriptor ) ) ; }",
    "label": 1
  },
  {
    "text_1": "scans a class node .",
    "text_2": "public void scan ( Class Node cn ) { List < Threat Result > thre ats = new Array List < Threat Result > ( ) ; for ( Class Handler class Handler : class Handlers ) { Threat Result result = class Handler . scan Class ( cn ) ; if ( result ! = null ) { thre ats . add ( result ) ; } } for ( Method Node mn : cn . methods ) { for ( Method Handler method Handler : method Handlers ) { Threat Result result = method Handler . scan Method ( mn ) ; if ( result ! = null ) { thre ats . add ( result ) ; } } } if ( thre ats . size ( ) > NUM ) { thre ats By Class . put ( cn . name , thre ats ) ; } }",
    "label": 1
  },
  {
    "text_1": "build a default class path from the path strings specified by the properties sun . boot . class . path and env . class . path , in that order .",
    "text_2": "public Class Path ( ) { String sy scp = System . get Property ( STRING ) ; String env cp = System . get Property ( STRING ) ; if ( env cp = = null ) env cp = STRING ; String cp = sy scp + File . path Separator + env cp ; init ( cp ) ; }",
    "label": 1
  },
  {
    "text_1": "ensures that the specified number of additional bytes will fit in the buffer and resizes it if necessary .",
    "text_2": "public void ensure Additional Capacity ( final int size ) { final int new Count = visible . position ( ) + size ; if ( new Count > visible . capacity ( ) ) { final Byte Buffer new Byte Buffer = Byte Buffer . allocate ( Math . max ( visible . capacity ( ) < < NUM , new Count ) ) ; visible . flip ( ) ; visible = new Byte Buffer . put ( visible ) ; } }",
    "label": 1
  },
  {
    "text_1": "parses a ' pa up ' block .",
    "text_2": "public Partition Substitution Model parse PA UP Block ( B eaut i Options options , List < Char Set > char Sets ) throws Import Exception , IO Exception { Partition Substitution Model model = new Partition Substitution Model ( options , STRING ) ; read Top Level Block ( options , model , char Sets ) ; return model ; }",
    "label": 1
  },
  {
    "text_1": "resets mesh to ' initial ' state . meaning this mesh will draw a plain text ured rectangle after call to this method .",
    "text_2": "public synchronized void reset ( ) { m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } for ( int i = NUM ; i < NUM ; + + i ) { Vertex tmp = m Arr Temp Vertices . get ( NUM ) ; tmp . set ( m Rectangle [ i ] ) ; if ( m Flip Texture ) { tmp . m Tex X * = m Texture Rect Back . right ; tmp . m Tex Y * = m Texture Rect Back . bottom ; tmp . m Color = m Texture Page . get Color ( Curl Page . SIDE BACK ) ; } else { tmp . m Tex X * = m Texture Rect Front . right ; tmp . m Tex Y * = m Texture Rect Front . bottom ; tmp . m Color = m Texture Page . get Color ( Curl Page . SIDE FRONT ) ; } add Vertex ( tmp ) ; } m Vertices Count Front = NUM ; m Vertices Count Back = NUM ; m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } m Drop Shadow Count = m Self Shadow Count = NUM ; }",
    "label": 1
  },
  {
    "text_1": "operates on all individuals , removes the original individuals and adds the new ones .",
    "text_2": "@ Override public void operate ( Population pop ) throws Exception { List < Individual > new Individuals = new Linked List < Individual > ( ) ; for ( int i = NUM ; i < pop . get Number Of Individuals ( ) ; i + + ) { List < Individual > individuals = operate ( pop . get ( i ) ) ; new Individuals . add All ( individuals ) ; } pop . clear ( ) ; pop . add All Individuals ( new Individuals ) ; }",
    "label": 1
  },
  {
    "text_1": "compute the intersection of a line and a rectangle .",
    "text_2": "public static int intersect Line Rectangle ( Line NUM D l , Rectangle NUM D r , Point NUM D [ ] pts ) { double a NUM x = l . get X NUM ( ) , a NUM y = l . get Y NUM ( ) ; double a NUM x = l . get X NUM ( ) , a NUM y = l . get Y NUM ( ) ; double m xx = r . get Max X ( ) , m xy = r . get Max Y ( ) ; double m nx = r . get Min X ( ) , m ny = r . get Min Y ( ) ; if ( pts [ NUM ] = = null ) pts [ NUM ] = new Point NUM D . Double ( ) ; if ( pts [ NUM ] = = null ) pts [ NUM ] = new Point NUM D . Double ( ) ; int i = NUM ; if ( intersect Line Line ( m nx , m ny , m xx , m ny , a NUM x , a NUM y , a NUM x , a NUM y , pts [ i ] ) > NUM ) i + + ; if ( intersect Line Line ( m xx , m ny , m xx , m xy , a NUM x , a NUM y , a NUM x , a NUM y , pts [ i ] ) > NUM ) i + + ; if ( i = = NUM ) return i ; if ( intersect Line Line ( m xx , m xy , m nx , m xy , a NUM x , a NUM y , a NUM x , a NUM y , pts [ i ] ) > NUM ) i + + ; if ( i = = NUM ) return i ; if ( intersect Line Line ( m nx , m xy , m nx , m ny , a NUM x , a NUM y , a NUM x , a NUM y , pts [ i ] ) > NUM ) i + + ; return i ; }",
    "label": 1
  },
  {
    "text_1": "ensures there is enough space in the buffer for the given number of additional bytes .",
    "text_2": "private void expand ( int i ) { if ( count + i < = buf . length ) { return ; } byte [ ] newbuf = m Pool . get Buf ( ( count + i ) * NUM ) ; System . arraycopy ( buf , NUM , newbuf , NUM , count ) ; m Pool . return Buf ( buf ) ; buf = newbuf ; }",
    "label": 1
  },
  {
    "text_1": "calculate the surface distance in kilo metres from the this latlng to the given latlng .",
    "text_2": "public double distance ( Lat Lng ll ) { double er = NUM ; double lat From = Math . to Radians ( get Lat ( ) ) ; double lat To = Math . to Radians ( ll . get Lat ( ) ) ; double lng From = Math . to Radians ( get Lng ( ) ) ; double lng To = Math . to Radians ( ll . get Lng ( ) ) ; double d = Math . acos ( Math . sin ( lat From ) * Math . sin ( lat To ) + Math . cos ( lat From ) * Math . cos ( lat To ) * Math . cos ( lng To - lng From ) ) * er ; return d ; }",
    "label": 1
  },
  {
    "text_1": "action that will be called from the workflow inbox . the inbox also passes the id of the clicked item which is of the form : < next - workflow - action > - service code - userid - counter id",
    "text_2": "@ Action ( value = STRING ) public String list Workflow ( ) { if ( wf Action ! = null & & wf Action . equals ( Collection Constants . WF ACTION APPROVE ) ) fetch Receipts ( Collection Constants . WF ACTION APPROVE ) ; else fetch Receipts ( Collection Constants . WF ACTION SUBMIT ) ; return INDEX ; }",
    "label": 1
  },
  {
    "text_1": "calculating the number of ints ( m bit size ) cannot rely on a power of 2 . previously this assumption was sufficient to guarantee a rounding on to an 64 k boundary . however , now n ints 32 64 = 64 k , so need multiple of 32 ints . so , whatever multiple of 64 , if we allocate a multiple of 32 ints we are guaranteed to be on an 64 k boundary . this does mean that for the largest blocks of ~ 256 k , we are allocating 256 mb of space",
    "text_2": "Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i + + ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }",
    "label": 1
  },
  {
    "text_1": "this is a quiet method .",
    "text_2": "public static boolean delete Files In A Directory ( String directory Path ) { if ( ( directory Path = = null ) | | directory Path . is Empty ( ) ) { return BOOL ; } boolean is Successful Delete = BOOL ; List < File > files = get List Of Files In A Directory ( directory Path ) ; if ( files = = null ) { return BOOL ; } try { for ( File file : files ) { boolean file Delete Success = delete File ( directory Path , file . get Name ( ) ) ; if ( ! file Delete Success ) { is Successful Delete = BOOL ; } } } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; is Successful Delete = BOOL ; } return is Successful Delete ; }",
    "label": 1
  },
  {
    "text_1": "flush the output stream . must be called when done printing the document , otherwise some text might be buffered .",
    "text_2": "public void flush ( ) throws IO Exception { try { writer . write ( buffer , NUM , pos ) ; writer . flush ( ) ; } catch ( IO Exception except ) { if ( exception = = null ) exception = except ; throw except ; } pos = NUM ; }",
    "label": 1
  },
  {
    "text_1": "write a subarray of bytes over connection .",
    "text_2": "public synchronized void write ( byte b [ ] , int off , int len ) throws IO Exception { if ( len < = NUM ) return ; int free Space = buffer . length - pos ; if ( len < = free Space ) { System . arraycopy ( b , off , buffer , pos , len ) ; pos + = len ; return ; } flush ( ) ; int local requested ; while ( BOOL ) { synchronized ( lock ) { while ( ( local requested = requested ) < NUM & & ! disconnected ) { try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } if ( disconnected ) throw new IO Exception ( STRING ) ; } if ( local requested < len ) { manager . send Transmit ( info , b , off , local requested ) ; off + = local requested ; len - = local requested ; synchronized ( lock ) { requested - = local requested ; } } else { manager . send Transmit ( info , b , off , len ) ; synchronized ( lock ) { requested - = len ; } break ; } } }",
    "label": 1
  },
  {
    "text_1": "returns the value of this effect in the current selection .",
    "text_2": "public List < V > values In Selection ( Rich Edit Text editor , int span Type ) { List < V > result = new Array List < V > ( ) ; Selection expanded Selection = get Expanded Selection ( editor , span Type ) ; if ( expanded Selection ! = null ) { for ( Span < V > span : get Spans ( editor . get Text ( ) , expanded Selection ) ) { result . add ( span . get Value ( ) ) ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "checks if ascii encoding works with inputstreamreader",
    "text_2": "public void test Ascii ( ) throws Exception { String str = STRING ; Byte Array Input Stream aa = new Byte Array Input Stream ( str . get Bytes ( STRING ) ) ; Input Stream Reader a = new Input Stream Reader ( aa , STRING ) ; try { int x = a . read ( ) ; assert Equals ( STRING , x ) ; char [ ] c = new char [ NUM ] ; x = a . read ( c , NUM , NUM ) ; assert Equals ( STRING , a . get Encoding ( ) ) ; assert Equals ( NUM , x ) ; assert Equals ( STRING , String . value Of ( c ) ) ; } finally { a . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "this method will be used to write leaf data to file file format < key > < measure 1 > < measure 2 > . . . .",
    "text_2": "protected void write Data To File ( Node Holder node Holder ) throws Carbon Data Writer Exception { long offset = write Data To File ( node Holder , file Channel ) ; Blocklet Info Column ar blocklet Info = get Blocklet Info ( node Holder , offset ) ; blocklet Info List . add ( blocklet Info ) ; }",
    "label": 1
  },
  {
    "text_1": "check if we have dragged the bottom of the list too high ( we have pushed the top element off the top of the screen when we did not need to ) . correct by sliding everything back down .",
    "text_2": "private void correct Too High ( int child Count ) { int last Position = m First Position + child Count - NUM ; if ( last Position = = m Item Count - NUM & & child Count > NUM ) { final int last Bottom = get Lowest Child Bottom ( ) ; final int end = ( get Bottom ( ) - get Top ( ) ) - get List Padding Bottom ( ) ; int bottom Offset = end - last Bottom ; final int first Top = get Highest Child Top ( ) ; if ( bottom Offset > NUM & & ( m First Position > NUM | | first Top < get List Padding Top ( ) ) ) { if ( m First Position = = NUM ) { bottom Offset = Math . min ( bottom Offset , get List Padding Top ( ) - first Top ) ; } offset Children Top And Bottom ( bottom Offset ) ; if ( m First Position > NUM ) { int previous Position = m First Position - NUM ; fill Up ( previous Position , get Next Child Ups Bottom ( previous Position ) ) ; adjust Views Up Or Down ( ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "calculate the p - norm ( i . e . length ) between two vectors .",
    "text_2": "public static double vector Distance ( double [ ] vec NUM , double [ ] vec NUM , double power , double one Over Power ) { double result = NUM ; if ( power = = NUM ) { for ( int i = NUM ; i < vec NUM . length ; i + + ) { result + = vec NUM [ i ] - vec NUM [ i ] = = NUM ? NUM : NUM ; } } else if ( power = = NUM ) { for ( int i = NUM ; i < vec NUM . length ; i + + ) { result + = Math . abs ( vec NUM [ i ] - vec NUM [ i ] ) ; } } else if ( power = = NUM ) { result = Math . sqrt ( dist Squared Cartesian ( vec NUM , vec NUM ) ) ; } else if ( power = = Integer . MAX VALUE | | Double . is Infinite ( power ) ) { for ( int i = NUM ; i < vec NUM . length ; i + + ) { result = Math . max ( result , Math . max ( vec NUM [ i ] , vec NUM [ i ] ) ) ; } } else { for ( int i = NUM ; i < vec NUM . length ; i + + ) { result + = Math . pow ( vec NUM [ i ] - vec NUM [ i ] , power ) ; } result = Math . pow ( result , one Over Power ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "todo : currently the repo only supports form based authentication . that way a rest controller authenticate would need to be invoked and session needs to be passed along .",
    "text_2": "private Header create Security Header ( ) { return new Basic Header ( STRING , STRING + create Auth ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if a charsequence is whitespace , empty ( \" \" ) or null .",
    "text_2": "public boolean is Blank ( final Char Sequence cs ) { int str Len ; if ( cs = = null | | ( str Len = cs . length ( ) ) = = NUM ) { return BOOL ; } for ( int i = NUM ; i < str Len ; i + + ) { if ( ! Character . is Whitespace ( cs . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "removes \\ \\ r characters from query . actually this is done specially for oracle due to some bug in it ' s driver",
    "text_2": "public static String make Unified Line Feeds ( String query ) { if ( query . index Of ( STRING ) = = - NUM ) { return query ; } String Builder result = new String Builder ( query . length ( ) ) ; for ( int i = NUM ; i < query . length ( ) ; i + + ) { char c = query . char At ( i ) ; if ( c = = STRING ) { continue ; } result . append ( c ) ; } return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "shows a error dialog in case creating a directory failed .",
    "text_2": "private static void show Directory Creation Error ( final String directory ) { final String message = STRING + STRING ; final String description = C Utility Functions . create Description ( String . format ( STRING , directory ) , new String [ ] { STRING } , new String [ ] { STRING , STRING } ) ; Navi Error Dialog . show ( null , message , description ) ; }",
    "label": 1
  },
  {
    "text_1": "this creates a model editor . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >",
    "text_2": "public Eip Editor ( ) { super ( ) ; initialize Editing Domain ( ) ; }",
    "label": 1
  },
  {
    "text_1": "parses http headers from the data receiver stream according to the generic format as given in section 3 . 1 of rfc 822 , rfc - 2616 section 4 and 19 . 3 .",
    "text_2": "public static Header [ ] parse Headers ( final Session Input Buffer inbuffer , int max Header Count , int max Line Len , Line Parser parser ) throws Http Exception , IO Exception { if ( inbuffer = = null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( parser = = null ) parser = Basic Line Parser . DEFAULT ; Array List header Lines = new Array List ( ) ; Char Array Buffer current = null ; Char Array Buffer previous = null ; for ( ; ; ) { if ( current = = null ) { current = new Char Array Buffer ( NUM ) ; } else { current . clear ( ) ; } int l = inbuffer . read Line ( current ) ; if ( l = = - NUM | | current . length ( ) < NUM ) { break ; } if ( ( current . char At ( NUM ) = = STRING | | current . char At ( NUM ) = = STRING ) & & previous ! = null ) { int i = NUM ; while ( i < current . length ( ) ) { char ch = current . char At ( i ) ; if ( ch ! = STRING & & ch ! = STRING ) { break ; } i + + ; } if ( max Line Len > NUM & & previous . length ( ) + NUM + current . length ( ) - i > max Line Len ) { throw new IO Exception ( STRING ) ; } previous . append ( STRING ) ; previous . append ( current , i , current . length ( ) - i ) ; } else { header Lines . add ( current ) ; previous = current ; current = null ; } if ( max Header Count > NUM & & header Lines . size ( ) > = max Header Count ) { throw new IO Exception ( STRING ) ; } } Header [ ] headers = new Header [ header Lines . size ( ) ] ; for ( int i = NUM ; i < header Lines . size ( ) ; i + + ) { Char Array Buffer buffer = ( Char Array Buffer ) header Lines . get ( i ) ; try { headers [ i ] = parser . parse Header ( buffer ) ; } catch ( Parse Exception ex ) { throw new Protocol Exception ( ex . get Message ( ) ) ; } } return headers ; }",
    "label": 1
  },
  {
    "text_1": "remove a player movement direction .",
    "text_2": "public void remove Direction ( final Direction dir , final boolean face ) { RP Action action ; int size ; action = new RP Action ( ) ; action . put ( STRING , STRING ) ; action . put ( STRING , - dir . get ( ) ) ; send ( action ) ; directions . remove ( dir ) ; size = directions . size ( ) ; if ( size = = NUM ) { action = new RP Action ( ) ; action . put ( STRING , STRING ) ; } else { if ( face ) { action = new Face RP Action ( directions . get ( size - NUM ) ) ; } else { action = new Move RP Action ( directions . get ( size - NUM ) ) ; } } send ( action ) ; }",
    "label": 1
  },
  {
    "text_1": "deletes all selected nodes in the workbench plus any edges that have had one of their nodes deleted in the process .",
    "text_2": "public final void delete Selected Objects ( ) { Component [ ] components = get Components ( ) ; List < Display Node > graph Nodes = new Array List < > ( ) ; List < I Display Edge > graph Edges = new Array List < > ( ) ; for ( Component comp : components ) { if ( comp instanceof Display Node ) { if ( ! is Delete Variables Allowed ( ) ) { continue ; } Display Node node = ( Display Node ) comp ; if ( node . is Selected ( ) ) { graph Nodes . add ( node ) ; } } else if ( comp instanceof I Display Edge ) { I Display Edge edge = ( I Display Edge ) comp ; if ( edge . is Selected ( ) ) { graph Edges . add ( edge ) ; } } } for ( Display Node graph Node : graph Nodes ) { remove Node ( graph Node ) ; } for ( I Display Edge display Edge : graph Edges ) { try { remove Edge ( display Edge ) ; reset Edge Offsets ( display Edge ) ; } catch ( Exception e ) { if ( is Node Edge Errors Reported ( ) ) { J Option Pane . show Message Dialog ( J Option Utils . centering Comp ( ) , e . get Message ( ) ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "post all filenames provided in args",
    "text_2": "public int post Files ( File [ ] files , int start Index In Args , Output Stream out , String type ) { reset ( ) ; int files Posted = NUM ; for ( File src File : files ) { if ( src File . is Directory ( ) & & src File . can Read ( ) ) { files Posted + = post Directory ( src File , out , type ) ; } else if ( src File . is File ( ) & & src File . can Read ( ) ) { files Posted + = post Files ( new File [ ] { src File } , out , type ) ; } else { File parent = src File . get Parent File ( ) ; if ( parent = = null ) parent = new File ( STRING ) ; String file Glob = src File . get Name ( ) ; Glob File Filter ff = new Glob File Filter ( file Glob , BOOL ) ; File [ ] file List = parent . list Files ( ff ) ; if ( file List = = null | | file List . length = = NUM ) { warn ( STRING + src File ) ; continue ; } files Posted + = post Files ( file List , out , type ) ; } } return files Posted ; }",
    "label": 1
  },
  {
    "text_1": "creates a signature object for the specified algorithm .",
    "text_2": "protected Signature ( String algorithm ) { this . algorithm = algorithm ; }",
    "label": 1
  },
  {
    "text_1": "adds a listener to the list that is notified each time a change to data model occurs",
    "text_2": "@ Override public void add Table Model Listener ( Table Model Listener l ) { m Listeners . add ( l ) ; }",
    "label": 1
  },
  {
    "text_1": "adds list of arguments to command line .",
    "text_2": "public Command Line add ( String . . . args ) { if ( args ! = null & & args . length > NUM ) { Collections . add All ( arguments , args ) ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "this method will force the appropriate facet method even if the user provided a different one as a request parameter n . b . this method could overwrite what you passed as request parameter . be extra careful",
    "text_2": "static Facet Method select Facet Method ( Schema Field field , Facet Method method , Integer min count ) { Field Type type = field . get Type ( ) ; if ( method = = null ) { if ( type instanceof Bool Field & & ( field . indexed ( ) = = BOOL | | field . has Doc Values ( ) = = BOOL ) ) { method = Facet Method . ENUM ; } else if ( type . get Numeric Type ( ) ! = null & & ! field . multi Valued ( ) ) { method = Facet Method . FCS ; } else { method = Facet Method . FC ; } } if ( method = = Facet Method . FC & & type . get Numeric Type ( ) ! = null & & ! field . multi Valued ( ) ) { method = Facet Method . FCS ; } if ( method = = Facet Method . U IF & & ! field . has Doc Values ( ) & & min count = = NUM ) { method = field . multi Valued ( ) ? Facet Method . FC : Facet Method . FCS ; } if ( method = = Facet Method . ENUM & & Trie Field . get Main Value Prefix ( type ) ! = null ) { method = field . multi Valued ( ) ? Facet Method . FC : Facet Method . FCS ; } final boolean multi Token = field . multi Valued ( ) | | type . multi Valued Field Cache ( ) ; if ( method = = Facet Method . FCS & & multi Token ) { method = Facet Method . FC ; } return method ; }",
    "label": 1
  },
  {
    "text_1": "intercept every call to the specified method and call a handler function instead .",
    "text_2": "private native synchronized static void hook Method Native ( Member method , Class < ? > declaring Class , int slot , Object additional Info ) ;",
    "label": 1
  },
  {
    "text_1": "check whether some of the first polygon ' s edges defined forms a separation axis of two polygons defined by the lists of vertices . optionally obtain a normalized direction of the separation axis .",
    "text_2": "static boolean separate Convex Polygons ( float [ ] verts NUM , float [ ] verts NUM , Vector NUM separation ) { final int length NUM = verts NUM . length ; final int length NUM = verts NUM . length ; for ( int i = NUM ; i < length NUM ; i + = NUM ) { final int j = ( i + NUM ) % length NUM ; float proj X = verts NUM [ j + NUM ] - verts NUM [ i + NUM ] ; float proj Y = verts NUM [ i ] - verts NUM [ j ] ; final float length = ( float ) Math . sqrt ( proj X * proj X + proj Y * proj Y ) ; proj X / = length ; proj Y / = length ; float min NUM = Float . POSITIVE INFINITY , max NUM = Float . NEGATIVE INFINITY ; for ( int k = NUM ; k < length NUM ; k + = NUM ) { final float dot = proj X * verts NUM [ k ] + proj Y * verts NUM [ k + NUM ] ; if ( dot < min NUM ) min NUM = dot ; if ( dot > max NUM ) max NUM = dot ; } float min NUM = Float . POSITIVE INFINITY , max NUM = Float . NEGATIVE INFINITY ; for ( int k = NUM ; k < length NUM ; k + = NUM ) { final float dot = proj X * verts NUM [ k ] + proj Y * verts NUM [ k + NUM ] ; if ( dot < min NUM ) min NUM = dot ; if ( dot > max NUM ) max NUM = dot ; } if ( ( max NUM < min NUM ) | | ( max NUM < min NUM ) ) { if ( null ! = separation ) separation . set ( proj Y , - proj X ) ; return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "writes a binary plist serialization of the given object as the root into a byte array .",
    "text_2": "public static byte [ ] write To Array ( NS Object root ) throws IO Exception { Byte Array Output Stream bout = new Byte Array Output Stream ( ) ; write ( bout , root ) ; return bout . to Byte Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create a shader object from the given classpath resource .",
    "text_2": "static int create Shader ( String resource , int type ) throws IO Exception { return create Shader ( resource , type , null ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a class list filename to this set of options .",
    "text_2": "void add Class List ( String class List Filename ) { if ( class List Filename . length ( ) > NUM ) { set Option ( STRING , class List Filename ) ; load Class Names ( class List Filename ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a descriptor like \" ( ljava / lang / class ; [ i ) ljava / lang / object ; \" .",
    "text_2": "String descriptor ( boolean include This ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; if ( include This ) { result . append ( declaring Type . name ) ; } for ( Type Id t : parameters . types ) { result . append ( t . name ) ; } result . append ( STRING ) ; result . append ( return Type . name ) ; return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "convenience method for updating rows in the database .",
    "text_2": "public int update With On Conflict ( String table , Content Values values , String where Clause , String [ ] where Args , @ Conflict Algorithm int conflict Algorithm ) { if ( values = = null | | values . size ( ) = = NUM ) { throw new Illegal Argument Exception ( STRING ) ; } acquire Reference ( ) ; try { String Builder sql = new String Builder ( NUM ) ; sql . append ( STRING ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( table ) ; sql . append ( STRING ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args = = null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM ; for ( Map . Entry < String , Object > entry : values . value Set ( ) ) { sql . append ( ( i > NUM ) ? STRING : STRING ) ; sql . append ( entry . get Key ( ) ) ; bind Args [ i + + ] = entry . get Value ( ) ; sql . append ( STRING ) ; } if ( where Args ! = null ) { for ( i = set Values Size ; i < bind Args Size ; i + + ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! Text Utils . is Empty ( where Clause ) ) { sql . append ( STRING ) ; sql . append ( where Clause ) ; } SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Update Delete ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "collect the hot methods that have been compiled at the given opt level .",
    "text_2": "public synchronized Method Count Set collect Hot Methods ( int opt Level , double threshold ) { if ( DEBUG ) validity Check ( ) ; Array List < Hot Method Recom pilation Event > collect = new Array List < Hot Method Recom pilation Event > ( ) ; collect Hot Opt Methods Internal ( NUM , collect , ho tness To Counts ( threshold ) , opt Level ) ; int num Hot Methods = collect . size ( ) ; double [ ] num Counts = new double [ num Hot Methods ] ; Compiled Method [ ] hot Methods = new Compiled Method [ num Hot Methods ] ; for ( int i = NUM ; i < num Hot Methods ; i + + ) { Hot Method Event event = collect . get ( i ) ; hot Methods [ i ] = event . get Compiled Method ( ) ; num Counts [ i ] = event . get Num Samples ( ) ; } return new Method Count Set ( hot Methods , num Counts ) ; }",
    "label": 1
  },
  {
    "text_1": "generates the graph string of the co b web tree",
    "text_2": "@ Override public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; text . append ( STRING ) ; m cob web Tree . graph Tree ( text ) ; text . append ( STRING ) ; return text . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "test is the url is signed .",
    "text_2": "public boolean is R sl Url Signed ( String url ) { if ( url = = null ) { return BOOL ; } return url . ends With ( SIGNED RSL URL DOT EXTENSION ) ; }",
    "label": 1
  },
  {
    "text_1": "parses the json data from the specified reader into list of objects of the specified type .",
    "text_2": "public < T > Json Array < T > create List Dto From Json ( Reader json , Class < T > dto Interface ) throws IO Exception { final Dto Provider < T > dto Provider = get Dto Provider ( dto Interface ) ; final List < Json Element > list ; try { list = gson . from Json ( json , list Type Cache . get ( Json Element . class ) ) ; } catch ( Json Syntax Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof IO Exception ) { throw ( IO Exception ) cause ; } throw e ; } final List < T > result = new Array List < > ( list . size ( ) ) ; for ( Json Element e : list ) { result . add ( dto Provider . from Json ( e ) ) ; } return new Json Array Impl < > ( result ) ; }",
    "label": 1
  },
  {
    "text_1": "uninstalls the ui defaults .",
    "text_2": "protected void uninstall Defaults ( ) { Sea Glass Context context = get Context ( split Pane , ENABLED ) ; style . uninstall Defaults ( context ) ; context . dispose ( ) ; style = null ; context = get Context ( split Pane , Region . SPLIT PANE DIVIDER , ENABLED ) ; divider Style . uninstall Defaults ( context ) ; context . dispose ( ) ; divider Style = null ; super . uninstall Defaults ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create a new dependency with a given digest .",
    "text_2": "public J Class Dependency ( J Class cl , String digest ) { class Name = cl . get Name ( ) ; String new Digest = get Digest ( ) ; if ( ! new Digest . equals ( digest ) ) { if ( log . is Loggable ( Level . FINE ) ) log . fine ( class Name + STRING ) ; is Digest Modified = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "returns the hostname property",
    "text_2": "public String host ( Properties props ) { return props . get Property ( HOST PROPERTY KEY , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new request configured to create a user owned open graph object .",
    "text_2": "public static Graph Request new Post Open Graph Object Request ( Access Token access Token , JSON Object open Graph Object , Callback callback ) { if ( open Graph Object = = null ) { throw new Facebook Exception ( STRING ) ; } if ( Utility . is Null Or Empty ( open Graph Object . opt String ( STRING ) ) ) { throw new Facebook Exception ( STRING ) ; } if ( Utility . is Null Or Empty ( open Graph Object . opt String ( STRING ) ) ) { throw new Facebook Exception ( STRING ) ; } String path = String . format ( MY OBJECTS FORMAT , open Graph Object . opt String ( STRING ) ) ; Bundle bundle = new Bundle ( ) ; bundle . put String ( OBJECT PARAM , open Graph Object . to String ( ) ) ; return new Graph Request ( access Token , path , bundle , Http Method . POST , callback ) ; }",
    "label": 1
  },
  {
    "text_1": "given a namespace uri , and the namespaces mappings for the current element , return the current prefix for that uri .",
    "text_2": "public String lookup Prefix ( String uri ) { String found Prefix = null ; Enumeration prefixes = m namespaces . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = ( String ) prefixes . next Element ( ) ; String uri NUM = lookup Namespace ( prefix ) ; if ( uri NUM ! = null & & uri NUM . equals ( uri ) ) { found Prefix = prefix ; break ; } } return found Prefix ; }",
    "label": 1
  },
  {
    "text_1": "escape restricted xml 1 . 1 characters inside the buffer and send the output to the writer . the \" & \" , \" < \" , and \" > \" characters are always escaped . single and double quotes are escaped when within an attribute . all xml 1 . 1 restricted characters are escaped using \" & x ( value ) ; \" .",
    "text_2": "@ Override public void escape ( char [ ] buffer , int start , int length , boolean is Attribute Value , Writer output Writer ) throws IO Exception { for ( int i = start ; i < start + length ; i + + ) { char ch = buffer [ i ] ; if ( ch = = STRING ) { output Writer . write ( STRING ) ; continue ; } if ( ch = = STRING ) { output Writer . write ( STRING ) ; continue ; } if ( ch = = STRING ) { output Writer . write ( STRING ) ; continue ; } if ( ch = = STRING & & is Attribute Value ) { output Writer . write ( STRING ) ; continue ; } if ( ch = = STRING & & is Attribute Value ) { output Writer . write ( STRING ) ; continue ; } if ( is Xml NUM Restricted Character ( ch ) ) { output Writer . write ( STRING ) ; output Writer . write ( Integer . to Hex String ( ch ) ) ; output Writer . write ( STRING ) ; continue ; } output Writer . write ( ch ) ; } }",
    "label": 1
  },
  {
    "text_1": "xor for two negative numbers of the same length",
    "text_2": "public void test Neg Neg Same Length ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns httpentity containing data from request params included with request declaration . allows also passing progress from upload via provided response handler",
    "text_2": "private Http Entity params To Entity ( Request Params params , Response Handler Interface response Handler ) { Http Entity entity = null ; try { if ( params ! = null ) { entity = params . get Entity ( response Handler ) ; } } catch ( Throwable t ) { if ( response Handler ! = null ) response Handler . send Failure Message ( NUM , null , null , t ) ; else t . print Stack Trace ( ) ; } return entity ; }",
    "label": 1
  },
  {
    "text_1": "schedules an activity with the manager .",
    "text_2": "private void schedule ( Activity a , long start Time ) { if ( a . is Scheduled ( ) ) { try { notify All ( ) ; } catch ( Exception e ) { } return ; } a . set Start Time ( start Time ) ; synchronized ( this ) { m activities . add ( a ) ; a . set Scheduled ( BOOL ) ; if ( start Time < m next Time ) { m next Time = start Time ; notify ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "returns the network parameters for the given string id or null if not recognized .",
    "text_2": "@ Nullable public static Network Parameters from ID ( String id ) { if ( id . equals ( ID MAIN NET ) ) { return Main Net Params . get ( ) ; } else if ( id . equals ( ID TEST NET ) ) { return Test Net NUM Params . get ( ) ; } else if ( id . equals ( ID UNIT TEST NET ) ) { return Unit Test Params . get ( ) ; } else { return null ; } }",
    "label": 1
  },
  {
    "text_1": "executes the query and returns the first result . can be used when you are sure that the query returns exactly one result , for instance when the query contains an identifier limitation or when the limit is set to 1 .",
    "text_2": "public Conten tlet execute Safe First ( ) { List < Conten tlet > result = execute Safe ( ) ; if ( result . size ( ) > NUM ) { return result . get ( NUM ) ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "computes a float from mantissa and exponent .",
    "text_2": "public static float build Float ( int mant , int exp ) { if ( exp < - NUM | | mant = = NUM ) { return NUM ; } if ( exp > = NUM ) { return ( mant > NUM ) ? Float . POSITIVE INFINITY : Float . NEGATIVE INFINITY ; } if ( exp = = NUM ) { return mant ; } if ( mant > = ( NUM < < NUM ) ) { mant + + ; } return ( float ) ( ( exp > NUM ) ? mant * pow NUM [ exp ] : mant / pow NUM [ - exp ] ) ; }",
    "label": 1
  },
  {
    "text_1": "fetches a exchange rate from the repository .",
    "text_2": "private Exchange Rate direct Lookup ( final Currency source , final Currency target , final Date date ) { if ( System . get Property ( STRING ) = = null ) throw new Unsupported Operation Exception ( STRING ) ; Exchange Rate rate = null ; QL . require ( ( ( rate = fetch ( source , target , date ) ) ! = null ) , STRING ) ; return rate ; }",
    "label": 1
  },
  {
    "text_1": "returns the semi deviation , defined as the square root of the semi variance .",
    "text_2": "public double semi Deviation ( ) { return Math . sqrt ( semi Variance ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "read an array of longs from a file .",
    "text_2": "public static int read Ints ( final File f , final Long Index a , final long offset , final long addend ) throws IO Exception { return read Ints ( f , NUM , ( int ) f . length ( ) / NUM , a , offset , addend ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a file and his content fro ma a res urce",
    "text_2": "static void create File From Resource ( String resource , Resource file ) throws IO Exception { create File From Resource ( resource , file , null ) ; }",
    "label": 1
  },
  {
    "text_1": "creates and persists a new storage policy entity .",
    "text_2": "private Storage Policy Entity create Storage Policy Entity ( Namespace Entity namespace Entity , String storage Policy Name , Storage Entity storage Entity , Storage Entity destination Storage Entity , Storage Policy Rule Type Entity storage Policy Rule Type Entity , Integer storage Policy Rule Value , Business Object Definition Entity business Object Definition Entity , String business Object Format Usage , File Type Entity file Type Entity , Storage Policy Status Entity storage Policy Status Entity , Integer storage Policy Version , Boolean storage Policy Latest Version ) { Storage Policy Entity storage Policy Entity = new Storage Policy Entity ( ) ; storage Policy Entity . set Namespace ( namespace Entity ) ; storage Policy Entity . set Name ( storage Policy Name ) ; storage Policy Entity . set Storage ( storage Entity ) ; storage Policy Entity . set Destination Storage ( destination Storage Entity ) ; storage Policy Entity . set Storage Policy Rule Type ( storage Policy Rule Type Entity ) ; storage Policy Entity . set Storage Policy Rule Value ( storage Policy Rule Value ) ; storage Policy Entity . set Business Object Definition ( business Object Definition Entity ) ; if ( String Utils . is Not Blank ( business Object Format Usage ) ) { storage Policy Entity . set Usage ( business Object Format Usage ) ; } storage Policy Entity . set File Type ( file Type Entity ) ; storage Policy Entity . set Status ( storage Policy Status Entity ) ; storage Policy Entity . set Version ( storage Policy Version ) ; storage Policy Entity . set Latest Version ( storage Policy Latest Version ) ; return storage Policy Dao . save And Refresh ( storage Policy Entity ) ; }",
    "label": 1
  },
  {
    "text_1": "save the state of this deque to a stream ( that is , serialize it ) .",
    "text_2": "private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { s . default Write Object ( ) ; for ( Node < E > p = first ; p ! = null ; p = p . next ) s . write Object ( p . item ) ; s . write Object ( null ) ; } finally { lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "invoked when a matching mapping is found .",
    "text_2": "protected void handle Match ( T mapping , String lookup Path , Server Web Exchange exchange ) { }",
    "label": 1
  },
  {
    "text_1": "make a dsa private key from its der encoding ( pkcs 8 ) .",
    "text_2": "public DSA Private Key ( byte [ ] encoded ) throws Invalid Key Exception { clear Old Key ( ) ; decode ( encoded ) ; }",
    "label": 1
  },
  {
    "text_1": "instantiates a new feature type constraint model .",
    "text_2": "public Feature Type Constraint Model ( Feature Type Constraint Model Update Interface parent ) { this . parent Obj = parent ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "expects the input to have the given symbol at the current parsing position .",
    "text_2": "private void expect ( char expected Symbol ) throws Parse Exception { if ( ! accept ( expected Symbol ) ) throw new Parse Exception ( STRING + expected Symbol + STRING + ( char ) data [ index ] + STRING , index ) ; }",
    "label": 1
  },
  {
    "text_1": "initializes the upper plot .",
    "text_2": "private XY Plot initialize Plot ( ) { jmx Chart = new Y Interval Series Improved ( STRING ) ; Y Interval Series Collection y interval seri es collection = new Y Interval Series Collection ( ) ; y interval seri es collection . add Series ( jmx Chart ) ; Deviation Renderer renderer = new Deviation Renderer ( BOOL , BOOL ) ; renderer . set Base Shapes Visible ( BOOL ) ; renderer . set Series Stroke ( NUM , new Basic Stroke ( NUM , Basic Stroke . CAP ROUND , Basic Stroke . JOIN ROUND ) ) ; renderer . set Series Fill Paint ( NUM , new Color ( NUM , NUM , NUM ) ) ; renderer . set Series Outline Stroke ( NUM , new Basic Stroke ( NUM ) ) ; renderer . set Series Shape ( NUM , new Ellipse NUM D . Double ( - NUM , - NUM , NUM , NUM ) ) ; renderer . set Base Tool Tip Generator ( new Standard XY Tool Tip Generator ( Standard XY Tool Tip Generator . DEFAULT TOOL TIP FORMAT , Date Format . get Date Time Instance ( ) , Number Format . get Number Instance ( ) ) ) ; Number Axis range Axis = plot Data Solver . get Axis ( ) ; subplot = new XY Plot ( y interval seri es collection , null , range Axis , renderer ) ; subplot . set Axis Offset ( new Rectangle Insets ( NUM , NUM , NUM , NUM ) ) ; subplot . set Range Axis Location ( Axis Location . TOP OR LEFT ) ; subplot . set Range Crosshair Visible ( BOOL ) ; return subplot ; }",
    "label": 1
  },
  {
    "text_1": "create a branch that goes from [ start latitude , start longitude , start altitude ] to [ finish latitude , finish longitude , finish altitude ] , optionally arch ing through peak altitude . if division count > 0 then the branch is sub divided into segments , this is required if the branch is ar cing or has a colour gradient .",
    "text_2": "private Element generate Branch ( Tree Type tree Type , Rooted Tree tree , Node node , String node Name , double start Latitude , double finish Latitude , double start Longitude , double finish Longitude , double start Altitude , double finish Altitude , double peak Position , double peak Altitude , double start Date , double finish Date , double age Cut Off , Line Style start Style , Line Style finish Style , int division Count , List < Element > styles ) { Element element ; Double rate = ( Double ) node . get Attribute ( STRING ) ; Double support = ( Double ) node . get Attribute ( STRING ) ; double height = tree . get Height ( node ) ; boolean has Division Styles = start Style ! = null & & finish Style ! = null ; if ( division Count > NUM ) { double lat Diff = finish Latitude - start Latitude ; double lat Delta = lat Diff / division Count ; double long Diff = finish Longitude - start Longitude ; double long Delta = long Diff / division Count ; double alt Diff = finish Altitude - start Altitude ; double alt Delta = alt Diff / division Count ; double date Diff = finish Date - start Date ; double date Delta = date Diff / division Count ; double last Latitude = start Latitude ; double latitude = start Latitude + lat Delta ; double last Longitude = start Longitude ; double longitude = start Longitude + long Delta ; double x = - peak Position ; double x Delta = NUM / division Count ; double a = peak Altitude - finish Altitude ; if ( peak Position = = NUM ) { a * = NUM ; } double altitude = peak Altitude - ( a * ( x * x ) ) ; double last Altitude = altitude ; x + = x Delta ; double date = start Date ; String style Name = null ; if ( ! has Division Styles & & start Style ! = null ) { style Name = node Name + STRING ; styles . add ( generate Line Style ( style Name , start Style . get Width ( ) , start Style . get Color ( ) ) ) ; } element = generate Container ( STRING , node Name , null , ( style Name ! = null ? STRING + style Name : null ) ) ; for ( int division = NUM ; division < division Count ; division + + ) { if ( age Cut Off = = NUM | | date > age Cut Off ) { String part Name = node Name + STRING + ( division + NUM ) ; style Name = null ; if ( has Division Styles ) { style Name = part Name + STRING ; } Element place Mark = generate Container ( STRING , part Name , null , ( style Name ! = null ? STRING + style Name : null ) ) ; annotate Branch ( place Mark , height , start Date , finish Date , rate , support ) ; if ( has Division Styles ) { double width = start Style . get Width ( ) ; Color color = get Blended Color ( ( ( float ) division ) / ( division Count - NUM ) , start Style . get Color ( ) , finish Style . get Color ( ) ) ; styles . add ( generate Line Style ( style Name , width , color ) ) ; } if ( date Diff > NUM ) { Element time Span = new Element ( STRING ) ; time Span . add Content ( generate Element ( STRING , get KML Date ( date ) ) ) ; place Mark . add Content ( time Span ) ; } Element line String = new Element ( STRING ) ; Element coordinates = new Element ( STRING ) ; if ( alt Diff > NUM | | peak Altitude > NUM ) { line String . add Content ( generate Element ( STRING , altitude Mode ) ) ; altitude = peak Altitude - ( a * ( x * x ) ) ; coordinates . add Content ( STRING + last Longitude + STRING + last Latitude + STRING + last Altitude + STRING ) ; coordinates . add Content ( STRING + longitude + STRING + latitude + STRING + altitude + STRING ) ; } else { line String . add Content ( generate Element ( STRING , STRING ) ) ; line String . add Content ( generate Element ( STRING , BOOL ) ) ; coordinates . add Content ( STRING + last Longitude + STRING + last Latitude + STRING ) ; coordinates . add Content ( STRING + longitude + STRING + latitude + STRING ) ; } last Latitude = latitude ; latitude + = lat Delta ; last Longitude = longitude ; longitude + = long Delta ; last Altitude = altitude ; x + = x Delta ; date + = date Delta ; line String . add Content ( coordinates ) ; place Mark . add Content ( line String ) ; element . add Content ( place Mark ) ; } } } else { String style Name = null ; if ( start Style ! = null ) { style Name = node Name + STRING ; double width = start Style . get Width ( ) ; styles . add ( generate Line Style ( style Name , width , start Style . get Color ( ) ) ) ; } element = generate Container ( STRING , node Name , null , ( style Name ! = null ? STRING + style Name : null ) ) ; annotate Branch ( element , height , start Date , finish Date , rate , support ) ; Element line String = new Element ( STRING ) ; line String . add Content ( generate Element ( STRING , altitude Mode ) ) ; Element coordinates = new Element ( STRING ) ; if ( tree Type = = Tree Type . RECTANGLE TREE ) { coordinates . add Content ( STRING + finish Longitude + STRING + finish Latitude + STRING + finish Altitude + STRING ) ; coordinates . add Content ( STRING + finish Longitude + STRING + finish Latitude + STRING + start Altitude + STRING ) ; coordinates . add Content ( STRING + start Longitude + STRING + start Latitude + STRING + start Altitude + STRING ) ; } else { coordinates . add Content ( STRING + finish Longitude + STRING + finish Latitude + STRING + finish Altitude + STRING ) ; coordinates . add Content ( STRING + start Longitude + STRING + start Latitude + STRING + start Altitude + STRING ) ; } line String . add Content ( coordinates ) ; element . add Content ( line String ) ; } return element ; }",
    "label": 1
  },
  {
    "text_1": "recompute the separation of cluster means .",
    "text_2": "private void recompute Seper ation ( double [ ] [ ] means , double [ ] sep ) { final int k = means . length ; assert ( sep . length = = k ) ; boolean is squared = ( distance Function instanceof Squared Euclidean Distance Function ) ; Arrays . fill ( sep , Double . POSITIVE INFINITY ) ; for ( int i = NUM ; i < k ; i + + ) { Double Vector m1 = Double Vector . wrap ( means [ i ] ) ; for ( int j = NUM ; j < i ; j + + ) { double d = distance Function . distance ( m1 , Double Vector . wrap ( means [ j ] ) ) ; sep [ i ] = ( d < sep [ i ] ) ? d : sep [ i ] ; sep [ j ] = ( d < sep [ j ] ) ? d : sep [ j ] ; } } for ( int i = NUM ; i < k ; i + + ) { sep [ i ] = is squared ? Math . sqrt ( sep [ i ] ) : sep [ i ] ; sep [ i ] * = NUM ; } }",
    "label": 1
  },
  {
    "text_1": "initialize the timeout timer . value must be kept in a local variable , not a field .",
    "text_2": "private long start Wait ( ) { return System . nano Time ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create a node set dtm , and copy the members of the given dtm iterator into it .",
    "text_2": "public Node Set DTM ( Node Iterator iterator , X Path Context xctxt ) { super ( ) ; Node node ; m manager = xctxt . get DTM Manager ( ) ; while ( null ! = ( node = iterator . next Node ( ) ) ) { int handle = xctxt . get DTM Handle From Node ( node ) ; add Node In Doc Order ( handle , xctxt ) ; } }",
    "label": 1
  },
  {
    "text_1": "indicates whether organisation units are present as dimension or filter .",
    "text_2": "public boolean has Organisation Units ( ) { List < Dimensional Item Object > dim Opts = get Dimension Options ( ORGUNIT DIM ID ) ; List < Dimensional Item Object > filter Opts = get Filter Options ( ORGUNIT DIM ID ) ; return ! dim Opts . is Empty ( ) | | ! filter Opts . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "keep private . call only when holding lock .",
    "text_2": "private Record Buffer < R > try Take ( long elapsed Waiting ) { Record Buffer < R > result = null ; if ( ! retry Queue . is Empty ( ) ) { result = retry Queue . poll ( ) ; } else { result = never Pub Queue . poll ( ) ; } if ( result ! = null ) { return on Take Success ( result , elapsed Waiting ) ; } else if ( elapsed Waiting > NUM ) { return on Take Timeout ( elapsed Waiting ) ; } else return null ; }",
    "label": 1
  },
  {
    "text_1": "add a prebuilt classifier to the list for use in the ensemble",
    "text_2": "public void add Pre Built Classifier ( Classifier c ) { m pre Built Classifiers . add ( c ) ; }",
    "label": 1
  },
  {
    "text_1": "display all field values",
    "text_2": "private void display Values ( ) { log ( STRING , Project . MSG INFO ) ; log ( STRING + this . spec ) ; log ( STRING + get Spec Absolute Path ( ) ) ; log ( STRING + get Serialized Spec Absolute Path ( ) ) ; log ( STRING + this . spec dir ) ; log ( STRING + this . cup NUM srcdir ) ; log ( STRING + this . classpath ) ; log ( STRING + this . algorithm ) ; log ( STRING + this . verbose ) ; log ( STRING + this . par set able ) ; log ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "call back methods used by sax loader . startelement ( ) and endelement ( )",
    "text_2": "@ Override public void start Element ( final String namespace URI , final String local Name , final String q Name , final Attributes atts ) throws SAX Exception { Object object To Load = null ; if ( open Nodes . size ( ) = = NUM ) object To Load = root Object ; else object To Load = create Child ( q Name , atts ) ; if ( object To Load ! = null ) { if ( atts . get Index ( STRING ) < NUM ) Object Get Setter . set ( object To Load , STRING , q Name ) ; Object Get Setter . set All ( object To Load , atts ) ; } open Nodes . push ( new Stacked Object ( object To Load ) ) ; }",
    "label": 1
  },
  {
    "text_1": "tests fix for bug 18 0 41 - server - side prepared statements don ' t cause truncation exceptions to be thrown .",
    "text_2": "public void test Bug NUM ( ) throws Exception { if ( version Meets Minimum ( NUM , NUM ) ) { create Table ( STRING , STRING ) ; Properties props = new Properties ( ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; Connection trunc Conn = null ; Prepared Statement stm = null ; try { trunc Conn = get Connection With Props ( props ) ; stm = trunc Conn . prepare Statement ( STRING ) ; stm . set Int ( NUM , NUM ) ; stm . set String ( NUM , STRING ) ; stm . execute Update ( ) ; fail ( STRING ) ; } catch ( Data Truncation trunc Ex ) { } finally { if ( trunc Conn ! = null ) { trunc Conn . close ( ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "adds the tree update .",
    "text_2": "public void add Tree Update ( SLD Tree Updated Interface sld Tree ) { tree Update List . add ( sld Tree ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new column with the provided arguments .",
    "text_2": "public static Column column ( final String id , final String title , final int width , final int double Precision ) { return new Column ( id , title , Math . max ( width , title . length ( ) ) , double Precision ) ; }",
    "label": 1
  },
  {
    "text_1": "builds an intent that launches a script in a terminal .",
    "text_2": "public static Intent build Start In Terminal Intent ( File script ) { final Component Name component Name = Constants . SL NUM A SERVICE LAUNCHER COMPONENT NAME ; Intent intent = new Intent ( ) ; intent . set Component ( component Name ) ; intent . set Action ( Constants . ACTION LAUNCH FOREGROUND SCRIPT ) ; intent . put Extra ( Constants . EXTRA SCRIPT PATH , script . get Absolute Path ( ) ) ; return intent ; }",
    "label": 1
  },
  {
    "text_1": "removes a particular map mouse mode from the mouse mode list .",
    "text_2": "public void remove Mouse Mode ( Map Mouse Mode med ) { boolean need To Adjust Active Mode = BOOL ; if ( med = = null ) { return ; } if ( med . equals ( active Mouse Mode ) ) { need To Adjust Active Mode = BOOL ; set Inactive ( med ) ; } for ( Map Mouse Mode check MM : mouse Modes ) { if ( med . equals ( check MM ) ) { med . remove All Map Mouse Listeners ( ) ; } else if ( need To Adjust Active Mode ) { set Active ( check MM ) ; need To Adjust Active Mode = BOOL ; } } mouse Modes . remove ( med ) ; fire Property Change ( Mouse Modes Property , null , mouse Modes ) ; }",
    "label": 1
  },
  {
    "text_1": "check the format of tls pre master secret . to avoid vulnerabilities described by section 7 . 4 . 7 . 1 , rfc 5 246 , treating incorrectly formatted message blocks and / or mismatched version numbers in a manner indi st ing ui sh able from correctly formatted rsa blocks . rfc 5 246 describes the approach as : 1 . generate a string r of 48 random bytes 2 . decrypt the message to recover the plaintext m 3 . if the pkcs 1 padding is not correct , or the length of message m is not exactly 48 bytes : pre master secret = r else if clien thel lo . client version < = tls 1 . 0 , and version number check is explicitly disabled : pre master secret = m else if m [ 0 . . 1 ] ! = clien thel lo . client version : pre master secret = r else : pre master secret = m note that 2 should have completed before the call to this method .",
    "text_2": "public static byte [ ] check Tls Pre Master Secret Key ( int client Version , int server Version , Secure Random random , byte [ ] encoded , boolean is Fail Over ) { if ( random = = null ) { random = JCA Util . get Secure Random ( ) ; } byte [ ] replacer = new byte [ NUM ] ; random . next Bytes ( replacer ) ; if ( ! is Fail Over & & ( encoded ! = null ) ) { if ( encoded . length ! = NUM ) { return replacer ; } int encoded Version = ( ( encoded [ NUM ] & NUM ) < < NUM ) | ( encoded [ NUM ] & NUM ) ; if ( client Version ! = encoded Version ) { if ( client Version > NUM | | server Version ! = encoded Version ) { encoded = replacer ; } } return encoded ; } return replacer ; }",
    "label": 1
  },
  {
    "text_1": "processes a removed node and updates the references list accordingly .",
    "text_2": "private boolean process Removed Node ( final I Navi View Node node ) { if ( node instanceof I Navi Code Node ) { final I Navi Code Node cnode = ( I Navi Code Node ) node ; try { final I Navi Function target Function = cnode . get Parent Function ( ) ; if ( m node Counter . contains Key ( target Function ) ) { final int new Counter = m node Counter . get ( target Function ) - NUM ; if ( new Counter = = NUM ) { m node Counter . remove ( target Function ) ; final Set < C Cross Reference > to Delete = new Hash Set < C Cross Reference > ( ) ; for ( final C Cross Reference reference : m cross References ) { if ( reference . get Called Function ( ) = = target Function ) { to Delete . add ( reference ) ; } } m cross References . remove All ( to Delete ) ; return BOOL ; } else { m node Counter . put ( target Function , new Counter ) ; } } } catch ( final Maybe Null Exception exception ) { } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "create float version from point 2 d object , where the x , y values are expected to be decimal degrees .",
    "text_2": "public Float ( Point NUM D pt NUM D ) { set Lat Lon ( pt NUM D . get Y ( ) , pt NUM D . get X ( ) , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "execute a \" heapify downwards \" aka \" si ft down \" . used in deletions .",
    "text_2": "protected boolean heapify Down Comparator ( final int ipos , Object cur ) { int pos = ipos ; final int half = size > > > NUM ; while ( pos < half ) { int min = pos ; Object best = cur ; final int l child = ( pos < < NUM ) + NUM ; Object left = queue [ l child ] ; if ( comparator . compare ( best , left ) > NUM ) { min = l child ; best = left ; } final int r child = l child + NUM ; if ( r child < size ) { Object right = queue [ r child ] ; if ( comparator . compare ( best , right ) > NUM ) { min = r child ; best = right ; } } if ( min = = pos ) { break ; } queue [ pos ] = best ; pos = min ; } queue [ pos ] = cur ; return ( pos ! = ipos ) ; }",
    "label": 1
  },
  {
    "text_1": "the natural log of the probability density function of the distribution",
    "text_2": "public static double log Pdf ( double x , double m , double sd ) { double a = NUM / ( Math . sqrt ( NUM * Math . PI ) * sd ) ; double b = - ( x - m ) * ( x - m ) / ( NUM * sd * sd ) ; return Math . log ( a ) + b ; }",
    "label": 1
  },
  {
    "text_1": "update the processor duration .",
    "text_2": "public void update Processor Duration ( Duration duration ) { processor duration = Optional . of ( duration ) ; }",
    "label": 1
  },
  {
    "text_1": "replace all occurrences in the original string of the old string with the new string .",
    "text_2": "public static String replace All ( String input , String regular Expression , String replacement ) { return input . replace All ( regular Expression , replacement ) ; }",
    "label": 1
  },
  {
    "text_1": "map xml type to java",
    "text_2": "@ Override public Set < Location > unmarshal ( Locations Type locations Type ) { Set < Location > locations = new Linked Hash Set < Location > ( ) ; locations . add All ( locations Type . get R ps Blast Locations ( ) ) ; locations . add All ( locations Type . get Hmmer NUM Locations ( ) ) ; locations . add All ( locations Type . get Hmmer NUM Locations ( ) ) ; locations . add All ( locations Type . get Super Family Hmmer NUM Locations ( ) ) ; locations . add All ( locations Type . get Finger Prints Locations ( ) ) ; locations . add All ( locations Type . get Blast Pro Dom Locations ( ) ) ; locations . add All ( locations Type . get Pattern Scan Locations ( ) ) ; locations . add All ( locations Type . get Profile Scan Locations ( ) ) ; locations . add All ( locations Type . get Ph ob ius Locations ( ) ) ; locations . add All ( locations Type . get Coils Locations ( ) ) ; locations . add All ( locations Type . get Pan ther Locations ( ) ) ; locations . add All ( locations Type . get Signal P Locations ( ) ) ; locations . add All ( locations Type . get TM HMM Locations ( ) ) ; return locations ; }",
    "label": 1
  },
  {
    "text_1": "construct a refresh er for the given scene .",
    "text_2": "public Refresher ( GL Scene scene ) { Preconditions . check Not Null ( scene ) ; this . scene = scene ; }",
    "label": 1
  },
  {
    "text_1": "copies all links from the source element to the destination element .",
    "text_2": "private Cn A Tree Element unify Links ( Cn A Tree Element source Element , Cn A Tree Element destination Element ) throws Command Exception { for ( Cn A Link link Down : source Element . get Links Down ( ) ) { create Link ( destination Element , link Down . get Dependency ( ) , link Down . get Relation Id ( ) ) ; } for ( Cn A Link link Up : source Element . get Links Up ( ) ) { create Link ( link Up . get Dependant ( ) , destination Element , link Up . get Relation Id ( ) ) ; } return destination Element ; }",
    "label": 1
  },
  {
    "text_1": "return a substring containing no semicolons .",
    "text_2": "public String byte String No Semicolon ( ) { String Builder retval = new String Builder ( ) ; try { while ( BOOL ) { char next = look Ahead ( NUM ) ; if ( next = = STRING | | next = = STRING | | next = = STRING | | next = = STRING ) { break ; } else { consume ( NUM ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { return retval . to String ( ) ; } return retval . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "103 this method should return , if it knows , the number of bytes 104 that will be decoded . many formats such as uu encoding provide 105 this information . by default we return the maximum bytes that 106 could have been encoded on the line . 107",
    "text_2": "protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "create a copy of this mapping with the given host port",
    "text_2": "public Docker Port Mapping with Host Port ( int host Port ) { Docker Port Mapping new Mapping = new Docker Port Mapping ( ) ; new Mapping . protocol = protocol ; new Mapping . container Port = container Port ; new Mapping . host Ip = host Ip ; new Mapping . host Port = String . value Of ( host Port ) ; return new Mapping ; }",
    "label": 1
  },
  {
    "text_1": "make a plugin available in an alternate name . this is an internal api and not for public use",
    "text_2": "boolean alias ( String src , String target ) { if ( src = = null ) return BOOL ; Plugin Holder < T > a = registry . get ( src ) ; if ( a = = null ) return BOOL ; Plugin Holder < T > b = registry . get ( target ) ; if ( b ! = null ) return BOOL ; registry . put ( target , a ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "acquires a commit from the pool .",
    "text_2": "public Server Commit acquire ( Operation Entry entry , Server Session Context session , long timestamp ) { Server Commit commit = pool . poll ( ) ; if ( commit = = null ) { commit = new Server Commit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }",
    "label": 1
  },
  {
    "text_1": "calculate the placement and size of the popup portion of the combo box based on the combo box location and the enclosing screen bounds . if no transformations are required , then the returned rectangle will have the same values as the parameters .",
    "text_2": "protected Rectangle compute Popup Bounds ( int px , int py , int pw , int ph ) { Toolkit toolkit = Toolkit . get Default Toolkit ( ) ; Rectangle screen Bounds ; Graphics Configuration gc = combo Box . get Graphics Configuration ( ) ; Point p = new Point ( ) ; Swing Utilities . convert Point From Screen ( p , combo Box ) ; if ( gc ! = null ) { Insets screen Insets = toolkit . get Screen Insets ( gc ) ; screen Bounds = gc . get Bounds ( ) ; screen Bounds . width - = ( screen Insets . left + screen Insets . right ) ; screen Bounds . height - = ( screen Insets . top + screen Insets . bottom ) ; screen Bounds . x + = ( p . x + screen Insets . left ) ; screen Bounds . y + = ( p . y + screen Insets . top ) ; } else { screen Bounds = new Rectangle ( p , toolkit . get Screen Size ( ) ) ; } Rectangle rect = new Rectangle ( px , py , pw , ph ) ; if ( py + ph > screen Bounds . y + screen Bounds . height & & ph < screen Bounds . height ) { rect . y = - rect . height ; } return rect ; }",
    "label": 1
  },
  {
    "text_1": "method to update current position of the slider",
    "text_2": "public void update Slider ( final double p , final boolean n ) { check Widget ( ) ; double percentage = p ; if ( step ! = null ) { percentage = Math . round ( percentage / step ) * step ; } this . notify = n ; if ( percentage < NUM ) { percentage = NUM ; } else if ( percentage > NUM ) { percentage = NUM ; } final int useful Width = get Client Area ( ) . width - thumb Width ; final int width = ( int ) Math . round ( useful Width * percentage ) ; move Thumb Horizontally ( width ) ; previous Position = percentage ; this . notify = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "todo this is a temporary workaround for https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 8 3600 and https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 85 293",
    "text_2": "public static char [ ] fix NUM ( char [ ] signature ) { if ( signature = = null | | signature . length < NUM ) return signature ; return Signature . remove Capture ( signature ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a micro services runner instance which will be used for deploying micro services . allows specifying ports on which the micro services in this micro services runner are deployed .",
    "text_2": "public Micro services Runner ( int . . . ports ) { configure Transport ( ports ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new instance of the listener support .",
    "text_2": "public Io Service Listener Support ( Io Service service ) { if ( service = = null ) { throw new Illegal Argument Exception ( STRING ) ; } this . service = service ; }",
    "label": 1
  },
  {
    "text_1": "create a new named column projection .",
    "text_2": "public Named Column Projection ( String [ ] names , boolean include ) { m names = new Hash Set ( ) ; for ( int i = NUM ; i < names . length ; + + i ) m names . add ( names [ i ] ) ; m include = include ; }",
    "label": 1
  },
  {
    "text_1": "walks the basic block tree in depth - first order , calling the visitor method once for every block . this depth - first walk may be run forward from the method entry point or backwards from the method exit points .",
    "text_2": "public void for Each Block Depth First ( boolean reverse , Ssa Basic Block . Visitor v ) { Bit Set visited = new Bit Set ( blocks . size ( ) ) ; Stack < Ssa Basic Block > stack = new Stack < Ssa Basic Block > ( ) ; Ssa Basic Block root Block = reverse ? get Exit Block ( ) : get Entry Block ( ) ; if ( root Block = = null ) { return ; } stack . add ( null ) ; stack . add ( root Block ) ; while ( stack . size ( ) > NUM ) { Ssa Basic Block cur = stack . pop ( ) ; Ssa Basic Block parent = stack . pop ( ) ; if ( ! visited . get ( cur . get Index ( ) ) ) { Bit Set children = reverse ? cur . get Predecessors ( ) : cur . get Successors ( ) ; for ( int i = children . next Set Bit ( NUM ) ; i > = NUM ; i = children . next Set Bit ( i + NUM ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . get Index ( ) ) ; v . visit Block ( cur , parent ) ; } } }",
    "label": 1
  },
  {
    "text_1": "init the common properties , including filter , level , formatter , and encoding",
    "text_2": "void init Properties ( String default Level , String default Filter , String default Formatter , String default Encoding ) { Log Manager manager = Log Manager . get Log Manager ( ) ; final String filter Name = manager . get Property ( prefix + STRING ) ; if ( filter Name ! = null ) { try { filter = ( Filter ) get Customize Instance ( filter Name ) ; } catch ( Exception e1 ) { print Invalid Prop Message ( STRING , filter Name , e1 ) ; filter = ( Filter ) get Default Instance ( default Filter ) ; } } else { filter = ( Filter ) get Default Instance ( default Filter ) ; } String level Name = manager . get Property ( prefix + STRING ) ; if ( level Name ! = null ) { try { level = Level . parse ( level Name ) ; } catch ( Exception e ) { print Invalid Prop Message ( STRING , level Name , e ) ; level = Level . parse ( default Level ) ; } } else { level = Level . parse ( default Level ) ; } final String formatter Name = manager . get Property ( prefix + STRING ) ; if ( formatter Name ! = null ) { try { formatter = ( Formatter ) get Customize Instance ( formatter Name ) ; } catch ( Exception e ) { print Invalid Prop Message ( STRING , formatter Name , e ) ; formatter = ( Formatter ) get Default Instance ( default Formatter ) ; } } else { formatter = ( Formatter ) get Default Instance ( default Formatter ) ; } final String encoding Name = manager . get Property ( prefix + STRING ) ; try { internal Set Encoding ( encoding Name ) ; } catch ( Unsupported Encoding Exception e ) { print Invalid Prop Message ( STRING , encoding Name , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a string representation of this object .",
    "text_2": "public String to String ( ) { String Buffer sb = new String Buffer ( STRING ) ; if ( type ! = SET CONSTRAINTS ) { sb . append ( type = = AS IS ? STRING : STRING ) ; } sb . append ( loader ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < context Elements . length ; i + + ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( context Elements [ i ] ) ; } if ( principals = = null ) { sb . append ( STRING ) ; } else { sb . append ( STRING ) ; for ( int i = NUM ; i < principals . length ; i + + ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( principals [ i ] ) ; } sb . append ( STRING ) ; } for ( int i = NUM ; i < permissions . length ; i + + ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "writes a guid value .",
    "text_2": "private void write GUID Value ( Byte Buffer buffer , Object value ) throws IO Exception { Matcher m = GUID PATTERN . matcher ( to Char Sequence ( value ) ) ; if ( ! m . matches ( ) ) { throw new IO Exception ( with Error Context ( STRING + value ) ) ; } Byte Buffer orig Buffer = null ; byte [ ] tmp Buf = null ; if ( buffer . order ( ) ! = Byte Order . BIG ENDIAN ) { orig Buffer = buffer ; tmp Buf = new byte [ NUM ] ; buffer = Byte Buffer . wrap ( tmp Buf ) ; } Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; if ( tmp Buf ! = null ) { Byte Util . swap NUM Bytes ( tmp Buf , NUM ) ; Byte Util . swap NUM Bytes ( tmp Buf , NUM ) ; Byte Util . swap NUM Bytes ( tmp Buf , NUM ) ; orig Buffer . put ( tmp Buf ) ; } }",
    "label": 1
  },
  {
    "text_1": "compute a list of patches to turn text 1 into text 2 . a set of diffs will be computed .",
    "text_2": "public Linked List < Patch > patch make ( String text NUM , String text NUM ) { if ( text NUM = = null | | text NUM = = null ) { throw new Illegal Argument Exception ( STRING ) ; } Linked List < Diff > diffs = diff main ( text NUM , text NUM , BOOL ) ; if ( diffs . size ( ) > NUM ) { diff cleanup Semantic ( diffs ) ; diff cleanup Efficiency ( diffs ) ; } return patch make ( text NUM , diffs ) ; }",
    "label": 1
  },
  {
    "text_1": "default implementation just returns the copy of the bytes .",
    "text_2": "@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws Ldap Exception { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , NUM , len ) ; return copy ; }",
    "label": 1
  },
  {
    "text_1": "returns true if there is a media entity with the type of \" photo \"",
    "text_2": "static public boolean has Photo ( Tweet tweet ) { return get Photo Entity ( tweet ) ! = null ; }",
    "label": 1
  },
  {
    "text_1": "create an enumerated distribution using the given probability mass function enumeration .",
    "text_2": "public Enumerated Distribution ( final List < Pair < T , Double > > pmf ) throws Math Illegal Argument Exception { singletons = new Array List < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = NUM ; i < pmf . size ( ) ; i + + ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . get Key ( ) ) ; final double p = sample . get Value ( ) ; probs [ i ] = p ; } probabilities = check And Normalize ( probs ) ; cumulative Probabilities = new double [ probabilities . length ] ; double sum = NUM ; for ( int i = NUM ; i < probabilities . length ; i + + ) { sum + = probabilities [ i ] ; cumulative Probabilities [ i ] = sum ; } }",
    "label": 1
  },
  {
    "text_1": "recursive . same as pre - order traversal . split data and create a queue of string values first . each time , poll a node from the queue , create the current root . then build left and right subtree recursively .",
    "text_2": "public Tree Node deserialize ( String data ) { Deque < String > nodes = new Linked List < > ( ) ; nodes . add All ( Arrays . as List ( data . split ( SPLI TER ) ) ) ; return build Tree ( nodes ) ; }",
    "label": 1
  },
  {
    "text_1": "creates pseudo function selector for given function and expression .",
    "text_2": "@ Suppress Warnings ( STRING ) public Pseudo Function Selector ( String function Name , String expression ) { super ( Type . PSEUDO FUNCTION ) ; this . pseudo Function = ( Pseudo Function < E > ) lookup Pseudo Function ( function Name . trim ( ) ) ; this . expression = expression ; this . parsed Expression = pseudo Function . parse Expression ( expression ) ; }",
    "label": 1
  },
  {
    "text_1": "this method retrieves data using http or https protocol and ' get ' method .",
    "text_2": "protected byte [ ] http Get ( final String url ) { Http Get http Request = null ; Http Response http Response = null ; Closeable Http Client client = null ; try { final URI uri = new URI ( url . trim ( ) ) ; http Request = new Http Get ( uri ) ; if ( content Type ! = null ) { http Request . set Header ( CONTENT TYPE , content Type ) ; } client = get Http Client ( url ) ; http Response = get Http Response ( client , http Request , url ) ; final byte [ ] returned Bytes = read Http Response ( url , http Response ) ; return returned Bytes ; } catch ( URI Syntax Exception e ) { throw new DSS Exception ( e ) ; } finally { try { if ( http Request ! = null ) { http Request . release Connection ( ) ; } if ( http Response ! = null ) { Entity Utils . consume Quietly ( http Response . get Entity ( ) ) ; } } finally { close Client ( client ) ; } } }",
    "label": 1
  },
  {
    "text_1": "adds wheel changing listener",
    "text_2": "public void add Changing Listener ( On Wheel Changed Listener listener ) { changing Listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "trace an object , calling the appropriate visitor method",
    "text_2": "private void trace Object ( Object Reference object , boolean root ) { if ( VERBOSE ) { Trace . trace ( Item . SAN ITY , STRING , Object Model . get String ( object ) ) ; } if ( object . is Null ( ) ) return ; boolean marked = black Set . contains ( object ) ; if ( ! marked ) { black Set . add ( object ) ; mark Stack . add ( object ) ; } visitor . visit Object ( object , root , marked ) ; }",
    "label": 1
  },
  {
    "text_1": "give subclasses a chance to add extensions .",
    "text_2": "protected void init ( final I Datatype URI Resolver resolver , final I Lexicon Configuration < Bigdata Value > config , final Collection < I Extension < ? extends Bigdata Value > > extensions ) { }",
    "label": 1
  },
  {
    "text_1": "cancel a running statement .",
    "text_2": "void cancel Statement ( String session Id , int statement Id ) { for ( Tcp Server Thread c : New . array List ( running ) ) { if ( c ! = null ) { c . cancel Statement ( session Id , statement Id ) ; } } }",
    "label": 1
  },
  {
    "text_1": "attempts to prepare the request for a retry . if there are no more attempts remaining in the request ' s retry policy , a timeout exception is thrown .",
    "text_2": "private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }",
    "label": 1
  },
  {
    "text_1": "parse a range which use a \" : \" as delimiter",
    "text_2": "private Uid Range parse Uid Range ( String range ) throws Decoding Exception { int pos = range . index Of ( STRING ) ; try { if ( pos = = - NUM ) { if ( range . length ( ) = = NUM & & range . char At ( NUM ) = = STRING ) { return new Uid Range ( Message Uid . MAX VALUE ) ; } else { long value = parse Unsigned Integer ( range ) ; return new Uid Range ( Message Uid . of ( value ) ) ; } } else { long val NUM = parse Unsigned Integer ( range . substring ( NUM , pos ) ) ; long val NUM = parse Unsigned Integer ( range . substring ( pos + NUM ) ) ; if ( val NUM = = Long . MAX VALUE & & val NUM = = Long . MAX VALUE ) { return new Uid Range ( Message Uid . MAX VALUE ) ; } else if ( val NUM < = val NUM ) { return new Uid Range ( Message Uid . of ( val NUM ) , Message Uid . of ( val NUM ) ) ; } else if ( val NUM = = Long . MAX VALUE ) { return new Uid Range ( Message Uid . of ( val NUM ) , Message Uid . MAX VALUE ) ; } else { return new Uid Range ( Message Uid . of ( val NUM ) , Message Uid . of ( val NUM ) ) ; } } } catch ( Number Format Exception e ) { throw new Decoding Exception ( Human Readable Text . INVALID MESSAGE SET , STRING , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "cancels this latency request .",
    "text_2": "public void cancel ( ) { synchronized ( lock ) { if ( this . latency = = NO TARGET ) { throw new Illegal State Exception ( STRING + STRING ) ; } if ( ! requests . remove ( this ) ) { throw new Internal Error ( STRING + this + STRING ) ; } if ( requests . is Empty ( ) ) requests = null ; this . latency = NO TARGET ; adjust Latency If Needed ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "this method was generated by mybatis generator . this method corresponds to the database table step",
    "text_2": "public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "the introduction of i allocation contexts has added some complexity to the older concept of a free list . with allocation contexts it is possibly for allocator to have free space available but this being restricted to a specific allocation context . in addition to the standard free allocation search we want to add a \" density \" restriction for small slots to encourage the aggregation of writes ( by increasing the likelihood of sibling slot allocation ) . there is some \" do what i mean \" complexity here , with difficulty in determining a good rule to identify an initial allocation point . there is a danger of significantly reducing the allocation efficiency of short transactions if we too na ively check committed bit density . we should only do this when identifying the initial allocation , and when the alloc index is incremented .",
    "text_2": "public int alloc ( final RW Store store , final int size , final I Allocation Context context ) { try { if ( size < = NUM ) throw new Illegal Argument Exception ( STRING + size ) ; if ( size > m size ) throw new Illegal Argument Exception ( STRING + m size + STRING + size + STRING ) ; if ( m free Bits = = NUM ) { throw new Illegal State Exception ( STRING + m size + STRING ) ; } int addr = - NUM ; if ( m size < = m store . c Small Slot ) { return alloc From Index ( size ) ; } final Iterator < Alloc Block > iter = m alloc Blocks . iterator ( ) ; int count = - NUM ; while ( addr = = - NUM & & iter . has Next ( ) ) { count + + ; final Alloc Block block = iter . next ( ) ; check Block ( block ) ; addr = block . alloc ( m size ) ; } if ( addr ! = - NUM ) { addr + = NUM ; if ( - - m free Bits = = NUM ) { if ( s is log Trace ) log . trace ( STRING ) ; remove From Free List ( ) ; if ( m free List . size ( ) > NUM ) { if ( s is log Debug ) { final Fixed Allocator nxt = ( Fixed Allocator ) m free List . get ( NUM ) ; log . debug ( STRING + nxt . get Summary Stats ( ) ) ; } } } addr + = ( count * NUM * m bit Size ) ; final int value = - ( ( m index < < RW Store . OFFSET BITS ) + addr ) ; if ( m stats Bucket ! = null ) { m stats Bucket . allocate ( size ) ; } return value ; } else { String Builder sb = new String Builder ( ) ; sb . append ( STRING + m free Bits + STRING ) ; for ( Alloc Block ab : m alloc Blocks ) { sb . append ( ab . show ( ) + STRING ) ; } log . error ( sb ) ; return NUM ; } } finally { if ( s is log Debug ) check Bits ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "calculate wit dh , height and region values here",
    "text_2": "@ Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { m Width = Measure Spec . get Size ( width Measure Spec ) ; m Height = Measure Spec . get Size ( height Measure Spec ) ; int min Side = Math . min ( m Width , m Height ) ; m Width = min Side ; m Height = min Side ; m Current Progress Position = calculate Current Position From Current Seconds ( m Current Seconds ) ; object Animator Progress . set Float Values ( m Current Progress Position / m Width , NUM ) ; object Animator Progress . set Duration ( ( m Max Seconds - m Current Seconds ) * NUM ) ; if ( m Bitmap Cover Image ! = null ) scale Cover Bitmap ( m Bitmap Cover Image ) ; rect F Empty Progress . set ( NUM , m Height - m Progress Height , m Width , m Height ) ; m Drawable Bottom Shadow . set Bounds ( NUM , ( NUM * m Height ) / NUM , m Width , m Height ) ; if ( start Requested ) { start Requested = BOOL ; start ( ) ; } super . on Measure ( width Measure Spec , height Measure Spec ) ; }",
    "label": 1
  },
  {
    "text_1": "create a new float column .",
    "text_2": "public Float Column ( int nrows , int capacity , float default Value ) { super ( float . class , new Float ( default Value ) ) ; if ( capacity < nrows ) { throw new Illegal Argument Exception ( STRING ) ; } m values = new float [ capacity ] ; Arrays . fill ( m values , default Value ) ; m size = nrows ; }",
    "label": 1
  },
  {
    "text_1": "records that a particular interval is potentially available for reuse .",
    "text_2": "void free Interval ( Spill Location Interval i ) { free Intervals . add ( i ) ; }",
    "label": 1
  },
  {
    "text_1": "executes task r in the caller ' s thread , unless the executor has been shut down , in which case the task is discarded .",
    "text_2": "public void rejected Execution ( Runnable r , Thread Pool Executor e ) { if ( ! e . is Shutdown ( ) ) { r . run ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a folder with a given path , including all necessary nonexistent parent directories . if a folder is already present , no action is performed .",
    "text_2": "public static void create Destination Folder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; }",
    "label": 1
  },
  {
    "text_1": "fills a buffer by reading data from a socket .",
    "text_2": "@ Nullable private static String read ( @ Non Null Socket Channel socket , @ Non Null byte [ ] buffer ) throws IO Exception { Byte Buffer buf = Byte Buffer . wrap ( buffer , NUM , buffer . length ) ; while ( buf . position ( ) ! = buf . limit ( ) ) { int count ; count = socket . read ( buf ) ; if ( count < NUM ) { throw new IO Exception ( STRING ) ; } } try { return new String ( buffer , NUM , buf . position ( ) , Adb Helper . DEFAULT ENCODING ) ; } catch ( Unsupported Encoding Exception e ) { return null ; } }",
    "label": 1
  },
  {
    "text_1": "create a dialog that filters for files with the specified extensions .",
    "text_2": "public J File Data Store Chooser ( Shell parent , int style , final String [ ] extensions ) { this ( parent , style , associations ( Arrays . as List ( extensions ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a reference to the manifest",
    "text_2": "public void add Reference ( Message Part reference ) { references . add ( reference ) ; }",
    "label": 1
  },
  {
    "text_1": "generates a simple exemplar of this class to test serialization .",
    "text_2": "public static Manual Lag Graph serializable Instance ( ) { return new Manual Lag Graph ( Manual Lag Graph Params . serializable Instance ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "loads the modules that belong to the target .",
    "text_2": "private void load Target Modules ( ) { for ( final Module module : target . get Modules ( ) ) { module . add Listener ( module Keeper Listener ) ; modules . add ( module ) ; if ( ! module . is Loaded ( ) ) { try { module . load ( ) ; } catch ( final Couldnt Load Data Exception e ) { error Loading Module ( module , e ) ; return ; } } } step + + ; }",
    "label": 1
  },
  {
    "text_1": "negate ( ) for a negative bigdecimal",
    "text_2": "public void test Negate Negative ( ) { String a = STRING ; int a Scale = NUM ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal c Number = new Big Decimal ( new Big Integer ( c ) , c Scale ) ; assert Equals ( STRING , c Number , a Number . negate ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "get proper string for an an object including arrays with upto one dimension of arrays .",
    "text_2": "public static void object String Non Recursive ( @ Un retained Object obj , String Builder sb ) { if ( obj instanceof Object [ ] ) { sb . append ( STRING ) ; boolean first = BOOL ; for ( Object o : ( Object [ ] ) obj ) { if ( ! first ) { sb . append ( STRING ) ; sb . append ( o ) ; } else { first = BOOL ; object String With Bytes ( o , sb ) ; } } sb . append ( STRING ) ; } else { object String With Bytes ( obj , sb ) ; } }",
    "label": 1
  },
  {
    "text_1": "send file content callback function , be called only once when the file uploaded",
    "text_2": "public int send ( Output Stream out ) throws IO Exception { out . write ( this . file Buff , this . offset , this . length ) ; return NUM ; }",
    "label": 1
  },
  {
    "text_1": "read window configuration from properties .",
    "text_2": "private void read From Properties ( final Properties props , final boolean default Minimized , final int default X , final int default Y , final boolean default Visible ) { minimized = Boolean . parse Boolean ( props . get Property ( STRING + name + STRING , Boolean . to String ( default Minimized ) ) ) ; visible = Boolean . parse Boolean ( props . get Property ( STRING + name + STRING , Boolean . to String ( default Visible ) ) ) ; x = Integer . parse Int ( props . get Property ( STRING + name + STRING , Integer . to String ( default X ) ) ) ; y = Integer . parse Int ( props . get Property ( STRING + name + STRING , Integer . to String ( default Y ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a member to this base type .",
    "text_2": "void add Member ( final Type Member member ) { Preconditions . check Not Null ( member , STRING ) ; Preconditions . check Argument ( member . get Parent Type ( ) = = this , STRING ) ; members . add ( member ) ; }",
    "label": 1
  },
  {
    "text_1": "convenience method for generating a method signature in human readable form .",
    "text_2": "public static String convert Method Signature ( String class Name , String method Name , String method Sig , String pkg Name ) { String Builder args = new String Builder ( ) ; Signature Converter converter = new Signature Converter ( method Sig ) ; converter . skip ( ) ; args . append ( STRING ) ; while ( converter . get First ( ) ! = STRING ) { if ( args . length ( ) > NUM ) { args . append ( STRING ) ; } args . append ( shorten ( pkg Name , converter . parse Next ( ) ) ) ; } converter . skip ( ) ; args . append ( STRING ) ; String Builder result = new String Builder ( ) ; result . append ( class Name ) ; result . append ( STRING ) ; result . append ( method Name ) ; result . append ( args . to String ( ) ) ; return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "turns a field access or method call into a call to an accessor method . reuses existing accessors based on name mang ling ( see create accessor name )",
    "text_2": "public static void create Accessor Method ( Soot Method container , Stmt stmt ) { Body container Body = container . get Active Body ( ) ; soot . util . Chain container Stmts = container Body . get Units ( ) ; if ( ! container Stmts . contains ( stmt ) ) throw new Runtime Exception ( ) ; if ( stmt . contains Invoke Expr ( ) ) { create Invoke Accessor ( container , stmt ) ; } else if ( stmt instanceof Assign Stmt ) { Assign Stmt as = ( Assign Stmt ) stmt ; Field Ref ref ; if ( as . get Left Op ( ) instanceof Field Ref ) { ref = ( Field Ref ) as . get Left Op ( ) ; create Set Accessor ( container , as , ref ) ; } else if ( as . get Right Op ( ) instanceof Field Ref ) { ref = ( Field Ref ) as . get Right Op ( ) ; create Get Accessor ( container , as , ref ) ; } else { throw new Runtime Exception ( STRING ) ; } } else throw new Runtime Exception ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "write a utf string with a length to a stream .",
    "text_2": "static void write UTF ( Output Stream out , String str ) throws IO Exception { for ( int i = NUM , len = str . length ( ) ; i < len ; i + + ) { int c = str . char At ( i ) ; if ( ( c > = NUM ) & & ( c < = NUM ) ) { out . write ( c ) ; } else { if ( c > NUM ) { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } else { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "writes a character as a decimal escape . hex escapes are smaller than the decimal version , but netscape didn ' t support hex escapes until 4 . 7 . 4 .",
    "text_2": "static private void write Dec Ref ( Writer out , char ch ) throws IO Exception { if ( ch = = STRING ) { out . write ( STRING ) ; return ; } out . write ( STRING ) ; int i = ( int ) ch ; if ( i > NUM ) { out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + i ) ; } else if ( i > NUM ) { out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + i ) ; } else { out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + i ) ; } out . write ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "unzips the specified zip file to a temp folder",
    "text_2": "public static File unzip To Temp Folder ( File zip File ) { String zip Filename = zip File . get Name ( ) ; String temp Folder Prefix = zip Filename . substring ( NUM , zip Filename . last Index Of ( STRING ) ) ; File temp Folder = create Temp Folder ( temp Folder Prefix ) ; try { PU Zip Utils . unzip ( zip File , temp Folder ) ; return temp Folder ; } catch ( Exception e ) { try { File Utils . delete File Or Directory ( temp Folder ) ; } catch ( Runtime Exception ex ) { logger . debug ( STRING + temp Folder , ex ) ; } throw new Runtime Exception ( STRING + zip File + STRING + temp Folder , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "turns output of ' show warnings ' into jdbc sql warning instances . if ' for trun cat ionon ly ' is true , only looks for truncation warnings , and actually throws datat run cation as an exception .",
    "text_2": "static SQL Warning convert Show Warnings To SQL Warnings ( Connection connection ) throws SQL Exception { return convert Show Warnings To SQL Warnings ( connection , NUM , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "initializes the parameters of this circuit , all parameters have been set to 0 right before calling this",
    "text_2": "public abstract void init Parameters ( int [ ] a Circuit Data , I Redstone Circuit Block a Redstone Circuit Block ) ;",
    "label": 1
  },
  {
    "text_1": "retuns a darker color from a specified color by the factor .",
    "text_2": "public static int darker ( int color , float factor ) { int a = Color . alpha ( color ) ; int r = Color . red ( color ) ; int g = Color . green ( color ) ; int b = Color . blue ( color ) ; return Color . argb ( a , Math . max ( ( int ) ( r * factor ) , NUM ) , Math . max ( ( int ) ( g * factor ) , NUM ) , Math . max ( ( int ) ( b * factor ) , NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "blocking nack all messages which have been read from pubsub but not passed downstream . this way pubsub will send them again promp tly .",
    "text_2": "public void nack All ( Pubsub Reader < T > reader ) throws IO Exception { check State ( this . reader = = null , STRING ) ; List < String > batch Yet To Ack Ids = new Array List < > ( Math . min ( not Yet Read Ids . size ( ) , ACK BATCH SIZE ) ) ; for ( String ack Id : not Yet Read Ids ) { batch Yet To Ack Ids . add ( ack Id ) ; if ( batch Yet To Ack Ids . size ( ) > = ACK BATCH SIZE ) { long now Ms Since Epoch = now ( reader ) ; reader . nack Batch ( now Ms Since Epoch , batch Yet To Ack Ids ) ; batch Yet To Ack Ids . clear ( ) ; } } if ( ! batch Yet To Ack Ids . is Empty ( ) ) { long now Ms Since Epoch = now ( reader ) ; reader . nack Batch ( now Ms Since Epoch , batch Yet To Ack Ids ) ; } }",
    "label": 1
  },
  {
    "text_1": "remove stale iterator references from the iterator list .",
    "text_2": "private void remove Stale Iterator References ( ) { remove Stale References ( iterator Reference Queue , iterators ) ; }",
    "label": 1
  },
  {
    "text_1": "create the federated namespace .",
    "text_2": "public static void create Federated Namespace ( URI namespace , Zoo Keeper Client zkc ) throws Interrupted Exception , Zoo Keeper Client . Zoo Keeper Connection Exception , Keeper Exception { String zk Sub Namespaces Path = namespace . get Path ( ) + STRING + Z NODE SUB NAMESPACES ; Utils . zk Create Full Path Optimistic ( zkc , zk Sub Namespaces Path , new byte [ NUM ] , zkc . get Default ACL ( ) , Create Mode . PERSISTENT ) ; }",
    "label": 1
  },
  {
    "text_1": "colours the tree probabi list ically with the given migration rates",
    "text_2": "public Default Tree Colouring sample Tree Colouring ( Tree tree , Colour Change Matrix colour Change Matrix , Meta Population mp ) { Default Tree Colouring col ouring = new Default Tree Colouring ( NUM , tree ) ; double [ ] N = mp . get Population Sizes ( NUM ) ; double [ ] root Partials = prune ( tree , tree . get Root ( ) , colour Change Matrix , N ) ; double normalization = NUM ; for ( int i = NUM ; i < root Partials . length ; i + + ) { normalization + = colour Change Matrix . get Equ il ib ri um ( i ) * root Partials [ i ] ; } sample Internal Nodes ( tree , tree . get Root ( ) , colour Change Matrix ) ; sample Branch Col our ings ( col ouring , tree , tree . get Root ( ) , colour Change Matrix ) ; double log P = calculate Log Probability Density ( col ouring , tree , tree . get Root ( ) , colour Change Matrix , N ) - Math . log ( normalization ) ; col ouring . set Log Probability Density ( log P ) ; return col ouring ; }",
    "label": 1
  },
  {
    "text_1": "create a pkcs 10 cert fication request using the named provider .",
    "text_2": "public PKCS NUM Certification Request ( String signature Algorithm , X509 Name subject , Public Key key , ASN NUM Set attributes , Private Key signing Key , String provider ) throws No Such Algorithm Exception , No Such Provider Exception , Invalid Key Exception , Signature Exception { String algorithm Name = Strings . to Upper Case ( signature Algorithm ) ; DER Object Identifier sig OID = ( DER Object Identifier ) algorithms . get ( algorithm Name ) ; if ( sig OID = = null ) { try { sig OID = new DER Object Identifier ( algorithm Name ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } } if ( subject = = null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( key = = null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( no Params . contains ( sig OID ) ) { this . sig Alg Id = new Algorithm Identifier ( sig OID ) ; } else if ( params . contains Key ( algorithm Name ) ) { this . sig Alg Id = new Algorithm Identifier ( sig OID , ( ASN NUM Encodable ) params . get ( algorithm Name ) ) ; } else { this . sig Alg Id = new Algorithm Identifier ( sig OID , DER Null . INSTANCE ) ; } try { ASN NUM Sequence seq = ( ASN NUM Sequence ) ASN NUM Primitive . from Byte Array ( key . get Encoded ( ) ) ; this . req Info = new Certification Request Info ( subject , new Subject Public Key Info ( seq ) , attributes ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } Signature sig ; if ( provider = = null ) { sig = Signature . get Instance ( signature Algorithm ) ; } else { sig = Signature . get Instance ( signature Algorithm , provider ) ; } sig . init Sign ( signing Key ) ; try { sig . update ( req Info . get Encoded ( ASN NUM Encoding . DER ) ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + e ) ; } this . sig Bits = new DER Bit String ( sig . sign ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an array containing all of the elements in this deque , in proper sequence ( from first to last element ) . the returned array will be \" safe \" in that no references to it are maintained by this deque . ( in other words , this method must allocate a new array ) . the caller is thus free to modify the returned array . this method acts as bridge between array - based and collection - based apis .",
    "text_2": "public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p ! = null ; p = p . next ) a [ k + + ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "use jdbc template preparedstatement to update row in database by setting columns with conditions",
    "text_2": "public void update ( String [ ] columns , Object [ ] column Values , String [ ] conditions , Object [ ] condition Values ) throws Data Access Exception { if ( columns . length ! = column Values . length | | conditions . length ! = condition Values . length ) { logger . error ( STRING ) ; return ; } Object [ ] values = Arrays . copy Of ( column Values , column Values . length + condition Values . length ) ; System . arraycopy ( condition Values , NUM , values , column Values . length , condition Values . length ) ; final String sql = Prepared Statement Util . prepare Update Template With Column ( table Name , columns , conditions ) ; execute ( sql , values ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a query exception with a message and a cause .",
    "text_2": "public Query Exception ( String message , int error Code , Sql States sql State , Throwable cause ) { super ( message , cause ) ; this . message = message ; this . error Code = error Code ; this . sql State = sql State . get Sql State ( ) ; }",
    "label": 1
  },
  {
    "text_1": "saves the current matrix state and the touch - start point .",
    "text_2": "private void save Touch Start ( Motion Event event ) { m Saved Matrix . set ( m Matrix ) ; m Touch Start Point . set ( event . get X ( ) , event . get Y ( ) ) ; m Closest Data Set To Touch = m Chart . get Data Set By Touch Point ( event . get X ( ) , event . get Y ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method assumes that parameter p is a do it t point in map coordinates and converts it under the assumption that the map env parameter field is properly set in map coordinates and that the img height and img width are the dimensions of the map image in pixels .",
    "text_2": "public static final Image Point convert Point ( Map Point map Point , Map Envelope map Env , int img Height , int img Width ) { long image Y = Math . round ( convert Y ( map Point , map Env , img Height ) ) ; long image X = Math . round ( convert X ( map Point , map Env , img Width ) ) ; return new Image Point ( image X , image Y ) ; }",
    "label": 1
  },
  {
    "text_1": "skips the given number of names in the table buffer .",
    "text_2": "private static void skip Names ( Byte Buffer table Buffer , int count ) { for ( int i = NUM ; i < count ; + + i ) { Byte Util . forward ( table Buffer , table Buffer . get Short ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "create cursor loader to initial list view",
    "text_2": "@ Override public Loader < Cursor > on Create Loader ( int id , Bundle args ) { Uri uri = Fm Radio Station . Station . CONTENT URI ; String select = Fm Radio Station . Station . COLUMN STATION TYPE + STRING ; String order = Fm Radio Station . Station . COLUMN STATION TYPE + STRING + Fm Radio Station . Station . COLUMN STATION FREQ ; Cursor Loader cursor Loader = new Cursor Loader ( this , uri , Fm Radio Station . COLUMNS , select , new String [ ] { String . value Of ( Fm Radio Station . STATION TYPE FAVOR ITE ) , String . value Of ( Fm Radio Station . STATION TYPE SEARCH ED ) } , order ) ; return cursor Loader ; }",
    "label": 1
  },
  {
    "text_1": "removes and returns the item at the specified index .",
    "text_2": "public long remove Index ( int index ) { if ( index > = size ) throw new Index Out Of Bounds Exception ( String . value Of ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size - - ; if ( ordered ) System . arraycopy ( items , index + NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }",
    "label": 1
  },
  {
    "text_1": "returns the common parent of n elements .",
    "text_2": "public static < T > Optional < T > lowest Common Ancestor ( Tree Def . Paren ted < T > tree Def , List < T > nodes ) { if ( nodes . size ( ) = = NUM ) { return Optional . empty ( ) ; } else { Optional < T > so Far = Optional . of ( nodes . get ( NUM ) ) ; for ( int i = NUM ; i < nodes . size ( ) & & so Far . is Present ( ) ; + + i ) { so Far = lowest Common Ancestor ( tree Def , so Far . get ( ) , nodes . get ( i ) ) ; } return so Far ; } }",
    "label": 1
  },
  {
    "text_1": "check to see if this is a recursive attribute definition .",
    "text_2": "public boolean is Recursive Attr Set ( Elem Attribute Set attr Set ) { if ( null = = m attr Set Stack ) { m attr Set Stack = new Stack ( ) ; } if ( ! m attr Set Stack . empty ( ) ) { int loc = m attr Set Stack . search ( attr Set ) ; if ( loc > - NUM ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "unit test for saving some non - empty solutions into a named solution set and then reading it back .",
    "text_2": "@ Suppress Warnings ( STRING ) public void test put Get NUM ( ) { final List < I Binding Set [ ] > in = new Linked List < I Binding Set [ ] > ( ) ; { final I Variable < ? > x = Var . var ( STRING ) ; final I Variable < ? > y = Var . var ( STRING ) ; final I Variable < ? > z = Var . var ( STRING ) ; { final List < I Binding Set > t = new Linked List < I Binding Set > ( ) ; { final List Binding Set b = new List Binding Set ( ) ; b . set ( x , new Constant < IV > ( term Id ) ) ; b . set ( y , new Constant < IV > ( term Id NUM ) ) ; t . add ( b ) ; } { final List Binding Set b = new List Binding Set ( ) ; b . set ( x , new Constant < IV > ( term Id NUM ) ) ; b . set ( y , new Constant < IV > ( inline IV ) ) ; b . set ( z , new Constant < IV > ( blob IV ) ) ; t . add ( b ) ; } in . add ( t . to Array ( new I Binding Set [ NUM ] ) ) ; } } final String solution Set = get Name ( ) ; try { solution Sets Manager . get Solutions ( solution Set ) ; fail ( STRING + Illegal State Exception . class ) ; } catch ( Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } solution Sets Manager . put Solutions ( solution Set , new Closeable Iterator Wrapper < I Binding Set [ ] > ( in . iterator ( ) ) ) ; final I Closeable Iterator < I Binding Set [ ] > out = solution Sets Manager . get Solutions ( solution Set ) ; assert Same Solutions Any Order ( flatten ( in . iterator ( ) ) , out ) ; }",
    "label": 1
  },
  {
    "text_1": "returns whether the given size is within the blacklist string .",
    "text_2": "public static boolean is Black Listed ( @ Nonnull Size size , @ Nonnull String blacklist String ) { String [ ] blacklist String Array = blacklist String . split ( STRING ) ; if ( blacklist String Array . length = = NUM ) { return BOOL ; } Set < String > blacklisted Sizes = new Hash Set ( Lists . new Array List ( blacklist String Array ) ) ; return is Black Listed ( size , blacklisted Sizes ) ; }",
    "label": 1
  },
  {
    "text_1": "find the name of the replica set precedes the host addresses .",
    "text_2": "public static String replica Set Used In ( String addresses ) { if ( addresses . starts With ( STRING ) ) { return null ; } int index = addresses . index Of ( STRING ) ; if ( index < NUM ) return null ; return addresses . substring ( NUM , index ) ; }",
    "label": 1
  },
  {
    "text_1": "checks whether the given file is readable",
    "text_2": "public static boolean is File Readable ( String file Name ) { final File file = new File ( file Name ) ; return file . exists ( ) & & file . can Read ( ) ; }",
    "label": 1
  },
  {
    "text_1": "to be called when exiting the emulation",
    "text_2": "public void exit ( ) { exit Called = BOOL ; if ( thread Map ! = null ) { delete All Threads ( ) ; log . info ( STRING ) ; if ( Duration Statistics . collect Statistics ) { statistics . exit ( ) ; log . info ( String . format ( STRING , statistics . all Cycles , statistics . get Duration Millis ( ) / NUM ) ) ; Collections . sort ( statistics . threads ) ; for ( Statistics . Thread Statistics thread Statistics : statistics . threads ) { double percentage = NUM ; if ( statistics . all Cycles ! = NUM ) { percentage = ( thread Statistics . run Clocks / ( double ) statistics . all Cycles ) * NUM ; } log . info ( String . format ( STRING , thread Statistics . get Quoted Name ( ) , thread Statistics . run Clocks , percentage ) ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "check to see if symbolizer is an image outline .",
    "text_2": "private boolean image Outline ( Default Mutable Tree Node node ) { boolean is Outline = BOOL ; if ( node ! = null ) { Default Mutable Tree Node parent Node = ( Default Mutable Tree Node ) node . get Parent ( ) ; if ( parent Node ! = null ) { if ( parent Node . get User Object ( ) instanceof Raster Symbolizer ) { is Outline = BOOL ; } } } return is Outline ; }",
    "label": 1
  },
  {
    "text_1": "adds a child layer . nested layers can only have one parent .",
    "text_2": "public void add Child ( Pdf Layer child Layer ) { if ( child Layer . parent ! = null ) throw new Illegal Argument Exception ( STRING ) ; child Layer . parent = this ; if ( children = = null ) children = new Array List < > ( ) ; children . add ( child Layer ) ; }",
    "label": 1
  },
  {
    "text_1": "thest if the given point is somewhat colinear and should not be inserted note it is quite possible that the given point replaces a point already in the list",
    "text_2": "private boolean has col inear ( Array List < Pla Point Int > corners list , Pla Point Int a point ) { int count = corners list . size ( ) ; if ( count < NUM ) return BOOL ; for ( int index = NUM ; index < count - NUM ; index + + ) { Pla Point Int start = corners list . get ( index ) ; Pla Point Int end = corners list . get ( index + NUM ) ; if ( a point . side of ( start , end ) ! = Pla Side . COL LINEAR ) continue ; double d start p = start . distance square ( a point ) ; double d p end = a point . distance square ( end ) ; double d start end = start . distance square ( end ) ; if ( d start end > = d start p ) { if ( d start end > = d p end ) { return BOOL ; } else { corners list . set ( index , a point ) ; return BOOL ; } } else { if ( d start end > = d p end ) { corners list . set ( index + NUM , a point ) ; return BOOL ; } else { corners list . set ( index , a point ) ; return BOOL ; } } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "check if the download has been paused or canceled , stopping the request appropriately if it has been .",
    "text_2": "private void check Download Can Proceed ( ) throws Stop Request Exception { if ( clock . interval Less Than ( Clock . Interval . ONE SECOND ) ) { return ; } clock . start Interval ( ) ; check Is Paused Or Canceled ( ) ; check Client Rules ( ) ; }",
    "label": 1
  },
  {
    "text_1": "appends an interface to the interfaces implemented by the class .",
    "text_2": "public void add Interface ( String name ) { cached Interfaces = null ; int info = const Pool . add Class Info ( name ) ; if ( interfaces = = null ) { interfaces = new int [ NUM ] ; interfaces [ NUM ] = info ; } else { int n = interfaces . length ; int [ ] newarray = new int [ n + NUM ] ; System . arraycopy ( interfaces , NUM , newarray , NUM , n ) ; newarray [ n ] = info ; interfaces = newarray ; } }",
    "label": 1
  },
  {
    "text_1": "creates a new instance of statusbar",
    "text_2": "public Status Bar ( boolean show Memory ) { super ( new Border Layout ( ) ) ; add ( create Info Panel ( ) , Border Layout . WEST ) ; if ( show Memory ) { add ( create Memory Status ( ) , Border Layout . CENTER ) ; J Panel icon Panel = new J Panel ( new Border Layout ( ) ) ; icon Panel . add ( new J Label ( new Ang led Lines Windows Corner Icon ( ) ) , Border Layout . SOUTH ) ; add ( icon Panel , Border Layout . EAST ) ; } else { set Background ( Color . WHITE ) ; } }",
    "label": 1
  },
  {
    "text_1": "inserts a trace into the board , whose geometry is described by a polyline . p clearance class is the index in the clearance mat ix , which describes the required clearance restrictions to other items .",
    "text_2": "public void insert trace ( Polyline p polyline , int p layer , int p half width , Net Nos List p net no arr , int p clearance class , Item Fix State p fixed state ) { Brd Tracep new trace = insert trace without cleaning ( p polyline , p layer , p half width , p net no arr , p clearance class , p fixed state ) ; if ( new trace = = null ) return ; new trace . normalize ( changed area . get area ( p layer ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a unit that corresponds to the specified string .",
    "text_2": "static Unit value Of ( String name , boolean horizontal ) { if ( name . length ( ) = = NUM ) { Unit default Unit = Sizes . get Default Unit ( ) ; if ( default Unit ! = null ) { return default Unit ; } return horizontal ? DIALOG UNITS X : DIALOG UNITS Y ; } else if ( name . equals ( STRING ) ) { return PIXEL ; } else if ( name . equals ( STRING ) ) { return horizontal ? DIALOG UNITS X : DIALOG UNITS Y ; } else if ( name . equals ( STRING ) ) { return POINT ; } else if ( name . equals ( STRING ) ) { return INCH ; } else if ( name . equals ( STRING ) ) { return MILLI METER ; } else if ( name . equals ( STRING ) ) { return CEN TIME TER ; } else { throw new Illegal Argument Exception ( STRING + name + STRING + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "converts the given value to the xml string value .",
    "text_2": "public static String to String ( final double value ) { return Double . to String ( value ) ; }",
    "label": 1
  },
  {
    "text_1": "when a pick list is installed , table selection controls the add button",
    "text_2": "public void value Changed ( List Selection Event e ) { if ( table = = null ) { return ; } int row = table . get Selected Row ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + row ) ; } if ( row > = NUM ) { add Button . set Enabled ( BOOL ) ; add Button . set Tool Tip Text ( null ) ; if ( type ! = null & & type . equals ( STRING ) ) { make Icon Map ( pick List Model . get Bean At ( row ) ) ; clear Icon Panel ( ) ; do Icon Panel ( ) ; } } else { add Button . set Enabled ( BOOL ) ; add Button . set Tool Tip Text ( Bundle . get Message ( STRING ) ) ; } validate ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "helps to find recursivly all visible childs in a view group .",
    "text_2": "static void find All Visible Childs ( final View Group view Group , final List < View > or do red Childs ) { for ( int child View Index = NUM ; child View Index < view Group . get Child Count ( ) ; child View Index + + ) { final View child View = view Group . get Child At ( child View Index ) ; if ( child View instanceof View Group ) { find All Visible Childs ( ( View Group ) child View , or do red Childs ) ; continue ; } if ( child View . get Visibility ( ) = = View . VISIBLE ) { or do red Childs . add ( child View ) ; } } }",
    "label": 1
  },
  {
    "text_1": "checker method that will throw if any unsupported standard osgi options is present .",
    "text_2": "private static void reject Unsupported Options ( Properties p ) throws SQL Feature Not Supported Exception { if ( p . contains Key ( Data Source Factory . JDBC ROLE NAME ) ) { throw new SQL Feature Not Supported Exception ( STRING + Data Source Factory . JDBC ROLE NAME + STRING ) ; } if ( p . contains Key ( Data Source Factory . JDBC DATASOURCE NAME ) ) { throw new SQL Feature Not Supported Exception ( STRING + Data Source Factory . JDBC DATASOURCE NAME + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "replaces single \\ r line feeds with \\ n ( some databases don ' t like them )",
    "text_2": "public static String fix Line Feeds ( String sql ) { if ( sql . index Of ( STRING ) = = - NUM ) { return sql ; } boolean has Fixes = BOOL ; char [ ] fixed = sql . to Char Array ( ) ; for ( int i = NUM ; i < fixed . length ; i + + ) { if ( fixed [ i ] = = STRING & & ( i = = fixed . length - NUM | | fixed [ i + NUM ] ! = STRING ) ) { fixed [ i ] = STRING ; has Fixes = BOOL ; } } return has Fixes ? String . value Of ( fixed ) : sql ; }",
    "label": 1
  },
  {
    "text_1": "angle of this sample in radians",
    "text_2": "public float angle ( ) { return ( float ) Math . atan NUM ( y ( ) , x ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "tell the table something is not pressed .",
    "text_2": "public void handle Header Column Released ( Point p ) { TABLE . set Pressed Column Index ( - NUM ) ; J Table Header th = TABLE . get Table Header ( ) ; int col = th . column At Point ( p ) ; if ( col ! = - NUM ) th . repaint ( th . get Header Rect ( col ) ) ; }",
    "label": 1
  },
  {
    "text_1": "generate base 64 from bitmap image",
    "text_2": "public static String create Base NUM ( Bitmap m Bitmap ) { Byte Array Output Stream baos NUM = new Byte Array Output Stream ( ) ; m Bitmap . compress ( Bitmap . Compress Format . JPEG , NUM , baos NUM ) ; byte [ ] b NUM = baos NUM . to Byte Array ( ) ; return Base NUM . encode To String ( b NUM , Base NUM . DEFAULT ) ; }",
    "label": 1
  },
  {
    "text_1": "gets detailed information about docker image .",
    "text_2": "public Image Info inspect Image ( String image ) throws IO Exception { return inspect Image ( Inspect Image Params . create ( image ) ) ; }",
    "label": 1
  },
  {
    "text_1": "event handler for when a reference is inserted into the output stream .",
    "text_2": "public Object reference Insert ( String reference , Object value ) { String s = null ; if ( value ! = null ) { s = REFERENCE VALUE ; } else { if ( reference . equals ( STRING ) ) { s = NO REFERENCE VALUE ; } } return s ; }",
    "label": 1
  },
  {
    "text_1": "concatenate the path of the so library , including directory .",
    "text_2": "static String target So File ( String lib Name , int version ) { Context context = m Context ; if ( null = = context ) { return STRING ; } String path = STRING + context . get Package Name ( ) + STRING ; File f = context . get Files Dir ( ) ; if ( f ! = null ) { path = f . get Path ( ) ; } return path + STRING + lib Name + STRING + version + STRING ; }",
    "label": 1
  },
  {
    "text_1": "checks the parent window if its size is within parameters as set by the lc .",
    "text_2": "private void adjust Window Size ( Container Wrapper parent ) { Bound Size w Bounds = lc . get Pack Width ( ) ; Bound Size h Bounds = lc . get Pack Height ( ) ; if ( w Bounds = = null & & h Bounds = = null ) return ; Window win = ( ( Window ) Swing Utilities . get Ancestor Of Class ( Window . class , ( Component ) parent . get Component ( ) ) ) ; if ( win = = null ) return ; Dimension pref Size = win . get Preferred Size ( ) ; int targ W = constrain ( check Parent ( win ) , win . get Width ( ) , pref Size . width , w Bounds ) ; int targ H = constrain ( check Parent ( win ) , win . get Height ( ) , pref Size . height , h Bounds ) ; int x = Math . round ( win . get X ( ) - ( ( targ W - win . get Width ( ) ) * ( NUM - lc . get Pack Width Align ( ) ) ) ) ; int y = Math . round ( win . get Y ( ) - ( ( targ H - win . get Height ( ) ) * ( NUM - lc . get Pack Height Align ( ) ) ) ) ; win . set Bounds ( x , y , targ W , targ H ) ; }",
    "label": 1
  },
  {
    "text_1": "is this diff equivalent to another diff ?",
    "text_2": "@ Override public boolean equals ( Object obj ) { if ( this = = obj ) { return BOOL ; } if ( obj = = null ) { return BOOL ; } if ( get Class ( ) ! = obj . get Class ( ) ) { return BOOL ; } Diff other = ( Diff ) obj ; if ( operation ! = other . operation ) { return BOOL ; } if ( text = = null ) { if ( other . text ! = null ) { return BOOL ; } } else if ( ! text . equals ( other . text ) ) { return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "adds a description to this method .",
    "text_2": "public Defined Method add Description ( String description ) { this . description = Optional . of ( description ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "get the day difference in the selected day and the first day in the week",
    "text_2": "public static int m Date Gap ( String day Name ) { Log . d ( STRING , day Name ) ; if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else { return NUM ; } }",
    "label": 1
  },
  {
    "text_1": "returns the number of rules contained in this grammar .",
    "text_2": "public int size ( ) { return rules . size ( ) ; }",
    "label": 1
  },
  {
    "text_1": "determine if is a supported auth type",
    "text_2": "public static boolean is Valid Auth Type ( String auth Type ) { log . debug ( STRING ) ; if ( auth Type ! = null ) { if ( ! auth Type . is Empty ( ) ) { if ( auth Type . equals Ignore Case ( Ldap Auth Base . LDAP AUTH TYPE SIMPLE ) ) return BOOL ; if ( auth Type . equals Ignore Case ( Ldap Auth Base . LDAP AUTH TYPE NONE ) ) return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "method from org . apache . maven . plugins . help . abstrac te ffective mojo write comments in the effective pom / settings header .",
    "text_2": "protected static void write Header ( XML Writer writer ) { Xml Writer Util . write Comment Line Break ( writer ) ; Xml Writer Util . write Comment ( writer , STRING ) ; Date Format date Format = new Simple Date Format ( STRING ) ; Xml Writer Util . write Comment ( writer , STRING + date Format . format ( new Date ( System . current Time Millis ( ) ) ) ) ; Xml Writer Util . write Comment ( writer , STRING ) ; Xml Writer Util . write Comment ( writer , STRING ) ; Xml Writer Util . write Comment Line Break ( writer ) ; Xml Writer Util . write Line Break ( writer ) ; }",
    "label": 1
  },
  {
    "text_1": "checks log ix reference of text .",
    "text_2": "String validate Logix Reference ( String name ) { Logix l = null ; if ( name ! = null ) { if ( name . length ( ) > NUM ) { l = log ix Manager . get By User Name ( name ) ; if ( l ! = null ) { return name ; } } l = log ix Manager . get By System Name ( name ) ; } if ( l = = null ) { message Invalid Action Item Name ( name , STRING ) ; return null ; } return name ; }",
    "label": 1
  },
  {
    "text_1": "returns the number of components in this list .",
    "text_2": "public int size ( ) { return delegate . size ( ) ; }",
    "label": 1
  },
  {
    "text_1": "deploys all tasks that correspond to given descriptor . first method checks tasks versions and stops processing tasks that have both versioned and un versioned instances . than it deletes tasks with lower version and deploys newest tasks .",
    "text_2": "private void new Unit Received ( Grid Uri Deployment Unit Descriptor new Desc , Collection < Class < ? > > clss ) { assert new Desc ! = null ; assert new Desc . get Type ( ) = = Grid Uri Deployment Unit Descriptor . Type . FILE ; if ( clss ! = null & & ! clss . is Empty ( ) ) { try { add Resources ( new Desc . get Class Loader ( ) , new Desc , clss . to Array ( new Class < ? > [ clss . size ( ) ] ) ) ; } catch ( Ignite Spi Exception e ) { U . warn ( log , STRING + new Desc + STRING + e . get Message ( ) + STRING ) ; } } Collection < Class Loader > rmv Cls L drs = new Array List < > ( ) ; synchronized ( mux ) { if ( check Md NUM & & unit Deployed ( new Desc . get Md NUM ( ) ) ) { if ( log . is Info Enabled ( ) ) LT . info ( log , STRING + STRING + U . hide Password ( new Desc . get Uri ( ) ) + STRING + ( new Desc . get File ( ) = = null ? STRING : new Desc . get File ( ) ) + STRING ) ; return ; } boolean is Added = BOOL ; boolean ignore New Unit = BOOL ; for ( List Iterator < Grid Uri Deployment Unit Descriptor > iter = unit Loaders . list Iterator ( ) ; iter . has Next ( ) ; ) { Grid Uri Deployment Unit Descriptor desc = iter . next ( ) ; assert ! new Desc . get Class Loader ( ) . equals ( desc . get Class Loader ( ) ) : STRING + new Desc ; if ( desc . get Type ( ) = = Grid Uri Deployment Unit Descriptor . Type . FILE & & new Desc . get Uri ( ) . equals ( desc . get Uri ( ) ) & & ! new Desc . get File ( ) . equals ( desc . get File ( ) ) ) { iter . remove ( ) ; rmv Cls L drs . add ( desc . get Class Loader ( ) ) ; if ( ! iter . has Next ( ) ) break ; continue ; } if ( ! is Added ) { if ( unit Comp . compare ( new Desc , desc ) < = NUM ) { if ( check Unit Collision ( desc , new Desc ) ) { iter . remove ( ) ; iter . add ( new Desc ) ; rmv Cls L drs . add ( desc . get Class Loader ( ) ) ; } else { iter . set ( new Desc ) ; iter . add ( desc ) ; } is Added = BOOL ; } else if ( check Unit Collision ( new Desc , desc ) ) { ignore New Unit = BOOL ; break ; } } else if ( check Unit Collision ( new Desc , desc ) ) { iter . remove ( ) ; rmv Cls L drs . add ( desc . get Class Loader ( ) ) ; } } if ( ! ignore New Unit ) { if ( ! is Added ) unit Loaders . add ( new Desc ) ; if ( log . is Debug Enabled ( ) ) LT . info ( log , STRING + new Desc . get Class Loader ( ) + STRING + new Desc . get Timestamp ( ) + STRING + U . hide Password ( new Desc . get Uri ( ) ) + STRING + ( new Desc . get File ( ) = = null ? STRING : new Desc . get File ( ) ) + STRING ) ; } } for ( Class Loader cld Ldr : rmv Cls L drs ) on Unit Released ( cld Ldr ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "updates this tunnel , marking it as recently accessed .",
    "text_2": "public void access ( ) { last Accessed Time = System . current Time Millis ( ) ; }",
    "label": 1
  },
  {
    "text_1": "tell if the table contains the given node .",
    "text_2": "public boolean contains ( Node s ) { run To ( - NUM ) ; if ( null = = m map ) return BOOL ; for ( int i = NUM ; i < m first Free ; i + + ) { Node node = m map [ i ] ; if ( ( null ! = node ) & & node . equals ( s ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "a wrapper method for those callers who don ' t want to make optimization plans",
    "text_2": "public static int recompile With Opt ( Normal Method method ) { if ( VM . Build For Opt Compiler ) { Compilation Plan plan = new Compilation Plan ( method , ( Optimization Plan Element [ ] ) optimization Plan , null , ( Opt Options ) options ) ; return recompile With Opt ( plan ) ; } else { if ( VM . Verify Assertions ) VM . assert ( VM . NOT REACHED ) ; return - NUM ; } }",
    "label": 1
  },
  {
    "text_1": "removes an index entry",
    "text_2": "boolean remove Index Entry ( String resource Name , String policy Name ) { Iterator iter = top Level Entries . iterator ( ) ; boolean processed = BOOL ; while ( ! processed & & ( iter . has Next ( ) ) ) { Resource Index Entry resource Index Entry = ( Resource Index Entry ) iter . next ( ) ; if ( resource Index Entry . remove Index Entry ( resource Type , resource Name , policy Name ) ) { processed = BOOL ; } } return processed ; }",
    "label": 1
  },
  {
    "text_1": "writes the data to a file .",
    "text_2": "private static long write File ( String path , byte [ ] data ) { File Output Stream out = null ; try { out = new File Output Stream ( path ) ; out . write ( data ) ; return data . length ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } finally { try { out . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } } return - NUM ; }",
    "label": 1
  },
  {
    "text_1": "parses a utf - 8 constant pool entry .",
    "text_2": "private Utf NUM Constant parse Utf NUM Constant ( int index ) throws IO Exception { int length = read Short ( ) ; String Builder cb = new String Builder ( ) ; for ( int i = NUM ; i < length ; i + + ) { int ch = read ( ) ; if ( ch < NUM ) { cb . append ( ( char ) ch ) ; } else if ( ( ch & NUM ) = = NUM ) { int ch NUM = read ( ) ; i + + ; cb . append ( ( char ) ( ( ( ch & NUM ) < < NUM ) + ( ch NUM & NUM ) ) ) ; } else { int ch NUM = read ( ) ; int ch NUM = read ( ) ; i + = NUM ; cb . append ( ( char ) ( ( ( ch & NUM ) < < NUM ) + ( ( ch NUM & NUM ) < < NUM ) + ( ( ch NUM & NUM ) ) ) ) ; } } return new Utf NUM Constant ( class . get Constant Pool ( ) , index , cb . to String ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "add a part to the body .",
    "text_2": "public Builder add Part ( Part part ) { if ( part = = null ) throw new Null Pointer Exception ( STRING ) ; parts . add ( part ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "read information object and return pointer to correct place",
    "text_2": "public void read Information Object ( final Pdf Object info Obj , final Object Decoder object Decoder ) { try { object Decoder . check Resolved ( info Obj ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; } String new Value ; int id ; byte [ ] data ; final int count = Pdf File Information . information field I Ds . length ; for ( int i = NUM ; i < count ; i + + ) { id = Pdf File Information . information field I Ds [ i ] ; if ( id = = Pdf Dictionary . Tr apped ) { new Value = info Obj . get Name ( id ) ; if ( new Value = = null ) { new Value = STRING ; } } else { data = info Obj . get Text Stream Value As Byte ( id ) ; if ( data = = null ) { new Value = STRING ; } else { new Value = String Utils . get Text String ( data , BOOL ) ; } } set Field Value ( i , new Value ) ; } }",
    "label": 1
  },
  {
    "text_1": "check if all files in selected filename st obe modified are not write protected .",
    "text_2": "public String check Write Protected ( int res Id Action , final File . . . files To Be Modified ) { if ( files To Be Modified ! = null ) { for ( File file : files To Be Modified ) { if ( ( file ! = null ) & & ( file . exists ( ) ) & & ( ! file . can Write ( ) ) ) { String action = ( res Id Action = = NUM ) ? STRING : m Context . get String ( res Id Action ) ; return m Context . get String ( R . string . file err write protected , file . get Absolute Path ( ) , action ) ; } } } return null ; }",
    "label": 1
  },
  {
    "text_1": "calculates the centroid pivot of a node based on the list of points that it contains ( t be two lists of its children are provided ) .",
    "text_2": "public Instance calc Pivot ( My Idx List list NUM , My Idx List list NUM , Instances insts ) { int class Idx = m Instances . class Index ( ) ; double [ ] attr Vals = new double [ insts . num Attributes ( ) ] ; Instance temp ; for ( int i = NUM ; i < list NUM . length ( ) ; i + + ) { temp = insts . instance ( list NUM . get ( i ) . idx ) ; for ( int k = NUM ; k < temp . num Values ( ) ; k + + ) { if ( temp . index ( k ) = = class Idx ) { continue ; } attr Vals [ k ] + = temp . value Sparse ( k ) ; } } for ( int j = NUM ; j < list NUM . length ( ) ; j + + ) { temp = insts . instance ( list NUM . get ( j ) . idx ) ; for ( int k = NUM ; k < temp . num Values ( ) ; k + + ) { if ( temp . index ( k ) = = class Idx ) { continue ; } attr Vals [ k ] + = temp . value Sparse ( k ) ; } } for ( int j = NUM , num Insts = list NUM . length ( ) + list NUM . length ( ) ; j < attr Vals . length ; j + + ) { attr Vals [ j ] / = num Insts ; } temp = new Dense Instance ( NUM , attr Vals ) ; return temp ; }",
    "label": 1
  },
  {
    "text_1": "returns the password changed time .",
    "text_2": "public void request Password Changed Time ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD CHANGED TIME ) ; }",
    "label": 1
  },
  {
    "text_1": "returns int [ ] scaled width , scaled height for dimensions that fit within the given maxwidth , max height at the given in width , in height aspect ratio . if the in dimensions fit fully inside the max dimensions , no scaling is applied . otherwise , at least one scaled dimension is set to a max dimension , and the other scaled dimension is scaled to fit .",
    "text_2": "public static int [ ] scale Down Inside ( int in Width , int in Height , int max Width , int max Height ) { int scaled Width ; int scaled Height ; if ( in Width < = max Width & & in Height < = max Height ) { scaled Width = in Width ; scaled Height = in Height ; } else { double width Ratio = ( double ) in Width / ( double ) max Width ; double height Ratio = ( double ) in Height / ( double ) max Height ; if ( width Ratio > height Ratio ) { scaled Width = max Width ; scaled Height = ( int ) Math . round ( ( double ) in Height / width Ratio ) ; } else { scaled Height = max Height ; scaled Width = ( int ) Math . round ( ( double ) in Width / height Ratio ) ; } } return new int [ ] { scaled Width , scaled Height } ; }",
    "label": 1
  },
  {
    "text_1": "invoke heapify - down for the root object .",
    "text_2": "private void heapify Down ( Comparable < Object > cur ) { final int stop = size > > > NUM ; int twopos = NUM ; while ( twopos < stop ) { int bestchild = ( twopos < < NUM ) + NUM ; Comparable < Object > best = twoheap [ bestchild ] ; final int right = bestchild + NUM ; if ( right < size & & best . compare To ( twoheap [ right ] ) > NUM ) { bestchild = right ; best = twoheap [ right ] ; } if ( cur . compare To ( best ) < = NUM ) { break ; } twoheap [ twopos ] = best ; twopos = bestchild ; } twoheap [ twopos ] = cur ; }",
    "label": 1
  },
  {
    "text_1": "insert data for position",
    "text_2": "public void add Item ( int position , M model ) { m Datas . add ( position , model ) ; notify Item Inserted ( position ) ; }",
    "label": 1
  },
  {
    "text_1": "determines whether a new span at [ start , end ) will overlap with any existing span .",
    "text_2": "private static boolean span Will Overlap ( Spannable span Text , URL Span [ ] span List , int start , int end ) { if ( start = = end ) { return BOOL ; } for ( URL Span span : span List ) { int existing Start = span Text . get Span Start ( span ) ; int existing End = span Text . get Span End ( span ) ; if ( ( start > = existing Start & & start < existing End ) | | end > existing Start & & end < = existing End ) { if ( Log . is Loggable ( TAG , Log . VERBOSE ) ) { Char Sequence seq = span Text . sub Sequence ( start , end ) ; Log . v ( TAG , STRING + seq + STRING ) ; } return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "returns the protocol version to use for sending multicast requests or announcements , or initiating unicast discovery .",
    "text_2": "public int choose Protocol Version ( ) { return preferred Protocol Version ; }",
    "label": 1
  },
  {
    "text_1": "retrieves all coden vy workspaces of the user identified by the authentication token .",
    "text_2": "@ Override public Request < List < Workspace > > all ( ) { List < Workspace > workspaces To Return = new Array List < > ( ) ; for ( Workspace dummy Workspace : workspaces . values ( ) ) { workspaces To Return . add ( dummy Workspace ) ; } return new Dummy Request < > ( workspaces To Return ) ; }",
    "label": 1
  },
  {
    "text_1": "internal conversion . this is needed to support the current spring boot actuator audit event repository interface",
    "text_2": "public Map < String , Object > convert Data To Objects ( Map < String , String > data ) { Map < String , Object > results = new Hash Map < > ( ) ; if ( data ! = null ) { for ( String key : data . key Set ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }",
    "label": 1
  },
  {
    "text_1": "find the f feature in y that maxi mise j ( x + y )",
    "text_2": "private int sequential Forward Selection ( String data File , String [ ] features , int ind Var Col Number , int X [ ] , int Y [ ] , double J [ ] , int row Ini , int row End ) { double sig [ ] = new double [ Y . length ] ; int sig Index [ ] = new int [ Y . length ] ; double cor X plus y [ ] = new double [ Y . length ] ; double cor X ; if ( X . length > NUM ) { Regression reg = new Regression ( ) ; reg . multiple Linear Regression ( data File , ind Var Col Number , X , features , intercept Term , row Ini , row End ) ; cor X = reg . get Correlation ( ) ; } else cor X = NUM ; for ( int i = NUM ; i < Y . length ; i + + ) { cor X plus y [ i ] = correlation Of New Feature ( data File , features , ind Var Col Number , X , Y [ i ] , row Ini , row End ) ; sig [ i ] = cor X plus y [ i ] - cor X ; sig Index [ i ] = Y [ i ] ; } int min Sig = Math Utils . get Min Index ( sig ) ; J [ NUM ] = cor X plus y [ min Sig ] ; J [ NUM ] = cor X ; int max Sig = Math Utils . get Max Index ( sig ) ; J [ NUM ] = cor X plus y [ max Sig ] ; return sig Index [ max Sig ] ; }",
    "label": 1
  },
  {
    "text_1": "mark the appropriate areas as needing a repaint after changes to the document .",
    "text_2": "protected void update Damage ( Document Event changes , Shape a , View Factory f ) { check Metrics ( ) ; Component host = get Container ( ) ; Element elem = get Element ( ) ; Document Event . Element Change ec = changes . get Change ( elem ) ; Element [ ] added = ( ec ! = null ) ? ec . get Children Added ( ) : null ; Element [ ] removed = ( ec ! = null ) ? ec . get Children Removed ( ) : null ; if ( ( ( added ! = null ) & & ( added . length > NUM ) ) | | ( ( removed ! = null ) & & ( removed . length > NUM ) ) ) { if ( added ! = null & & longest Line ! = null ) { int current Max Width = get Line Width ( longest Line ) ; for ( int i = NUM ; i < added . length ; i + + ) { int width = get Line Width ( added [ i ] ) ; if ( width > current Max Width ) { current Max Width = width ; longest Line = added [ i ] ; } } } if ( removed ! = null ) { for ( int i = NUM ; i < removed . length ; i + + ) { if ( removed [ i ] = = longest Line ) { longest Line = null ; break ; } } } preference Changed ( null , BOOL , BOOL ) ; host . repaint ( ) ; } else { Element map = get Element ( ) ; int line = map . get Element Index ( changes . get Offset ( ) ) ; int end Line = map . get Element Index ( changes . get Offset ( ) + changes . get Length ( ) ) ; damage Line Range ( line , end Line , a , host ) ; get Longest Line ( ) ; if ( changes . get Type ( ) = = Document Event . Event Type . INSERT ) { int w = get Line Width ( longest Line ) ; Element e = map . get Element ( line ) ; if ( e = = longest Line ) { preference Changed ( null , BOOL , BOOL ) ; } else if ( get Line Width ( e ) > w ) { longest Line = e ; preference Changed ( null , BOOL , BOOL ) ; } } else if ( changes . get Type ( ) = = Document Event . Event Type . REMOVE ) { if ( map . get Element ( line ) = = longest Line ) { determine Longest Line ( ) ; preference Changed ( null , BOOL , BOOL ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "check if the current upgrade is a sp / patch / hot fix upgrade .",
    "text_2": "private boolean is Minor Version Upgrade ( String current Version , String target Version ) { String current Db Schema Version = Vdc Util . get Db Schema Version ( current Version ) ; if ( current Db Schema Version = = null ) { return BOOL ; } return current Db Schema Version . equals ( Vdc Util . get Db Schema Version ( target Version ) ) ; }",
    "label": 1
  },
  {
    "text_1": "evaluate model - over 20 windows .",
    "text_2": "public static Result evaluate Model ( Multi Label Classifier h , Instances D ) throws Exception { return evaluate Model Pre qu ential Basic ( h , D , NUM , NUM , STRING , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize all port parameters port - & gt ; dialog",
    "text_2": "public void init Port Parameters ( Serial Port port ) { initialized = BOOL ; if ( port ! = null ) { cb Port . set Selected Item ( port . get Name ( ) ) ; cb B audrate . set Selected Item ( String . value Of ( port . get Baud Rate ( ) ) ) ; cb Parity . set Selected Index ( port . get Parity ( ) ) ; cb Data Bits . set Selected Index ( port . get Data Bits ( ) - NUM ) ; cb Stop Bits . set Selected Index ( port . get Stop Bits ( ) - NUM ) ; int prt = port . get Flow Control Mode ( ) ; cb Protocol Rx . set Selected Index ( ( prt & Serial Port . FLOW CONTROL RT SC TS IN ) ! = NUM ? NUM : ( prt & Serial Port . FLOW CONTROL X ON X OFF IN ) ! = NUM ? NUM : NUM ) ; cb Protocol Tx . set Selected Index ( ( prt & Serial Port . FLOW CONTROL RT SC TS OUT ) ! = NUM ? NUM : ( prt & Serial Port . FLOW CONTROL X ON X OFF OUT ) ! = NUM ? NUM : NUM ) ; btn DSR . set Selected ( port . is DSR ( ) ) ; btn CTS . set Selected ( port . is CTS ( ) ) ; btn CD . set Selected ( port . is CD ( ) ) ; btn DTR . set Selected ( port . is DTR ( ) ) ; btn RTS . set Selected ( port . is RTS ( ) ) ; } initialized = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "writes attributes as a null - terminated list of marsh alled instances .",
    "text_2": "private void write Object ( Object Output Stream stream ) throws IO Exception { stream . default Write Object ( ) ; marshal Attributes ( attrs , stream ) ; }",
    "label": 1
  },
  {
    "text_1": "generates a one - dimensional array of normal random doubles .",
    "text_2": "public static double [ ] nd ary ( int n ) { double d [ ] = new double [ n ] ; for ( int i = NUM ; i < n ; i + + ) { d [ i ] = R . next Gaussian ( ) ; } return d ; }",
    "label": 1
  },
  {
    "text_1": "api to make the existing demand bill inactive",
    "text_2": "public void make Existing Demand Bill Inactive ( String assessment No ) { Demand Bill Service demand Bill Service = ( Demand Bill Service ) bean Provider . get Bean ( STRING ) ; demand Bill Service . make Demand Bill Inactive ( assessment No ) ; }",
    "label": 1
  },
  {
    "text_1": "use on sizechanged instead of on attached towindow to get the dimensions of the view , because this method is called after measuring the dimensions of match parent & wrap content . use this dimensions to setup the bounds and paints .",
    "text_2": "@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { super . on Size Changed ( w , h , oldw , oldh ) ; setup Bounds ( w , h ) ; setup Paints ( ) ; invalidate ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create a jms connectionfactory with the specified name connected to a single live - backup pair of servers . the connectionfactory is bound to the registry for all the specified bindings strings .",
    "text_2": "@ Override public void create Connection Factory ( String name , boolean ha , boolean use Discovery , int cf Type , String connectors , String bindings ) throws Exception { create Connection Factory ( name , ha , use Discovery , cf Type , to Array ( connectors ) , to Array ( bindings ) ) ; }",
    "label": 1
  },
  {
    "text_1": "remove all occurrences of the given regex pattern , replacing them with the empty string .",
    "text_2": "public Text Editor delete All ( String pattern ) { return replace All ( pattern , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "same as string . contains , but ignores case .",
    "text_2": "public static boolean contains Ignore Case ( String str , String query ) { if ( str ! = null & & query ! = null ) { int limit = str . length ( ) - query . length ( ) + NUM ; for ( int i = NUM ; i < limit ; i + + ) { if ( matches Ignore Case ( str , query , i ) ) { return BOOL ; } } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "creates a new panel object .",
    "text_2": "public C Visibility Criterium Panel ( final C Visibility Criterium criterium ) { super ( new Border Layout ( ) ) ; visibility Criterium = criterium ; visibility State Box . add Action Listener ( visibility State Box Listener ) ; init Panel ( ) ; }",
    "label": 1
  },
  {
    "text_1": "sets the current iteration position to the last boundary position before the specified position .",
    "text_2": "@ Override public int preceding ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; if ( cached Break Positions = = null | | offset < = cached Break Positions [ NUM ] | | offset > cached Break Positions [ cached Break Positions . length - NUM ] ) { cached Break Positions = null ; return super . preceding ( offset ) ; } else { position In Cache = NUM ; while ( position In Cache < cached Break Positions . length & & offset > cached Break Positions [ position In Cache ] ) { + + position In Cache ; } - - position In Cache ; text . set Index ( cached Break Positions [ position In Cache ] ) ; return text . get Index ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "checks actual current account against current accounts when the activity has been started .",
    "text_2": "private boolean has Current Account Changed ( ) { Account account = Account Utils . get Current Own Cloud Account ( this ) ; if ( account = = null ) { return BOOL ; } else { return ! m Original Current Account . equals ( account . name ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a new socket reader object .",
    "text_2": "public Socket Reader ( final Socket socket ) throws IO Exception { Preconditions . check Not Null ( socket , STRING ) ; m Input Stream = new Buffered Input Stream ( socket . get Input Stream ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "geme in same initial methode der dre i konstru k to ren , diese er ha elt den cf ml code als char [ ] und ueber tra e gt i hn , in die intere n daten hal tun g .",
    "text_2": "protected void init ( String str ) { int len = str . length ( ) ; text = new char [ len ] ; lc Text = new char [ len ] ; for ( int i = NUM ; i < len ; i + + ) { char c = str . char At ( i ) ; text [ i ] = c ; if ( c = = STRING | | c = = STRING | | c = = STRING ) { lc Text [ i ] = STRING ; } else lc Text [ i ] = ( ( c > = STRING & & c < = STRING ) | | ( c > = STRING & & c < = STRING ) ) ? c : Character . to Lower Case ( c ) ; } }",
    "label": 1
  },
  {
    "text_1": "put current frame into stack due to function call",
    "text_2": "public void push Frame ( Local Variable Map vars , DML Program Counter pc ) { call Stack . push ( new DML Frame ( vars , pc ) ) ; }",
    "label": 1
  },
  {
    "text_1": "closes this input stream and releases any system resources associated with the stream .",
    "text_2": "public void close ( ) throws IO Exception { if ( ! closed ) { if ( uses Default Inflater ) inf . end ( ) ; in . close ( ) ; closed = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "cannot create shopping cart item with no parameters",
    "text_2": "protected Shopping Cart Item ( ) { }",
    "label": 1
  },
  {
    "text_1": "records the conditions of the page when a gesture is initiated .",
    "text_2": "private void begin Gesture ( int scroll Offset Y , int scroll Extent Y ) { m Initial Translation Y = get Translation Y ( ) ; boolean is Initially Visible = m Initial Translation Y < m Total Height ; int starting Y = is Initially Visible ? scroll Offset Y : Math . min ( scroll Offset Y , m Total Height ) ; m Initial Offset Y = starting Y + scroll Extent Y ; }",
    "label": 1
  },
  {
    "text_1": "creates a launch option using the default java environment .",
    "text_2": "public Launch Option ( Version version , Authenticator authenticator , Minecraft Directory minecraft Dir ) { Objects . require Non Null ( version ) ; Objects . require Non Null ( authenticator ) ; Objects . require Non Null ( minecraft Dir ) ; this . version = version ; this . authenticator = authenticator ; this . minecraft Directory = minecraft Dir ; this . runtime Directory = minecraft Dir ; this . java Environment = Java Environment . current ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the string is null or empty .",
    "text_2": "public static boolean is Empty ( String string ) { return string = = null | | string . length ( ) = = NUM ; }",
    "label": 1
  },
  {
    "text_1": "removes a production from this rule .",
    "text_2": "public void remove ( Production production ) { productions . remove ( production ) ; }",
    "label": 1
  },
  {
    "text_1": "write a list of strings to document as elements with given tag name .",
    "text_2": "public static void write Element List ( XML Output xml Output , String tag Name , Iterable < String > list Values ) throws IO Exception { write Element List ( xml Output , tag Name , list Values . iterator ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convolve with a kernel consisting of one row",
    "text_2": "private void threshold Blur ( Kernel kernel , int [ ] in Pixels , int [ ] out Pixels , int width , int height , boolean alpha ) { float [ ] matrix = kernel . get Kernel Data ( null ) ; int cols = kernel . get Width ( ) ; int cols NUM = cols / NUM ; for ( int y = NUM ; y < height ; y + + ) { int io ffset = y * width ; int out Index = y ; for ( int x = NUM ; x < width ; x + + ) { float r = NUM , g = NUM , b = NUM , a = NUM ; int mo ffset = cols NUM ; int rgb NUM = in Pixels [ io ffset + x ] ; int a NUM = ( rgb NUM > > NUM ) & NUM ; int r NUM = ( rgb NUM > > NUM ) & NUM ; int g NUM = ( rgb NUM > > NUM ) & NUM ; int b NUM = rgb NUM & NUM ; float af = NUM , rf = NUM , gf = NUM , bf = NUM ; for ( int col = - cols NUM ; col < = cols NUM ; col + + ) { float f = matrix [ mo ffset + col ] ; if ( f ! = NUM ) { int ix = x + col ; if ( ! ( NUM < = ix & & ix < width ) ) ix = x ; int rgb NUM = in Pixels [ io ffset + ix ] ; int a NUM = ( rgb NUM > > NUM ) & NUM ; int r NUM = ( rgb NUM > > NUM ) & NUM ; int g NUM = ( rgb NUM > > NUM ) & NUM ; int b NUM = rgb NUM & NUM ; int d ; d = a NUM - a NUM ; if ( d > = - threshold & & d < = threshold ) { a + = f * a NUM ; af + = f ; } d = r NUM - r NUM ; if ( d > = - threshold & & d < = threshold ) { r + = f * r NUM ; rf + = f ; } d = g NUM - g NUM ; if ( d > = - threshold & & d < = threshold ) { g + = f * g NUM ; gf + = f ; } d = b NUM - b NUM ; if ( d > = - threshold & & d < = threshold ) { b + = f * b NUM ; bf + = f ; } } } a = af = = NUM ? a NUM : a / af ; r = rf = = NUM ? r NUM : r / rf ; g = gf = = NUM ? g NUM : g / gf ; b = bf = = NUM ? b NUM : b / bf ; int ia = alpha ? Pixel Utils . clamp ( ( int ) ( a + NUM ) ) : NUM ; int ir = Pixel Utils . clamp ( ( int ) ( r + NUM ) ) ; int ig = Pixel Utils . clamp ( ( int ) ( g + NUM ) ) ; int ib = Pixel Utils . clamp ( ( int ) ( b + NUM ) ) ; out Pixels [ out Index ] = ( ia < < NUM ) | ( ir < < NUM ) | ( ig < < NUM ) | ib ; out Index + = height ; } } }",
    "label": 1
  },
  {
    "text_1": "decodes lz w image data into pixel array . adapted from john cri sty ' s image mag ick .",
    "text_2": "protected void decode Image Data ( ) { int Null Code = - NUM ; int npix = iw * ih ; int available , clear , code mask , code size , end of information , in code , old code , bits , code , count , i , datum , data size , first , top , bi , pi ; if ( ( pixels = = null ) | | ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix = = null ) prefix = new short [ Max Stack Size ] ; if ( suffix = = null ) suffix = new byte [ Max Stack Size ] ; if ( pixel Stack = = null ) pixel Stack = new byte [ Max Stack Size + NUM ] ; data size = read ( ) ; clear = NUM < < data size ; end of information = clear + NUM ; available = clear + NUM ; old code = Null Code ; code size = data size + NUM ; code mask = ( NUM < < code size ) - NUM ; for ( code = NUM ; code < clear ; code + + ) { prefix [ code ] = NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM ; for ( i = NUM ; i < npix ; ) { if ( top = = NUM ) { if ( bits < code size ) { if ( count = = NUM ) { count = read Block ( ) ; if ( count < = NUM ) break ; bi = NUM ; } datum + = ( ( ( int ) block [ bi ] ) & NUM ) < < bits ; bits + = NUM ; bi + + ; count - - ; continue ; } code = datum & code mask ; datum > > = code size ; bits - = code size ; if ( ( code > available ) | | ( code = = end of information ) ) break ; if ( code = = clear ) { code size = data size + NUM ; code mask = ( NUM < < code size ) - NUM ; available = clear + NUM ; old code = Null Code ; continue ; } if ( old code = = Null Code ) { pixel Stack [ top + + ] = suffix [ code ] ; old code = code ; first = code ; continue ; } in code = code ; if ( code = = available ) { pixel Stack [ top + + ] = ( byte ) first ; code = old code ; } while ( code > clear ) { pixel Stack [ top + + ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( ( int ) suffix [ code ] ) & NUM ; if ( available > = Max Stack Size ) break ; pixel Stack [ top + + ] = ( byte ) first ; prefix [ available ] = ( short ) old code ; suffix [ available ] = ( byte ) first ; available + + ; if ( ( ( available & code mask ) = = NUM ) & & ( available < Max Stack Size ) ) { code size + + ; code mask + = available ; } old code = in code ; } top - - ; pixels [ pi + + ] = pixel Stack [ top ] ; i + + ; } for ( i = pi ; i < npix ; i + + ) { pixels [ i ] = NUM ; } }",
    "label": 1
  },
  {
    "text_1": "schedule runnable to run after everything that ' s on the queue right now .",
    "text_2": "public void post ( Runnable runnable ) { synchronized ( m Queue ) { m Queue . add ( runnable ) ; if ( m Queue . size ( ) = = NUM ) { schedule Next Locked ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "generates a version filename prepended with the stable storage directory path with the given version number as a suffix .",
    "text_2": "private String version Name ( String prefix , int ver ) { return f Name ( prefix ) + String . value Of ( ver ) ; }",
    "label": 1
  },
  {
    "text_1": "description - - - - - - - - - - - function performs the first step of the lanczos algorithm . it also does a step of extended local re - orthogon alization . arguments - - - - - - - - - ( input ) n dimension of the eigen problem for matrix b ( output ) i err error flag w ptr array of pointers that point to work space that contains w ptr [ 0 ] r [ j ] w ptr [ 1 ] q [ j ] w ptr [ 2 ] q [ j - 1 ] w ptr [ 3 ] p w ptr [ 4 ] p [ j - 1 ] w ptr [ 6 ] diagonal elements of matrix t functions used - - - - - - - - - - - - - - blas svd da x py , svd dat x , svd d copy , svd d dot , svd d sc al user store , opb las start v",
    "text_2": "static double f abs ( double a ) { return Math . abs ( a ) ; }",
    "label": 1
  },
  {
    "text_1": "searches this vector for the specified object .",
    "text_2": "@ Override public boolean contains ( Object object ) { return index Of ( object , NUM ) ! = - NUM ; }",
    "label": 1
  },
  {
    "text_1": "writes the entire contents of this byte stream to the specified output stream .",
    "text_2": "public synchronized void write To ( Output Stream out ) throws IO Exception { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM , c ) ; remaining - = c ; if ( remaining = = NUM ) { break ; } } }",
    "label": 1
  },
  {
    "text_1": "add not null entry to list",
    "text_2": "public static < V > boolean add List Not Null Value ( List < V > source List , V value ) { return ( source List ! = null & & value ! = null ) ? source List . add ( value ) : BOOL ; }",
    "label": 1
  },
  {
    "text_1": "append a int onto the vector .",
    "text_2": "public void add Element ( int value ) { int index Relative To Cache = m first Free - m build Cache Start Index ; if ( index Relative To Cache > = NUM & & index Relative To Cache < m blocksize ) { m build Cache [ index Relative To Cache ] = value ; + + m first Free ; } else { int index = m first Free > > > m SHIFT ; int offset = m first Free & m MASK ; if ( index > = m map . length ) { int newsize = index + m num blocks ; int [ ] [ ] new Map = new int [ newsize ] [ ] ; System . arraycopy ( m map , NUM , new Map , NUM , m map . length ) ; m map = new Map ; } int [ ] block = m map [ index ] ; if ( null = = block ) block = m map [ index ] = new int [ m blocksize ] ; block [ offset ] = value ; m build Cache = block ; m build Cache Start Index = m first Free - offset ; + + m first Free ; } }",
    "label": 1
  },
  {
    "text_1": "queries the user as to whether they would like to save their sessions .",
    "text_2": "public boolean close All Sessions ( ) { while ( exists Session ( ) ) { Session Editor session Editor = get Fron t most Session Editor ( ) ; Session Editor Workbench workbench = session Editor . get Session Workbench ( ) ; Session Wrapper wrapper = workbench . get Session Wrapper ( ) ; if ( ! wrapper . is Session Changed ( ) ) { close Fron t most Session ( ) ; continue ; } String name = session Editor . get Name ( ) ; int ret = J Option Pane . show Confirm Dialog ( J Option Utils . centering Comp ( ) , STRING + name + STRING , STRING , J Option Pane . YES NO CANCEL OPTION ) ; if ( ret = = J Option Pane . NO OPTION ) { close Fron t most Session ( ) ; continue ; } else if ( ret = = J Option Pane . CANCEL OPTION ) { return BOOL ; } Save Session As Action action = new Save Session As Action ( ) ; action . action Performed ( new Action Event ( this , Action Event . ACTION PERFORMED , STRING ) ) ; if ( ! action . is Saved ( ) ) { int ret NUM = J Option Pane . show Confirm Dialog ( J Option Utils . centering Comp ( ) , STRING , STRING , J Option Pane . OK CANCEL OPTION ) ; if ( ret NUM = = J Option Pane . CANCEL OPTION ) { return BOOL ; } } close Fron t most Session ( ) ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "converts a string into long values takes the first 8 bytes and uses those to convert them into long , if the string does not contain 8 bytes we pad them with zeros",
    "text_2": "protected static Long convert String To Bu ck ecting Long ( String string To Be Converted ) { if ( string To Be Converted = = null | | string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i + + ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }",
    "label": 1
  },
  {
    "text_1": "draws the block within the specified area .",
    "text_2": "@ Override public Object draw ( Graphics NUM D g NUM , Rectangle NUM D area , Object params ) { draw ( g NUM , area ) ; return null ; }",
    "label": 1
  },
  {
    "text_1": "2 . using foreach and map . entry",
    "text_2": "@ Benchmark public long test NUM Using For Each And Map Entry ( ) throws IO Exception { long i = NUM ; for ( Map . Entry < Integer , Integer > pair : map . entry Set ( ) ) { i + = pair . get Key ( ) + pair . get Value ( ) ; } return i ; }",
    "label": 1
  },
  {
    "text_1": "add a sub button with 4 params .",
    "text_2": "public Builder add Sub Button ( Context context , int drawable , int [ ] two Colors , String string ) { if ( drawables = = null ) drawables = new Array List < > ( ) ; drawables . add ( Context Compat . get Drawable ( context , drawable ) ) ; if ( colors = = null ) colors = new Array List < > ( ) ; colors . add ( two Colors ) ; if ( strings = = null ) strings = new Array List < > ( ) ; strings . add ( string ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "calling this method will check for the current time of the day and switches on / off the night mode .",
    "text_2": "private void check For Night ( final Zoned Date Time TIME ) { int hour = TIME . get Hour ( ) ; int minute = TIME . get Minute ( ) ; if ( NUM < = hour & & minute > = NUM & & hour < = NUM & & minute < = NUM | | NUM < = hour & & minute < = NUM & & hour < = NUM & & minute < = NUM ) { if ( is Night Mode ( ) ) return ; set Night Mode ( BOOL ) ; } else { if ( ! is Night Mode ( ) ) return ; set Night Mode ( BOOL ) ; } }",
    "label": 1
  },
  {
    "text_1": "converts special characters in ascii into html entities ( e . g . & - > & amp ; )",
    "text_2": "public static String encode ( String encode ) { String Builder str = new String Builder ( encode ) ; String key ; int i = NUM ; while ( i < str . length ( ) ) { key = find Value ( str . char At ( i ) ) ; if ( key ! = null ) { str . replace ( i , i + NUM , key ) ; i + = key . length ( ) ; } else { i + + ; } } return str . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "build a complete tree with 2 ^ n - 1 nodes .",
    "text_2": "static Binary Tree < Integer > build Complete ( int n ) { Binary Tree < Integer > bt = new Binary Tree < Integer > ( ) ; int b = ( int ) Math . pow ( NUM , n - NUM ) ; for ( int i = NUM ; i < n ; i + + ) { bt . insert ( b ) ; for ( int j = NUM ; j < = Math . pow ( NUM , i ) - NUM ; j + + ) { bt . insert ( b + NUM * b * j ) ; } b = b / NUM ; } return bt ; }",
    "label": 1
  },
  {
    "text_1": "removes all parts from the message",
    "text_2": "protected void clear ( ) { parts . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "after the screen rotates , this method will be called to refresh the list of grid views",
    "text_2": "public void on Configuration Changed ( ) { int cur First = pager . get Current Screen ( ) * PAGE SIZE ; cal Page Size ( ) ; int new Page = cur First / PAGE SIZE ; remove View At ( NUM ) ; after Platform List Got ( ) ; pager . set Current Screen ( new Page ) ; }",
    "label": 1
  },
  {
    "text_1": "parse cookie max - age attribute .",
    "text_2": "@ Override public void parse ( final Cookie cookie , final String value ) throws Malformed Cookie Exception { if ( cookie = = null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( value = = null ) { throw new Malformed Cookie Exception ( STRING ) ; } int age = - NUM ; try { age = Integer . parse Int ( value ) ; } catch ( final Number Format Exception e ) { age = - NUM ; } if ( age < NUM ) { throw new Malformed Cookie Exception ( STRING ) ; } cookie . set Expiry Date ( new Date ( System . current Time Millis ( ) + age * NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "checks the version of this class against the given version - string",
    "text_2": "@ Override public int compare To ( String o ) { int result ; int major ; int minor ; int revision ; int pnt ; int [ ] maj = new int [ NUM ] ; int [ ] min = new int [ NUM ] ; int [ ] rev = new int [ NUM ] ; int [ ] point = new int [ NUM ] ; parse Version ( o , maj , min , rev , point ) ; major = maj [ NUM ] ; minor = min [ NUM ] ; revision = rev [ NUM ] ; pnt = point [ NUM ] ; if ( MAJOR < major ) { result = - NUM ; } else if ( MAJOR = = major ) { if ( MINOR < minor ) { result = - NUM ; } else if ( MINOR = = minor ) { if ( REVISION < revision ) { result = - NUM ; } else if ( REVISION = = revision ) { if ( POINT < pnt ) { result = - NUM ; } else if ( POINT = = pnt ) { result = NUM ; } else { result = NUM ; } } else { result = NUM ; } } else { result = NUM ; } } else { result = NUM ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "constructs a widget completion proposal computer .",
    "text_2": "public Widget Proposal Computer ( String text , int offset , Element root Element , Element parent Element , I Java Project java Project ) throws Java Model Exception , Ui Binder Exception { super ( java Project , text , offset , text . length ( ) ) ; this . root Element = root Element ; this . parent Element = parent Element ; package Manager . read From Element ( root Element ) ; }",
    "label": 1
  },
  {
    "text_1": "logs a purchase event with facebook , in the specified amount and with the specified currency . additional detail about the purchase can be passed in through the parameters bundle .",
    "text_2": "public void log Purchase ( Big Decimal purchase Amount , Currency currency , Bundle parameters ) { if ( purchase Amount = = null ) { notify Developer Error ( STRING ) ; return ; } else if ( currency = = null ) { notify Developer Error ( STRING ) ; return ; } if ( parameters = = null ) { parameters = new Bundle ( ) ; } parameters . put String ( App Events Constants . EVENT PARAM CURRENCY , currency . get Currency Code ( ) ) ; log Event ( App Events Constants . EVENT NAME PUR CHA SED , purchase Amount . double Value ( ) , parameters ) ; eager Flush ( ) ; }",
    "label": 1
  },
  {
    "text_1": "set bounds for the right textview including clip padding .",
    "text_2": "private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }",
    "label": 1
  },
  {
    "text_1": "appends a parameter type to the parameter list represented by the given descriptor . the appended parameter becomes the last parameter .",
    "text_2": "public static String append Parameter ( Ct Class type , String descriptor ) { int i = descriptor . index Of ( STRING ) ; if ( i < NUM ) return descriptor ; else { String Buffer new desc = new String Buffer ( ) ; new desc . append ( descriptor . substring ( NUM , i ) ) ; to Descriptor ( new desc , type ) ; new desc . append ( descriptor . substring ( i ) ) ; return new desc . to String ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "removes the given categories from the entry with the given name .",
    "text_2": "public synchronized Addressbook Entry remove ( String name , Set < String > categories To Remove ) { name = String Util . to Lower Case ( name ) ; Addressbook Entry current Entry = entries . get ( name ) ; if ( current Entry ! = null ) { Set < String > current Categories = current Entry . get Categories ( ) ; for ( String category : categories To Remove ) { current Categories . remove ( category ) ; } Addressbook Entry changed Entry = new Addressbook Entry ( name , current Categories ) ; entries . put ( name , changed Entry ) ; if ( ! current Entry . equals Fully ( changed Entry ) ) { save On Change ( ) ; } return changed Entry ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "rounds a double to the next nearest integer value . the jdk version of it doesn ' t work properly .",
    "text_2": "public static int round ( double value ) { int rounded Value = value > NUM ? ( int ) ( value + NUM ) : - ( int ) ( Math . abs ( value ) + NUM ) ; return rounded Value ; }",
    "label": 1
  },
  {
    "text_1": "queries with a deadline that lies significantly in the future can lie around in the priority queue until that deadline is reached if there are other queries in front of them that are not terminated and whose deadline has not be reached . therefore , periodically , we need to scan the queue and clear out entries for terminated queries .",
    "text_2": "static private void scan Deadline Queue ( final long now Nanos , final Priority Blocking Queue < Query Deadline > deadline Queue ) { final List < Query Deadline > c = new Array List < Query Deadline > ( DEAD LINE QUEUE SCAN SIZE ) ; deadline Queue . drain To ( c , DEAD LINE QUEUE SCAN SIZE ) ; int nd rop ped = NUM , n running = NUM ; for ( Query Deadline x : c ) { if ( x . check Deadline ( now Nanos ) ! = null ) { deadline Queue . add ( x ) ; n running + + ; } else { nd rop ped + + ; } } if ( log . is Info Enabled ( ) ) log . info ( STRING + DEAD LINE QUEUE SCAN SIZE + STRING + nd rop ped + STRING + n running + STRING + deadline Queue . size ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "counts the number of contained key - value pairs .",
    "text_2": "public int count ( ) { return dict . size ( ) ; }",
    "label": 1
  },
  {
    "text_1": "updates the locations for both thum bs .",
    "text_2": "@ Override protected void calculate Thumb Location ( ) { super . calculate Thumb Location ( ) ; if ( slider . get Snap To Ticks ( ) ) { int upper Value = slider . get Value ( ) + slider . get Extent ( ) ; int snapped Value = upper Value ; int major Tick Spacing = slider . get Major Tick Spacing ( ) ; int minor Tick Spacing = slider . get Minor Tick Spacing ( ) ; int tick Spacing = NUM ; if ( minor Tick Spacing > NUM ) { tick Spacing = minor Tick Spacing ; } else if ( major Tick Spacing > NUM ) { tick Spacing = major Tick Spacing ; } if ( tick Spacing ! = NUM ) { if ( ( upper Value - slider . get Minimum ( ) ) % tick Spacing ! = NUM ) { float temp = ( float ) ( upper Value - slider . get Minimum ( ) ) / ( float ) tick Spacing ; int which Tick = Math . round ( temp ) ; snapped Value = slider . get Minimum ( ) + ( which Tick * tick Spacing ) ; } if ( snapped Value ! = upper Value ) { slider . set Extent ( snapped Value - slider . get Value ( ) ) ; } } } if ( slider . get Orientation ( ) = = J Slider . HORIZONTAL ) { int upper Position = x Position For Value ( slider . get Value ( ) + slider . get Extent ( ) ) ; upper Thumb Rect . x = upper Position - ( upper Thumb Rect . width / NUM ) ; upper Thumb Rect . y = track Rect . y ; } else { int upper Position = y Position For Value ( slider . get Value ( ) + slider . get Extent ( ) ) ; upper Thumb Rect . x = track Rect . x ; upper Thumb Rect . y = upper Position - ( upper Thumb Rect . height / NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "draw the background for the projection . assume that the graphics has been set with the paint / color needed , just render the shape of the background .",
    "text_2": "public void draw Background ( Graphics g ) { g . fill Rect ( NUM , NUM , get Width ( ) , get Height ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "paints the background of the area behind the tabs of a tabbed pane . this implementation invokes the method of the same name without the orientation .",
    "text_2": "public void paint Tabbed Pane Tab Area Background ( Synth Context context , Graphics g , int x , int y , int w , int h , int orientation ) { if ( orientation = = J Tabbed Pane . LEFT ) { Affine Transform transform = new Affine Transform ( ) ; transform . scale ( - NUM , NUM ) ; transform . rotate ( Math . to Radians ( NUM ) ) ; paint Background ( context , g , y , x , h , w , transform ) ; } else if ( orientation = = J Tabbed Pane . RIGHT ) { Affine Transform transform = new Affine Transform ( ) ; transform . rotate ( Math . to Radians ( NUM ) ) ; transform . translate ( NUM , - ( x + w ) ) ; paint Background ( context , g , y , NUM , h , w , transform ) ; } else if ( orientation = = J Tabbed Pane . BOTTOM ) { Affine Transform transform = new Affine Transform ( ) ; transform . translate ( x , y ) ; paint Background ( context , g , NUM , NUM , w , h , transform ) ; } else { paint Background ( context , g , x , y , w , h , null ) ; } }",
    "label": 1
  },
  {
    "text_1": "this method will convert list of byte array to list of string",
    "text_2": "private List < String > convert Byte Array List To String Value List ( List < byte [ ] > dictionary Byte Array List ) { List < String > value List = new Array List < > ( dictionary Byte Array List . size ( ) ) ; for ( byte [ ] value : dictionary Byte Array List ) { value List . add ( new String ( value , Charset . for Name ( Carbon Common Constants . DEFAULT CHARSET ) ) ) ; } return value List ; }",
    "label": 1
  },
  {
    "text_1": "prints a single stack trace element .",
    "text_2": "private static void print Stack Trace Element ( Stack Trace Element trace , Print Writer out , Class Loader loader ) { try { Line Map map = get Script Line Map ( trace . get Class Name ( ) , loader ) ; if ( map ! = null ) { Line Map . Line line = map . get Line ( trace . get Line Number ( ) ) ; if ( line ! = null ) { out . print ( trace . get Class Name ( ) + STRING + trace . get Method Name ( ) ) ; out . print ( STRING + line . get Source Filename ( ) + STRING ) ; out . println ( line . get Source Line ( trace . get Line Number ( ) ) + STRING ) ; return ; } } } catch ( Throwable e ) { } out . println ( trace ) ; }",
    "label": 1
  },
  {
    "text_1": "create a replication job to copy a table .",
    "text_2": "public Replication Job create Job For Copy Table ( long audit Log Id , long audit Log Entry Create Time , Table table ) throws State Update Exception { Replication Operation replication Operation = Hive Utils . is Partitioned ( table ) ? Replication Operation . COPY PARTITIONED TABLE : Replication Operation . COPY UN PARTITIONED TABLE ; Map < String , String > extras = new Hash Map < > ( ) ; extras . put ( Persisted Job Info . AUDIT LOG ID EXTRAS KEY , Long . to String ( audit Log Id ) ) ; extras . put ( Persisted Job Info . AUDIT LOG ENTRY CREATE TIME KEY , Long . to String ( audit Log Entry Create Time ) ) ; Persisted Job Info persisted Job Info = job Info Store . res ilient Create ( replication Operation , Replication Status . PENDING , Replication Utils . get Location ( table ) , src Cluster . get Name ( ) , new Hive Object Spec ( table ) , Collections . empty List ( ) , Replication Utils . get T ldt ( table ) , Optional . empty ( ) , Optional . empty ( ) , extras ) ; Hive Object Spec spec = new Hive Object Spec ( table ) ; Optional < Path > table Location = Replication Utils . get Location ( table ) ; switch ( replication Operation ) { case COPY UN PARTITIONED TABLE : return new Replication Job ( conf , new Copy Un partitioned Table Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec , table Location , directory Copier , BOOL ) , on State Change Handler , persisted Job Info ) ; case COPY PARTITIONED TABLE : return new Replication Job ( conf , new Copy Partitioned Table Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec , table Location ) , on State Change Handler , persisted Job Info ) ; default : throw new Runtime Exception ( STRING + replication Operation ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "call this from a drag source view .",
    "text_2": "public boolean on Intercept Touch Event ( Motion Event ev ) { @ Suppress Warnings ( STRING ) final boolean debug = BOOL ; if ( debug ) { Log . d ( Launcher . TAG , STRING + ev + STRING + m Dragging ) ; } acquire Velocity Tracker And Add Movement ( ev ) ; final int action = ev . get Action ( ) ; final int [ ] drag Layer Pos = get Cl amped Drag Layer Pos ( ev . get X ( ) , ev . get Y ( ) ) ; final int drag Layer X = drag Layer Pos [ NUM ] ; final int drag Layer Y = drag Layer Pos [ NUM ] ; switch ( action ) { case Motion Event . ACTION MOVE : break ; case Motion Event . ACTION DOWN : m Motion Down X = drag Layer X ; m Motion Down Y = drag Layer Y ; m Last Drop Target = null ; break ; case Motion Event . ACTION UP : m Last Touch Up Time = System . current Time Millis ( ) ; if ( m Dragging ) { Point F vec = is Flin ging To Delete ( m Drag Object . drag Source ) ; if ( ! Delete Drop Target . will Accept Drop ( m Drag Object . drag Info ) ) { vec = null ; } if ( vec ! = null ) { drop On Fling To Delete Target ( drag Layer X , drag Layer Y , vec ) ; } else { drop ( drag Layer X , drag Layer Y ) ; } } end Drag ( ) ; break ; case Motion Event . ACTION CANCEL : cancel Drag ( ) ; break ; } return m Dragging ; }",
    "label": 1
  },
  {
    "text_1": "static method to show the progress bar by sending an integer when receiving data from the socket",
    "text_2": "public static void show Progress Bar ( int status , int i ) { if ( m Root View ! = null ) { Progress Bar pb = ( Progress Bar ) m Root View . find View By Id ( R . id . progress slice ) ; Text View tv = ( Text View ) m Root View . find View By Id ( R . id . viewer text progress slice ) ; Text View tve = ( Text View ) m Root View . find View By Id ( R . id . viewer text estimated time ) ; Text View tve title = ( Text View ) m Root View . find View By Id ( R . id . viewer estimated time textview ) ; if ( m Slicing Handler . get Last Reference ( ) ! = null ) { tve title . set Visibility ( View . VISIBLE ) ; pb . set Visibility ( View . VISIBLE ) ; switch ( status ) { case State Utils . S LIC ER HIDE : if ( i < NUM ) { tv . set Text ( R . string . error ) ; } else { tv . set Text ( R . string . viewer text downloaded ) ; } pb . set Visibility ( View . INVISIBLE ) ; break ; case State Utils . S LIC ER UPLOAD : String upload Text = m Context . get String ( R . string . viewer text up loading ) ; if ( i = = NUM ) pb . set Indeterminate ( BOOL ) ; else { pb . set Progress ( i ) ; pb . set Indeterminate ( BOOL ) ; upload Text + = STRING + i + STRING ; } tv . set Text ( upload Text ) ; tve . set Text ( null ) ; break ; case State Utils . S LIC ER SLICE : String slicing Text = m Context . get String ( R . string . viewer text slicing ) ; if ( i = = NUM ) { pb . set Indeterminate ( BOOL ) ; } else if ( i = = NUM ) { pb . set Indeterminate ( BOOL ) ; pb . set Progress ( NUM ) ; slicing Text + = STRING + m Context . get String ( R . string . viewer text done ) ; } else { pb . set Progress ( i ) ; pb . set Indeterminate ( BOOL ) ; slicing Text + = STRING + i + STRING ; } tv . set Text ( slicing Text ) ; tve . set Text ( null ) ; m Root View . invalidate ( ) ; break ; case State Utils . S LIC ER DOWNLOAD : if ( i > NUM ) { tve . set Text ( Oc top rint Connection . Convert Second To H HMM String ( String . value Of ( i ) ) ) ; } tv . set Text ( R . string . viewer text downloading ) ; pb . set Indeterminate ( BOOL ) ; break ; default : break ; } } else { pb . set Visibility ( View . INVISIBLE ) ; tve title . set Visibility ( View . INVISIBLE ) ; tv . set Text ( null ) ; tve . set Text ( null ) ; m Root View . invalidate ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "remove all - x boot classpath / p : or - j - x boot classpath / p : arguments from args and add them to the returned list",
    "text_2": "protected static List < String > extract Boot Class Path ( final List < String > args ) { return extract Opt With Pattern ( BOOT CLASS PATH REGEX , BOOL , args ) ; }",
    "label": 1
  },
  {
    "text_1": "checks whether password is ok .",
    "text_2": "public void check Password ( String password ) throws Bad Request Exception { if ( password = = null ) { throw new Bad Request Exception ( STRING ) ; } if ( password . length ( ) < NUM ) { throw new Bad Request Exception ( STRING ) ; } int num Of Letters = NUM ; int num Of Digits = NUM ; for ( char password Char : password . to Char Array ( ) ) { if ( Character . is Digit ( password Char ) ) { num Of Digits + + ; } else if ( Character . is Letter ( password Char ) ) { num Of Letters + + ; } } if ( num Of Digits = = NUM | | num Of Letters = = NUM ) { throw new Bad Request Exception ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "update a content assoc service . the work is done in a separate method so that complex services that need this functionality do not need to incur the reflection performance penalty .",
    "text_2": "public static Map < String , Object > deactivate Content Assoc ( Dispatch Context dctx , Map < String , ? extends Object > r context ) { Map < String , Object > context = Util Misc . make Map Writable ( r context ) ; context . put ( STRING , STRING ) ; List < String > target Operation List = Content Worker . prep Target Operation List ( context , STRING ) ; List < String > content Purpose List = Content Worker . prep Content Purpose List ( context ) ; context . put ( STRING , target Operation List ) ; context . put ( STRING , content Purpose List ) ; context . put ( STRING , null ) ; Map < String , Object > result = deactivate Content Assoc Method ( dctx , context ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "method opens dialog to add existing application insights resource in list .",
    "text_2": "protected void add Button Listener ( ) { Application Insights Add Dialog dialog = new Application Insights Add Dialog ( get Shell ( ) ) ; dialog . open ( ) ; table Viewer . refresh ( ) ; }",
    "label": 1
  },
  {
    "text_1": "true if the table has added columns .",
    "text_2": "public boolean is Alter Add ( ) { return columns To Add . size ( ) > NUM ; }",
    "label": 1
  },
  {
    "text_1": "create the bucket with the given key",
    "text_2": "protected Bucket < T > create Bucket ( long bucket Key ) { return new Bucket < T > ( bucket Key ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the domain name .",
    "text_2": "@ Override public String to String ( ) { return xml File . get Name ( ) ; }",
    "label": 1
  },
  {
    "text_1": "determines the height of this view",
    "text_2": "private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode = = Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode = = Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "clamp the magnitude of value for absmin and absmax . if the value is below the minimum , it will be clamped to zero . if the value is above the maximum , it will be clamped to the maximum .",
    "text_2": "private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }",
    "label": 1
  },
  {
    "text_1": "returns an iterator over this group of headers .",
    "text_2": "public Header Iterator iterator ( ) { return new Basic List Header Iterator ( this . headers , null ) ; }",
    "label": 1
  },
  {
    "text_1": "save the current configuration",
    "text_2": "public boolean save Current Configuration ( ) { if ( current Config . to String ( ) = = null ) { return ( BOOL ) ; } int answer = J Option Pane . show Confirm Dialog ( null , STRING , STRING , J Option Pane . YES NO CANCEL OPTION , J Option Pane . QUESTION MESSAGE , Icons . get Image Icon ( STRING ) ) ; if ( answer = = J Option Pane . CANCEL OPTION ) { return ( BOOL ) ; } else if ( answer = = J Option Pane . NO OPTION ) { return ( BOOL ) ; } return ( save Current Configuration As ( BOOL ) ) ; }",
    "label": 1
  },
  {
    "text_1": "blocks the current thread until the event arrives or the timeout expires .",
    "text_2": "public void wait For Event ( long timeout ) { Thread thread = Thread . current Thread ( ) ; Semaphore semaphore = sem ap ho res . get ( thread ) ; if ( semaphore = = null ) { semaphore = new Semaphore ( NUM , BOOL ) ; semaphore . drain Permits ( ) ; sem ap ho res . put If Absent ( thread , semaphore ) ; } semaphore = sem ap ho res . get ( thread ) ; try { semaphore . try Acquire ( timeout , Time Unit . MILLISECONDS ) ; } catch ( Interrupted Exception exception ) { logger . log ( Level . FINER , STRING , exception ) ; } }",
    "label": 1
  },
  {
    "text_1": "clean the patch version files , such as tin ker / patch - e 6 34 c",
    "text_2": "public void clean Patch By Version ( String version Name ) { if ( patch Directory = = null | | version Name = = null ) { return ; } String path = patch Directory . get Absolute Path ( ) + STRING + version Name ; Share Patch File Util . delete Dir ( path ) ; }",
    "label": 1
  },
  {
    "text_1": "terminates all threads , ending all discovery processing being performed by the current instance of this class . after this method has been invoked , no new lookup services will be discovered , and the effect of any new operations performed on the current instance of this class are undefined .",
    "text_2": "public void terminate ( ) { listeners . clear ( ) ; lookup Disc . terminate ( ) ; locator Disc . terminate ( ) ; if ( dynamic Locator Disc ! = null ) dynamic Locator Disc . terminate ( ) ; }",
    "label": 1
  },
  {
    "text_1": "handle an extension function .",
    "text_2": "public Object ext Function ( String ns , String func Name , Vector arg Vec , Object method Key , Expression Context expr Context ) throws javax . xml . transform . Transformer Exception { Object result = null ; if ( null ! = ns ) { Extension Handler ext NS = ( Extension Handler ) m extension Function Namespaces . get ( ns ) ; if ( null ! = ext NS ) { try { result = ext NS . call Function ( func Name , arg Vec , method Key , expr Context ) ; } catch ( javax . xml . transform . Transformer Exception e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . Transformer Exception ( e ) ; } } else { throw new X Path Processor Exception ( XSL Messages . create Message ( XSLT Error Resources . ER EXTENSION FUNC UNKNOWN , new Object [ ] { ns , func Name } ) ) ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "saves the oath device settings to the user ' s profile , overwriting any existing device profile .",
    "text_2": "void save Device Profile ( @ Nonnull String user , @ Nonnull String realm , @ Nonnull O ath Device Settings device Settings ) throws Auth Login Exception { Reject . if Null ( user , realm , device Settings ) ; try { devices Dao . save Device Profiles ( user , realm , json Utils . to Json Values ( Collections . singleton List ( device Settings ) ) ) ; } catch ( IO Exception e ) { debug . error ( STRING , user , realm , e ) ; throw new Auth Login Exception ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "new long array : create a new long array",
    "text_2": "private static int New Long Array ( JNI Environment env , int length ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { long [ ] new Array = new long [ length ] ; return env . push JNI Ref ( new Array ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }",
    "label": 1
  },
  {
    "text_1": "computes a score factor for a phrase . the default implementation sums the idf factor for each term in the phrase .",
    "text_2": "public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) = = - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > details = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; details . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf + = term Idf ; } return Explanation . match ( idf , STRING , details ) ; }",
    "label": 1
  },
  {
    "text_1": "creates job create request using a specified namespace code and job name , but test hard coded parameters will be used .",
    "text_2": "public Job Create Request create Job Create Request ( String namespace Cd , String job Name ) { List < Parameter > parameters = new Array List < > ( ) ; Parameter parameter = new Parameter ( Abstract Service Test . ATTRIBUTE NAME NUM MIXED CASE , Abstract Service Test . ATTRIBUTE VALUE NUM ) ; parameters . add ( parameter ) ; parameter = new Parameter ( STRING , null ) ; parameters . add ( parameter ) ; return create Job Create Request ( namespace Cd , job Name , parameters ) ; }",
    "label": 1
  },
  {
    "text_1": "create the managed protection set associated with the ingested rp volumes . also , as a side - effect , insert the protection set id into each of the imp acted volumes .",
    "text_2": "private Protection Set create Protection Set ( Recover Point Volume Ingestion Context volume Context ) { Un Managed Protection Set umpset = volume Context . get Un Managed Protection Set ( ) ; Protection Set pset = Volume Ingestion Util . find Or Create Protection Set ( volume Context , volume Context . get Unmanaged Volume ( ) , umpset , db Client ) ; volume Context . set Managed Protection Set ( pset ) ; return pset ; }",
    "label": 1
  },
  {
    "text_1": "actions a pull event",
    "text_2": "private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value ! = NUM & & ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State ! = State . PULL TO REFRESH & & item Dimension > = Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State = = State . PULL TO REFRESH & & item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }",
    "label": 1
  },
  {
    "text_1": "returns the number of introspected methods / properties that should be available via the template hash model interface .",
    "text_2": "int key Count ( Class clazz ) { Map map = get ( clazz ) ; int count = map . size ( ) ; if ( map . contains Key ( CONSTRUCT ORS KEY ) ) count - - ; if ( map . contains Key ( GENERIC GET KEY ) ) count - - ; if ( map . contains Key ( ARG TYPES KEY ) ) count - - ; return count ; }",
    "label": 1
  },
  {
    "text_1": "setting the list of grants to null is not allowed .",
    "text_2": "public @ Test final void test Set Users Negative ( ) { Role role = new Role ( TEST ROLE ) ; thrown . expect ( Illegal Argument Exception . class ) ; role . set Users ( null ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a file to the classpath if it exists .",
    "text_2": "public void add File ( String filename ) { if ( filename ! = null ) add File ( new File ( filename ) ) ; }",
    "label": 1
  },
  {
    "text_1": "read headers from the http response and store them into local state .",
    "text_2": "private void read Response Headers ( State state , Inner State inner State , Http Response response ) throws Stop Request { Header header = response . get First Header ( STRING ) ; if ( header ! = null ) { inner State . m Header Content Disposition = header . get Value ( ) ; } header = response . get First Header ( STRING ) ; if ( header ! = null ) { inner State . m Header Content Location = header . get Value ( ) ; } header = response . get First Header ( STRING ) ; if ( header ! = null ) { inner State . m Header E Tag = header . get Value ( ) ; } String header Transfer Encoding = null ; header = response . get First Header ( STRING ) ; if ( header ! = null ) { header Transfer Encoding = header . get Value ( ) ; } String header Content Type = null ; header = response . get First Header ( STRING ) ; if ( header ! = null ) { header Content Type = header . get Value ( ) ; if ( ! header Content Type . equals ( STRING ) ) { throw new Stop Request ( Downloader Service . STATUS FILE DELIVERED IN COR RECT LY , STRING ) ; } } if ( header Transfer Encoding = = null ) { header = response . get First Header ( STRING ) ; if ( header ! = null ) { inner State . m Header Content Length = header . get Value ( ) ; long content Length = Long . parse Long ( inner State . m Header Content Length ) ; if ( content Length ! = - NUM & & content Length ! = m Info . m Total Bytes ) { Log . e ( Constants . TAG , STRING ) ; } } } else { if ( Constants . LOG VV ) { Log . v ( Constants . TAG , STRING ) ; } } if ( Constants . LOG VV ) { Log . v ( Constants . TAG , STRING + inner State . m Header Content Disposition ) ; Log . v ( Constants . TAG , STRING + inner State . m Header Content Length ) ; Log . v ( Constants . TAG , STRING + inner State . m Header Content Location ) ; Log . v ( Constants . TAG , STRING + inner State . m Header E Tag ) ; Log . v ( Constants . TAG , STRING + header Transfer Encoding ) ; } boolean no Size Info = inner State . m Header Content Length = = null & & ( header Transfer Encoding = = null | | ! header Transfer Encoding . equals Ignore Case ( STRING ) ) ; if ( no Size Info ) { throw new Stop Request ( Downloader Service . STATUS HTTP DATA ERROR , STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "animate the bottom edge of the challenge view to the given position .",
    "text_2": "void animate Challenge To ( int y , int velocity ) { if ( m Challenge View = = null ) { return ; } cancel Transitions In Progress ( ) ; m Challenge Interactive Internal = BOOL ; m Challenge View . set Layer Type ( LAYER TYPE HARDWARE , null ) ; final int sy = m Challenge View . get Bottom ( ) ; final int dy = y - sy ; if ( dy = = NUM ) { complete Challenge Scroll ( ) ; return ; } set Scroll State ( SCROLL STATE SETT LING ) ; final int child Height = m Challenge View . get Height ( ) ; final int half Height = child Height / NUM ; final float distance Ratio = Math . min ( NUM , NUM * Math . abs ( dy ) / child Height ) ; final float distance = half Height + half Height * distance Influence For Snap Duration ( distance Ratio ) ; int duration = NUM ; velocity = Math . abs ( velocity ) ; if ( velocity > NUM ) { duration = NUM * Math . round ( NUM * Math . abs ( distance / velocity ) ) ; } else { final float child Delta = ( float ) Math . abs ( dy ) / child Height ; duration = ( int ) ( ( child Delta + NUM ) * NUM ) ; } duration = Math . min ( duration , MAX SETT LE DURATION ) ; m Scroller . start Scroll ( NUM , sy , NUM , dy , duration ) ; post Invalidate On Animation ( ) ; }",
    "label": 1
  },
  {
    "text_1": "read bytes . watch out , read may return fewer bytes than requested .",
    "text_2": "public final int read ( byte ba [ ] , int off , int len ) throws IO Exception { return is . read ( ba , off , len ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a sliding window from text",
    "text_2": "public static Window window For Word In Position ( int window Size , int word Pos , List < String > sentence ) { List < String > window = new Array List < > ( ) ; List < String > only Tokens = new Array List < > ( ) ; int context Size = ( int ) Math . floor ( ( window Size - NUM ) / NUM ) ; for ( int i = word Pos - context Size ; i < = word Pos + context Size ; i + + ) { if ( i < NUM ) window . add ( STRING ) ; else if ( i > = sentence . size ( ) ) window . add ( STRING ) ; else { only Tokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } String whole Sentence = String Utils . join ( sentence ) ; String window NUM = String Utils . join ( only Tokens ) ; int begin = whole Sentence . index Of ( window NUM ) ; int end = begin + window NUM . length ( ) ; return new Window ( window , begin , end ) ; }",
    "label": 1
  },
  {
    "text_1": "fill a 2d array of floats with 0 . 0",
    "text_2": "static void zero ( float [ ] [ ] array ) { for ( float [ ] a Float : array ) { Arrays . fill ( a Float , - NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a new d get alias dialog .",
    "text_2": "public D Get Alias ( J Frame parent , String title , String alias ) { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; init Components ( alias ) ; }",
    "label": 1
  },
  {
    "text_1": "process a received packet .",
    "text_2": "protected void process packet ( Sim Event ev ) { Cloud Sim . cancel All ( get Id ( ) , new Predicate Type ( Cloud Sim Tags . Network Event UP ) ) ; schedule ( get Id ( ) , swit ching delay , Cloud Sim Tags . Network Event UP ) ; pktlist . add ( ( Network Packet ) ev . get Data ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "remove a catch able pokemon from the cache",
    "text_2": "public void remove Cat chable ( Cat chable Pokemon pokemon ) { if ( cached Cat chable . size ( ) > NUM ) { cached Cat chable . remove ( pokemon ) ; } }",
    "label": 1
  },
  {
    "text_1": "xor for a positive number and zero",
    "text_2": "public void test Pos Zero ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize the desktop pane ui settings .",
    "text_2": "private void define Desktop Panes ( UI Defaults d ) { d . put ( STRING , new Color UI Resource ( NUM ) ) ; String c = PAINTER PREFIX + STRING ; String p = STRING ; d . put ( p + STRING , new Lazy Painter ( c , Desktop Pane Painter . Which . BACKGROUND ENABLED ) ) ; p = STRING ; c = PAINTER PREFIX + STRING ; d . put ( p + STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Desktop Icon Painter . Which . BACKGROUND ENABLED ) ) ; }",
    "label": 1
  },
  {
    "text_1": "determine if methodname of classname can be called through the target class",
    "text_2": "public boolean is Called Method ( String class Name , String method Name ) { if ( to Test Methods . is Empty ( ) ) compute Interesting Classes ( graph ) ; if ( to Test Methods . contains ( class Name + method Name ) ) { return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "checks that the service name matches in header and body .",
    "text_2": "public static void validate Service Name ( String service Code , String service Name ) { if ( ! service Name . starts With ( service Code ) ) { throw new Coded Exception ( X IN CONSISTENT HEADERS , STRING + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a new horizontal separator to the notifications list .",
    "text_2": "private void add Notification Category Separator ( J Panel panel ) { J Separator j sep = new J Separator ( Swing Constants . HORIZONTAL ) ; j sep . set Maximum Size ( new Dimension ( Short . MAX VALUE , NUM ) ) ; panel . add ( j sep ) ; }",
    "label": 1
  },
  {
    "text_1": "a static method to write a line to a buffe redo utputstream and then pass the line to the log method of the supplied pircbot instance .",
    "text_2": "static void send Raw Line ( Pi rc Bot bot , Buffered Writer bwriter , String line ) { if ( line . length ( ) > bot . get Max Line Length ( ) - NUM ) { line = line . substring ( NUM , bot . get Max Line Length ( ) - NUM ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + STRING ) ; bwriter . flush ( ) ; } catch ( Exception e ) { } } }",
    "label": 1
  },
  {
    "text_1": "remove a user from the specified channel in our memory .",
    "text_2": "private final User remove User ( String channel , String nick ) { channel = channel . to Lower Case ( ) ; User user = new User ( STRING , nick ) ; synchronized ( channels ) { Hashtable < User , User > users = channels . get ( channel ) ; if ( users ! = null ) { return users . remove ( user ) ; } } return null ; }",
    "label": 1
  },
  {
    "text_1": "encode parts of the message using text compaction as described in iso / iec 154 38 : 2001 ( e ) , chapter 4 . 4 . 2 .",
    "text_2": "private static int encode Text ( Char Sequence msg , int startpos , int count , String Builder sb , int initial Sub mode ) { String Builder tmp = new String Builder ( count ) ; int submode = initial Sub mode ; int idx = NUM ; while ( BOOL ) { char ch = msg . char At ( startpos + idx ) ; switch ( submode ) { case SUBMODE ALPHA : if ( is Alpha Upper ( ch ) ) { if ( ch = = STRING ) { tmp . append ( ( char ) NUM ) ; } else { tmp . append ( ( char ) ( ch - NUM ) ) ; } } else { if ( is Alpha Lower ( ch ) ) { submode = SUBMODE LOWER ; tmp . append ( ( char ) NUM ) ; continue ; } else if ( is Mixed ( ch ) ) { submode = SUBMODE MIXED ; tmp . append ( ( char ) NUM ) ; continue ; } else { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE LOWER : if ( is Alpha Lower ( ch ) ) { if ( ch = = STRING ) { tmp . append ( ( char ) NUM ) ; } else { tmp . append ( ( char ) ( ch - NUM ) ) ; } } else { if ( is Alpha Upper ( ch ) ) { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) ( ch - NUM ) ) ; break ; } else if ( is Mixed ( ch ) ) { submode = SUBMODE MIXED ; tmp . append ( ( char ) NUM ) ; continue ; } else { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE MIXED : if ( is Mixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( is Alpha Upper ( ch ) ) { submode = SUBMODE ALPHA ; tmp . append ( ( char ) NUM ) ; continue ; } else if ( is Alpha Lower ( ch ) ) { submode = SUBMODE LOWER ; tmp . append ( ( char ) NUM ) ; continue ; } else { if ( startpos + idx + NUM < count ) { char next = msg . char At ( startpos + idx + NUM ) ; if ( is Punctuation ( next ) ) { submode = SUBMODE PUNCTUATION ; tmp . append ( ( char ) NUM ) ; continue ; } } tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( is Punctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE ALPHA ; tmp . append ( ( char ) NUM ) ; continue ; } } idx + + ; if ( idx > = count ) { break ; } } char h = NUM ; int len = tmp . length ( ) ; for ( int i = NUM ; i < len ; i + + ) { boolean odd = ( i % NUM ) ! = NUM ; if ( odd ) { h = ( char ) ( ( h * NUM ) + tmp . char At ( i ) ) ; sb . append ( h ) ; } else { h = tmp . char At ( i ) ; } } if ( ( len % NUM ) ! = NUM ) { sb . append ( ( char ) ( ( h * NUM ) + NUM ) ) ; } return submode ; }",
    "label": 1
  },
  {
    "text_1": "returns a form of \" s \" appropriate for including in an xml document , after escaping certain special characters ( e . g . ' & ' = > ' & amp ; ' , etc . )",
    "text_2": "public static String xml Escape ( String s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i + + ) { char ch = s . char At ( i ) ; switch ( ch ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : break ; default : sb . append ( ch ) ; break ; } } return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "make the attached node stop acting on drag actions by removing drag event handlers",
    "text_2": "public void remove Drag Event Handlers ( ) { node . remove Event Handler ( Touch Event . ANY , touch Handler ) ; node . remove Event Handler ( Mouse Event . ANY , mouse Handler ) ; }",
    "label": 1
  },
  {
    "text_1": "copy nodelist members into this nodelist , adding in document order . null references are not added .",
    "text_2": "public void add Nodes ( Node Iterator iterator ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; if ( null ! = iterator ) { Node obj ; while ( null ! = ( obj = iterator . next Node ( ) ) ) { add Element ( obj ) ; } } }",
    "label": 1
  },
  {
    "text_1": "attempts to do an in - place rewrite of the exif metadata . if this fails , fall back to overwriting file . this preserves tags that are not being rewritten .",
    "text_2": "public void force Rewrite Exif ( String filename , Collection < Exif Tag > tags ) throws File Not Found Exception , IO Exception { if ( ! rewrite Exif ( filename , tags ) ) { Exif Data temp Data = m Data ; m Data = new Exif Data ( DEFAULT BYTE ORDER ) ; File Input Stream is = null ; Byte Array Output Stream bytes = null ; try { is = new File Input Stream ( filename ) ; bytes = new Byte Array Output Stream ( ) ; do Exif Stream IO ( is , bytes ) ; byte [ ] image Bytes = bytes . to Byte Array ( ) ; read Exif ( image Bytes ) ; set Tags ( tags ) ; write Exif ( image Bytes , filename ) ; } catch ( IO Exception e ) { close Silently ( is ) ; throw e ; } finally { is . close ( ) ; m Data = temp Data ; } } }",
    "label": 1
  },
  {
    "text_1": "currently we assume the ' click screen ' is relevant to platform 5 and 4",
    "text_2": "public boolean is Click Touch Screen ( ) { String s = Device Info . get Software Version ( ) ; if ( s . length ( ) > NUM ) { int v = Integer . parse Int ( s . substring ( NUM , NUM ) ) ; return v < = NUM ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "helper method for test methods that retrieve metadata expecting no results .",
    "text_2": "private void validate Table Meta Data No Row ( String table Name Pattern , String [ ] types ) throws Exception { try ( Result Set tables = dbmd . get Tables ( null , null , table Name Pattern , types ) ) { assert False ( String . format ( STRING , table Name Pattern , Arrays . to String ( types ) ) , tables . next ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "signals the semaphore when the event arrives .",
    "text_2": "public void signal Event ( ) { Collection < Semaphore > sem ap ho res = sem ap ho res . values ( ) ; for ( Semaphore semaphore : sem ap ho res ) { semaphore . release ( ) ; sem ap ho res . remove ( semaphore ) ; } }",
    "label": 1
  },
  {
    "text_1": "writes the tags from this exif interface object into a jpeg compressed bitmap , removing prior exif tags .",
    "text_2": "public void write Exif ( Bitmap bmap , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( bmap = = null | | exif Out File Name = = null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; try { s = get Exif Writer Stream ( exif Out File Name ) ; bmap . compress ( Bitmap . Compress Format . JPEG , NUM , s ) ; s . flush ( ) ; } catch ( IO Exception e ) { close Silently ( s ) ; throw e ; } s . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "caches the given items as re posts .",
    "text_2": "public synchronized void cache Re posts ( List < Long > new Re post Ids ) { Tree Set < Long > re posts = new Tree Set < > ( ) ; re posts . add All ( Longs . as List ( re post Cache . get ( ) ) ) ; re posts . add All ( new Re post Ids ) ; re post Cache . set ( Longs . to Array ( re posts ) ) ; }",
    "label": 1
  },
  {
    "text_1": "invoke the jsr 3 08 type annotations compiler with all relevant jars on its classpath or boot classpath",
    "text_2": "public int invoke Compiler ( ) { List < String > args = get Exec Arguments ( ) ; for ( int i = NUM ; i < args . size ( ) ; i + + ) { String arg = args . get ( i ) ; if ( arg . starts With ( STRING ) ) { String file Name = arg . substring ( NUM ) ; args . remove ( i ) ; output Arguments To File ( file Name , args ) ; break ; } } return Exec Util . execute ( args . to Array ( new String [ args . size ( ) ] ) , System . out , System . err ) ; }",
    "label": 1
  },
  {
    "text_1": "for use in projects that want initiate a replay via the java api .",
    "text_2": "public @ Check For Null Queue . Item run NUM ( @ Nonnull String replacement Main Script , @ Nonnull Map < String , String > replacement Loaded Scripts ) { List < Action > actions = new Array List < Action > ( ) ; Cps Flow Execution execution = get Execution ( ) ; if ( execution = = null ) { return null ; } actions . add ( new Replay Flow Factory Action ( replacement Main Script , replacement Loaded Scripts , execution . is Sandbox ( ) ) ) ; actions . add ( new Cause Action ( new Cause . User Id Cause ( ) , new Replay Cause ( run ) ) ) ; for ( Class < ? extends Action > c : COPI ED ACTIONS ) { actions . add All ( run . get Actions ( c ) ) ; } return Parameterized Job Mix In . schedule Build NUM ( run . get Parent ( ) , NUM , actions . to Array ( new Action [ actions . size ( ) ] ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the id as a string",
    "text_2": "@ Override public String to String ( ) { int len = session Id . length ; String Buffer s = new String Buffer ( NUM + NUM * len ) ; s . append ( STRING ) ; for ( int i = NUM ; i < len ; i + + ) { s . append ( NUM & session Id [ i ] ) ; if ( i ! = ( len - NUM ) ) s . append ( STRING ) ; } s . append ( STRING ) ; return s . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a sorted map of the properties of this packer .",
    "text_2": "Sorted Map < String , String > properties ( ) ;",
    "label": 1
  },
  {
    "text_1": "do not call this unless you obtained this via expand able list position . obtain ( ) . position metadata will handle recycling its own children .",
    "text_2": "public void recycle ( ) { synchronized ( s Pool ) { if ( s Pool . size ( ) < MAX POOL SIZE ) { s Pool . add ( this ) ; } } }",
    "label": 1
  },
  {
    "text_1": "ensures correct size of the widget .",
    "text_2": "@ Override protected synchronized void on Measure ( int width Measure Spec , int height Measure Spec ) { int width = NUM ; if ( Measure Spec . UNSPECIFIED ! = Measure Spec . get Mode ( width Measure Spec ) ) { width = Measure Spec . get Size ( width Measure Spec ) ; } int height = thumb Image . get Height ( ) ; if ( Measure Spec . UNSPECIFIED ! = Measure Spec . get Mode ( height Measure Spec ) ) { height = Math . min ( height , Measure Spec . get Size ( height Measure Spec ) ) ; } set Measured Dimension ( width , height ) ; }",
    "label": 1
  },
  {
    "text_1": "clean up after termination .",
    "text_2": "public void disconnect ( ) { if ( conn ! = null ) { try { conn . close ( ) ; } catch ( SQL Exception e ) { logger . warn ( STRING , e ) ; } } try { close Binlog ( ) ; } catch ( IO Exception e ) { logger . warn ( STRING , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "invalidate all tuples managed by this tup lemanager",
    "text_2": "public void invalidate All ( ) { if ( m tuples = = null ) return ; for ( int i = NUM ; i < m tuples . length ; + + i ) invalidate ( i ) ; }",
    "label": 1
  },
  {
    "text_1": "reads and skips all tokens before next end of line token .",
    "text_2": "protected void read Till EOL ( ) throws IO Exception { while ( m Tokenizer . next Token ( ) ! = Stream Tokenizer . TT EOL ) { } m Tokenizer . push Back ( ) ; }",
    "label": 1
  },
  {
    "text_1": "changes the first letter of the passed string to lower case .",
    "text_2": "public static String lower First Char ( String string ) { if ( string = = null ) return null ; if ( string . length ( ) < = NUM ) return string . to Lower Case ( ) ; String Builder sb = new String Builder ( string ) ; sb . set Char At ( NUM , Character . to Lower Case ( sb . char At ( NUM ) ) ) ; return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a full path with leading \" / \" if absolute .",
    "text_2": "public String to String ( ) { String Buffer path = new String Buffer ( ) ; if ( absolute ) path . append ( STRING ) ; for ( int i = NUM ; i < elements . size ( ) ; i + + ) { if ( i > NUM ) path . append ( STRING ) ; path . append ( elements . get ( i ) ) ; } return path . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "replaces all occurrences of a sub - string in a string .",
    "text_2": "public static String replace ( String text , String old sub , String new sub , boolean case Insensitive , boolean first Only ) { String Builder buf ; int tln ; int ol n = old sub . length ( ) ; if ( ol n = = NUM ) { int n ln = new sub . length ( ) ; if ( n ln = = NUM ) { return text ; } else { if ( first Only ) { return new sub + text ; } else { tln = text . length ( ) ; buf = new String Builder ( tln + ( tln + NUM ) * n ln ) ; buf . append ( new sub ) ; for ( int i = NUM ; i < tln ; i + + ) { buf . append ( text . char At ( i ) ) ; buf . append ( new sub ) ; } return buf . to String ( ) ; } } } else { old sub = case Insensitive ? old sub . to Lower Case ( ) : old sub ; String input = case Insensitive ? text . to Lower Case ( ) : text ; int e = input . index Of ( old sub ) ; if ( e = = - NUM ) { return text ; } int b = NUM ; tln = text . length ( ) ; buf = new String Builder ( tln + Math . max ( new sub . length ( ) - ol n , NUM ) * NUM ) ; do { buf . append ( text . substring ( b , e ) ) ; buf . append ( new sub ) ; b = e + ol n ; e = input . index Of ( old sub , b ) ; } while ( e ! = - NUM & & ! first Only ) ; buf . append ( text . substring ( b ) ) ; return buf . to String ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "opens a stream to the given uri .",
    "text_2": "public Output Stream open Output Stream ( Uri uri , boolean append ) throws IO Exception { assert Background Thread ( ) ; switch ( get Uri Type ( uri ) ) { case URI TYPE FILE : { File local File = new File ( uri . get Path ( ) ) ; File parent = local File . get Parent File ( ) ; if ( parent ! = null ) { parent . mkdirs ( ) ; } return new File Output Stream ( local File , append ) ; } case URI TYPE CONTENT : case URI TYPE RESOURCE : { Asset File Descriptor asset Fd = content Resolver . open Asset File Descriptor ( uri , append ? STRING : STRING ) ; return asset Fd . create Output Stream ( ) ; } } throw new File Not Found Exception ( STRING + uri ) ; }",
    "label": 1
  },
  {
    "text_1": "add a initial drawer item or a drawer item array for the sticky drawer footer",
    "text_2": "public Drawer Builder add Sticky Drawer Items ( @ Non Null I Drawer Item . . . sticky Drawer Items ) { if ( this . m Sticky Drawer Items = = null ) { this . m Sticky Drawer Items = new Array List < > ( ) ; } Collections . add All ( this . m Sticky Drawer Items , sticky Drawer Items ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "if the normalized scale is equal to 1 , then the image is made to fit the screen . otherwise , it is made to fit the screen according to the dimensions of the previous image matrix . this allows the image to maintain its zoom after rotation .",
    "text_2": "private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable = = null | | drawable . get Intrinsic Width ( ) = = NUM | | drawable . get Intrinsic Height ( ) = = NUM ) { return ; } if ( matrix = = null | | prev Matrix = = null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) & & ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { if ( prev Match View Width = = NUM | | prev Match View Height = = NUM ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }",
    "label": 1
  },
  {
    "text_1": "do the appropriate processing for cf b iv mode decryption .",
    "text_2": "private int decrypt Block With IV ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STRING ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STRING ) ; } if ( count = = NUM ) { for ( int n = NUM ; n < block Size ; n + + ) { FR [ n ] = in [ in Off + n ] ; } cipher . process Block ( FR , NUM , FR E , NUM ) ; count + = block Size ; return NUM ; } else if ( count = = block Size ) { System . arraycopy ( in , in Off , tmp , NUM , block Size ) ; System . arraycopy ( FR , NUM , FR , NUM , block Size - NUM ) ; FR [ block Size - NUM ] = tmp [ NUM ] ; FR [ block Size - NUM ] = tmp [ NUM ] ; cipher . process Block ( FR , NUM , FR E , NUM ) ; for ( int n = NUM ; n < block Size - NUM ; n + + ) { out [ out Off + n ] = encrypt Byte ( tmp [ n + NUM ] , n ) ; } System . arraycopy ( tmp , NUM , FR , NUM , block Size - NUM ) ; count + = NUM ; return block Size - NUM ; } else if ( count > = block Size + NUM ) { System . arraycopy ( in , in Off , tmp , NUM , block Size ) ; out [ out Off + NUM ] = encrypt Byte ( tmp [ NUM ] , block Size - NUM ) ; out [ out Off + NUM ] = encrypt Byte ( tmp [ NUM ] , block Size - NUM ) ; System . arraycopy ( tmp , NUM , FR , block Size - NUM , NUM ) ; cipher . process Block ( FR , NUM , FR E , NUM ) ; for ( int n = NUM ; n < block Size - NUM ; n + + ) { out [ out Off + n + NUM ] = encrypt Byte ( tmp [ n + NUM ] , n ) ; } System . arraycopy ( tmp , NUM , FR , NUM , block Size - NUM ) ; } return block Size ; }",
    "label": 1
  },
  {
    "text_1": "adds an action to the popup menu that is displayed when the button is clicked .",
    "text_2": "public Drop Down Popup Button Builder add ( Action action ) { popup Menu . add ( action ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "terminate this entire set of coroutines . the others will be deregistered and have exceptions thrown at them . note that this is intended as a pan ic - shutdown operation ; under normal circumstances a coroutine should always end with co exit to ( ) in order to polit ely inform at least one of its partners that it is going away . % tbd % this may need significantly more work . % tbd % should this just be co exit to ( , , co rout in emanager . pan ic ) ?",
    "text_2": "public synchronized void co exit ( int this Coroutine ) { m active I Ds . clear ( this Coroutine ) ; m next Coroutine = NO BODY ; notify ( ) ; }",
    "label": 1
  },
  {
    "text_1": "javax . security . auth . subject do as ( subject subject , privileged action action )",
    "text_2": "public void test do As NUM ( ) { Subject subj = new Subject ( ) ; Privileged Action < Object > pa = new my Privileged Action ( ) ; Privileged Action < Object > pa Null = null ; try { Object obj = Subject . do As ( null , pa ) ; } catch ( Exception e ) { fail ( STRING + e ) ; } try { Object obj = Subject . do As ( subj , pa ) ; } catch ( Exception e ) { fail ( STRING + e ) ; } try { Object obj = Subject . do As ( subj , pa Null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } }",
    "label": 1
  },
  {
    "text_1": "adds a new ( input ) relation for the node",
    "text_2": "@ Override public void add Input Node ( B Node input Node ) { super . add Input Node ( input Node ) ; }",
    "label": 1
  },
  {
    "text_1": "fill in definition of class ` c ' from corresponding class or source file .",
    "text_2": "private void fill In ( Class Symbol c ) { if ( completion Failure Name = = c . fullname ) { throw new Completion Failure ( c , STRING ) ; } current Owner = c ; warned Attrs . clear ( ) ; Java File Object classfile = c . classfile ; if ( classfile ! = null ) { Java File Object previous Class File = current Class File ; try { if ( filling ) { Assert . error ( STRING + classfile . to Uri ( ) + STRING + previous Class File ) ; } current Class File = classfile ; if ( verbose ) { log . print Verbose ( STRING , current Class File . to String ( ) ) ; } if ( classfile . get Kind ( ) = = Java File Object . Kind . CLASS ) { filling = BOOL ; try { bp = NUM ; buf = read Input Stream ( buf , classfile . open Input Stream ( ) ) ; read Class File ( c ) ; if ( ! missing Type Variables . is Empty ( ) & & ! found Type Variables . is Empty ( ) ) { List < Type > missing = missing Type Variables ; List < Type > found = found Type Variables ; missing Type Variables = List . nil ( ) ; found Type Variables = List . nil ( ) ; filling = BOOL ; Class Type ct = ( Class Type ) current Owner . type ; ct . supertype field = types . subst ( ct . supertype field , missing , found ) ; ct . interfaces field = types . subst ( ct . interfaces field , missing , found ) ; } else if ( missing Type Variables . is Empty ( ) ! = found Type Variables . is Empty ( ) ) { Name name = missing Type Variables . head . tsym . name ; throw bad Class File ( STRING , name ) ; } } finally { missing Type Variables = List . nil ( ) ; found Type Variables = List . nil ( ) ; filling = BOOL ; } } else { if ( source Completer ! = null ) { source Completer . complete ( c ) ; } else { throw new Illegal State Exception ( STRING + classfile . to Uri ( ) ) ; } } return ; } catch ( IO Exception ex ) { throw bad Class File ( STRING , ex . get Message ( ) ) ; } finally { current Class File = previous Class File ; } } else { JC Diagnostic diag = diag Factory . fragment ( STRING , c . flat name ) ; throw new Completion Failure ( c , diag ) ; } }",
    "label": 1
  },
  {
    "text_1": "verify if the size fits the buffer",
    "text_2": "public synchronized boolean check Size ( final int size Checked ) { if ( ! started ) { throw new Illegal State Exception ( STRING ) ; } if ( size Checked > buffer Size ) { throw new Illegal State Exception ( STRING + buffer Size + STRING ) ; } if ( buffer Limit = = NUM | | buffer . writer Index ( ) + size Checked > buffer Limit ) { flush ( ) ; delay Flush = BOOL ; final int remaining In File = buffer Observer . get Remaining Bytes ( ) ; if ( size Checked > remaining In File ) { return BOOL ; } else { buffer Limit = Math . min ( remaining In File , buffer Size ) ; return BOOL ; } } else { delay Flush = BOOL ; return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "randomly determine whether this call should result in a network failure .",
    "text_2": "private static boolean calculate Is Failure ( ) { int random Value = random . next Int ( NUM ) + NUM ; return random Value < = ERROR PCT ; }",
    "label": 1
  },
  {
    "text_1": "validates if a label contains only alphanumeric values",
    "text_2": "private static Boolean is Alphanumeric ( final String label ) { boolean status = BOOL ; if ( String Utils . is Not Empty ( label ) ) { Matcher matcher = pattern Alphanumeric . matcher ( label ) ; status = matcher . matches ( ) ; } return status ; }",
    "label": 1
  },
  {
    "text_1": "after rotating , the matrix needs to be translated . this function finds the area of image which was previously centered and adjusts translations so that is again the center , post - rotation .",
    "text_2": "private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "set speed of a throttle to a spe e ed set by a float , using the section for the length details",
    "text_2": "@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Section sec , float speed ) { if ( sec = = referenced & & speed = = desired Speed Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } return ; } float section Length = sec . get Actual Length ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sec . get Display Name ( ) ) ; } if ( sec = = referenced ) { distance Remaining = distance Remaining - get Distance Travel led ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; section Length = distance Remaining ; } else { referenced = sec ; } change Loco Speed ( t , section Length , speed ) ; }",
    "label": 1
  },
  {
    "text_1": "add a header line without any validation . only appropriate for headers from the remote peer or cache .",
    "text_2": "Builder add Lenient ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index ! = - NUM ) { return add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { return add Lenient ( STRING , line . substring ( NUM ) ) ; } else { return add Lenient ( STRING , line ) ; } }",
    "label": 1
  },
  {
    "text_1": "are msc api stores supported ?",
    "text_2": "public static boolean are Ms Capi Stores Supported ( ) { return Security . get Provider ( MS CAPI . jce ( ) ) ! = null ; }",
    "label": 1
  },
  {
    "text_1": "projects an immutable collection of this stream . initial iteration over the collection is not thread safe ( can ' t be performed by multiple threads concurrently ) subsequent iterations are .",
    "text_2": "public static final < A > Collection X < A > to Lazy Collection ( final Stream < A > stream ) { return Seq Utils . to Lazy Collection ( stream . iterator ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "replaces un printable characters by their e spaced ( or unicode escaped ) equivalents in the given string",
    "text_2": "protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i + + ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM | | ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the domain component of an email address is valid .",
    "text_2": "protected boolean is Valid Domain ( String domain ) { Matcher ip Domain Matcher = IP DOMAIN PATTERN . matcher ( domain ) ; if ( ip Domain Matcher . matches ( ) ) { Inet Address Validator inet Address Validator = Inet Address Validator . get Instance ( ) ; return inet Address Validator . is Valid ( ip Domain Matcher . group ( NUM ) ) ; } Domain Validator domain Validator = Domain Validator . get Instance ( allow Local ) ; return domain Validator . is Valid ( domain ) | | domain Validator . is Valid Tld ( domain ) ; }",
    "label": 1
  },
  {
    "text_1": "calculates control width and creates text layouts",
    "text_2": "private int calculate Layout Width ( int width Size , int mode ) { init Resources If Necessary ( ) ; items Layout . set Layout Params ( new Layout Params ( Layout Params . WRAP CONTENT , Layout Params . WRAP CONTENT ) ) ; items Layout . measure ( Measure Spec . make Measure Spec ( width Size , Measure Spec . UNSPECIFIED ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; int width = items Layout . get Measured Width ( ) ; if ( mode = = Measure Spec . EXACTLY ) { width = width Size ; } else { width + = NUM * PADDING ; width = Math . max ( width , get Suggested Minimum Width ( ) ) ; if ( mode = = Measure Spec . AT MOST & & width Size < width ) { width = width Size ; } } items Layout . measure ( Measure Spec . make Measure Spec ( width - NUM * PADDING , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; return width ; }",
    "label": 1
  },
  {
    "text_1": "called when the view is unbound",
    "text_2": "@ Override public void unbind View ( VH holder ) { }",
    "label": 1
  },
  {
    "text_1": "checks whether a character is a valid token character . whitespace , control characters , and http separators are not valid token characters . the http specification ( rfc 2616 , section 2 . 2 ) defines tokens only for the us - ascii character set , this method extends the definition to other character sets .",
    "text_2": "protected boolean is Token Char ( char ch ) { if ( Character . is Letter Or Digit ( ch ) ) return BOOL ; if ( Character . is ISO Control ( ch ) ) return BOOL ; if ( is Http Separator ( ch ) ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "removes a graphic from the overlay .",
    "text_2": "public void remove ( T graphic ) { synchronized ( m Lock ) { m Graphics . remove ( graphic ) ; } post Invalidate ( ) ; }",
    "label": 1
  },
  {
    "text_1": "check the given word for derived ad jec tives like \" magical \" or \" nom adic \" .",
    "text_2": "public static boolean is Derived Adjective ( final String word ) { if ( word . length ( ) > NUM ) { if ( word . ends With ( STRING ) | | word . ends With ( STRING ) ) return BOOL ; if ( word . ends With ( STRING ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "calculates whether this peer is alive : the peer is alive when the peer hasn ' t send data yet , or when data is received within the timeout after sending data .",
    "text_2": "public boolean is Alive ( ) { if ( has Sent Data ) { if ( System . current Time Millis ( ) - last Send Time < TIMEOUT ) return BOOL ; return has Received Data & & last Receive Time > last Send Time ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "provide a hash code that is consistent with equals for this class",
    "text_2": "public int hash Code ( ) { int result = NUM ; if ( table Name ! = null ) { result = NUM * table Name . hash Code ( ) ; } if ( repository Name ! = null ) { result = NUM * repository Name . hash Code ( ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "aggregate feature values stored in a chain of hypotheses .",
    "text_2": "public static < TK , FV > Feature Value Collection < FV > combine ( Derivation < TK , FV > hyp ) { Counter < FV > counter = new Classic Counter < FV > ( ) ; for ( ; hyp ! = null ; hyp = hyp . parent ) { if ( hyp . features ! = null ) { for ( Feature Value < FV > feature : hyp . features ) { counter . increment Count ( feature . name , feature . value ) ; } } } Set < FV > feature Names = new Tree Set < FV > ( counter . key Set ( ) ) ; Feature Value Collection < FV > combined List = new Feature Value List < FV > ( feature Names . size ( ) ) ; for ( FV feature : feature Names ) { combined List . add ( new Feature Value < FV > ( feature , counter . get Count ( feature ) ) ) ; } return combined List ; }",
    "label": 1
  },
  {
    "text_1": "read a line from the stream returning as a string . not used for reading headers .",
    "text_2": "public String read Line ( ) throws IO Exception { boolean got CR = BOOL , got LF = BOOL ; pos = NUM ; line Buf = new String Buffer ( ) ; while ( ! got LF ) { int c = is . read ( ) ; if ( c = = - NUM ) { return null ; } if ( got CR ) { if ( c = = LF ) { got LF = BOOL ; } else { got CR = BOOL ; consume ( CR ) ; consume ( c ) ; } } else { if ( c = = CR ) { got CR = BOOL ; } else { consume ( c ) ; } } } line Buf . append ( buf , NUM , pos ) ; return new String ( line Buf ) ; }",
    "label": 1
  },
  {
    "text_1": "adds several element to the end of this expandable array .",
    "text_2": "public void add Elements ( final double [ ] values ) { final double [ ] temp Array = new double [ num Elements + values . length + NUM ] ; System . arraycopy ( internal Array , start Index , temp Array , NUM , num Elements ) ; System . arraycopy ( values , NUM , temp Array , num Elements , values . length ) ; internal Array = temp Array ; start Index = NUM ; num Elements + = values . length ; }",
    "label": 1
  },
  {
    "text_1": "message provides notice that the operator has started execution and will consume some specific number of binding set chunks .",
    "text_2": "final protected void start Op ( final I Start Op Message msg ) { if ( ! controller ) throw new Unsupported Operation Exception ( ERR NOT CONTROLLER ) ; if ( msg = = null ) throw new Illegal Argument Exception ( ) ; if ( ! query Id . equals ( msg . get Query Id ( ) ) ) throw new Illegal Argument Exception ( ) ; lock . lock ( ) ; try { if ( log . is Trace Enabled ( ) ) log . trace ( msg . to String ( ) ) ; if ( future . is Done ( ) ) throw new Runtime Exception ( STRING ) ; run State . start Op ( msg ) ; } catch ( Timeout Exception ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "reads the configuration from the xml configuration file .",
    "text_2": "public synchronized Scan Manager Config read From File ( ) throws IO Exception { final File f = new File ( file ) ; if ( ! f . exists ( ) ) throw new IO Exception ( STRING + file ) ; if ( ! f . can Read ( ) ) throw new IO Exception ( STRING + file ) ; try { return read ( f ) ; } catch ( JAXB Exception x ) { final IO Exception io = new IO Exception ( STRING + file + STRING + x , x ) ; throw io ; } }",
    "label": 1
  },
  {
    "text_1": "loads this preference store from the given input stream . default preference values are not affected .",
    "text_2": "public void load ( Input Stream in ) throws IO Exception { properties . load ( in ) ; dirty = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "read a read a utf - 8 text file from our classpath and return it .",
    "text_2": "public static String read File ( Class < ? > context , String name ) throws IO Exception { try ( Input Stream in = context . get Resource As Stream ( name ) ) { if ( in = = null ) { return null ; } return new String ( Byte Streams . to Byte Array ( in ) , ENC ) ; } catch ( IO Exception e ) { throw new IO Exception ( STRING + name , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "process a trun king signalling block message",
    "text_2": "private void process T SB K ( T SB K Message tsbk ) { broadcast ( new Decoder State Event ( this , Event . CONTINUATION , State . CONTROL ) ) ; if ( tsbk . get Vendor ( ) = = Vendor . STANDARD ) { switch ( tsbk . get Opcode ( ) ) { case AD J AC ENT STATUS BROADCAST : if ( tsbk instanceof Adjacent Status Broadcast ) { I Adjacent Site ias = ( I Adjacent Site ) tsbk ; m Neighbor Map . put ( ias . get Unique ID ( ) , ias ) ; update System ( ias . get System ID ( ) ) ; } break ; case ACKNOWLEDGE RESPONSE : process T SB K Response ( tsbk ) ; break ; case AUTHENTICATION COMMAND : process T SB K Command ( tsbk ) ; break ; case CALL ALERT : process T SB K Page ( tsbk ) ; break ; case DENY RESPONSE : process T SB K Response ( tsbk ) ; break ; case EXTENDED FUNCTION COMMAND : process T SB K Command ( tsbk ) ; break ; case GROUP AFFI LI ATION QUERY : process T SB K Query ( tsbk ) ; break ; case GROUP AFFI LI ATION RESPONSE : process T SB K Response ( tsbk ) ; break ; case GROUP DATA CHANNEL ANNOUN CEMENT : case GROUP DATA CHANNEL ANNOUN CEMENT EXPLICIT : process T SB K Data Channel Announcement ( tsbk ) ; break ; case GROUP DATA CHANNEL GRANT : case GROUP VOICE CHANNEL GRANT : case GROUP VOICE CHANNEL GRANT UPDATE : case GROUP VOICE CHANNEL GRANT UPDATE EXPLICIT : case INDIVIDUAL DATA CHANNEL GRANT : case TELE PHONE INTER CONNECT VOICE CHANNEL GRANT : case TELE PHONE INTER CONNECT VOICE CHANNEL GRANT UPDATE : case UNIT TO UNIT VOICE CHANNEL GRANT : case UNIT TO UNIT VOICE CHANNEL GRANT UPDATE : process T SB K Channel Grant ( tsbk ) ; break ; case IDENTIFIER UPDATE NON V U HF : case IDENTIFIER UPDATE V HF U HF B ANDS : Identifier Update iu = ( Identifier Update ) tsbk ; if ( ! m Bands . contains Key ( iu . get Identifier ( ) ) ) { m Bands . put ( iu . get Identifier ( ) , iu ) ; } break ; case LOCATION REGISTRATION RESPONSE : case UNIT DER EG ISTR ATION ACKNOWLEDGE : process T SB K Response ( tsbk ) ; break ; case MESSAGE UPDATE : process T SB K Message ( tsbk ) ; break ; case NETWORK STATUS BROADCAST : m Network Status = ( module . decode . p25 . message . tsbk . osp . control . Network Status Broadcast ) tsbk ; break ; case PROTECTION PARAMETER UPDATE : process T SB K Response ( tsbk ) ; break ; case QUEUED RESPONSE : process T SB K Response ( tsbk ) ; break ; case RADIO UNIT MONITOR COMMAND : process T SB K Command ( tsbk ) ; break ; case RF SS STATUS BROADCAST : process T SB K RF SS Status ( ( RF SS Status Broadcast ) tsbk ) ; break ; case RO AM ING ADDRESS COMMAND : process T SB K Command ( tsbk ) ; break ; case SECONDARY CONTROL CHANNEL BROADCAST : module . decode . p25 . message . tsbk . osp . control . Secondary Control Channel Broadcast sc cb = ( module . decode . p25 . message . tsbk . osp . control . Secondary Control Channel Broadcast ) tsbk ; if ( sc cb . get Downlink Frequency NUM ( ) > NUM ) { m Secondary Control Channels . add ( sc cb ) ; } break ; case SND CP DATA CHANNEL ANNOUN CEMENT EXPLICIT : m SND CP Data Channel = ( SND CP Data Channel Announcement Explicit ) tsbk ; break ; case SND CP DATA CHANNEL GRANT : process T SB K Channel Grant ( tsbk ) ; break ; case STATUS QUERY : process T SB K Query ( tsbk ) ; break ; case STATUS UPDATE : process T SB K Response ( tsbk ) ; break ; case TELE PHONE INTER CONNECT ANSWER REQUEST : case UNIT TO UNIT ANSWER REQUEST : process T SB K Page ( tsbk ) ; break ; case UNIT REGISTRATION COMMAND : process T SB K Command ( tsbk ) ; break ; case UNIT REGISTRATION RESPONSE : process T SB K Response ( tsbk ) ; break ; default : break ; } } else if ( tsbk . get Vendor ( ) = = Vendor . MO TO RO LA ) { process Mo to rola T SB K ( ( Mo to rola T SB K Message ) tsbk ) ; } }",
    "label": 1
  },
  {
    "text_1": "iterates over the commands to find if the replica took a checkpoint . this iteration over commands is needed due to the batch execution strategy introduced with the durable techniques to improve state management . as several consensus instances can be executed in the same batch of commands , it is necessary to identify if the batch contains checkpoint indexes .",
    "text_2": "private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length = = NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period = = NUM ) { return cid Position ( cids , first CID ) ; } else { int next C kp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next C kp Index < = cids [ cids . length - NUM ] ) { return cid Position ( cids , next C kp Index ) ; } } return - NUM ; }",
    "label": 1
  },
  {
    "text_1": "add an extension with the given oid and the passed in byte array to be wrapped in the octet string associated with the extension .",
    "text_2": "public void add Extension ( ASN NUM Object Identifier oid , boolean critical , byte [ ] value ) { if ( extensions . contains Key ( oid ) ) { throw new Illegal Argument Exception ( STRING + oid + STRING ) ; } ext Ordering . add Element ( oid ) ; extensions . put ( oid , new Extension ( oid , critical , new DER Octet String ( value ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the request is paused or killed , developers should call this method periodically to test whether they should quit the current io operation immediately",
    "text_2": "protected boolean should Stop ( ) { return is Paused ( ) | | is Killed ( ) ; }",
    "label": 1
  },
  {
    "text_1": "makes this object immutable .",
    "text_2": "public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "handles button clicks by passing control to an appropriate handler method .",
    "text_2": "@ Override public void action Performed ( Action Event event ) { String command = event . get Action Command ( ) ; if ( command . equals ( STRING ) ) { attempt Font Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Modify Show Title ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "overrides apply settings method in setup window . this method applies any settings associated with this setup window .",
    "text_2": "public void apply Settings ( boolean load Core Components ) throws Apply Settings Exception { List < String > errors = new Array List < String > ( NUM ) ; apply Torrent Data Save Folder Settings ( errors ) ; apply Torrent Seeding Settings ( errors ) ; if ( ! errors . is Empty ( ) ) { throw new Apply Settings Exception ( String Utils . explode ( errors , STRING ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "the method runs all the sub - requests associated to the current instance of snmp requesthandler .",
    "text_2": "private Snmp Pdu Packet execute Sub Request ( Snmp Pdu Packet req , Object user Data ) { int error Status = Snmp Definitions . snmp Rsp No Error ; int i ; if ( req . type = = pdu Set Request Pdu ) { i = NUM ; for ( Enumeration < Snmp Sub Request Handler > e = subs . elements ( ) ; e . has More Elements ( ) ; i + + ) { Snmp Sub Request Handler sub = e . next Element ( ) ; sub . set User Data ( user Data ) ; sub . type = pdu Walk Request ; sub . run ( ) ; sub . type = pdu Set Request Pdu ; if ( sub . get Error Status ( ) ! = Snmp Definitions . snmp Rsp No Error ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } return new Error Response Pdu ( req , error Status , sub . get Error Index ( ) + NUM ) ; } } } i = NUM ; for ( Enumeration < Snmp Sub Request Handler > e = subs . elements ( ) ; e . has More Elements ( ) ; i + + ) { Snmp Sub Request Handler sub = e . next Element ( ) ; sub . set User Data ( user Data ) ; sub . run ( ) ; if ( sub . get Error Status ( ) ! = Snmp Definitions . snmp Rsp No Error ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } return new Error Response Pdu ( req , error Status , sub . get Error Index ( ) + NUM ) ; } } return null ; }",
    "label": 1
  },
  {
    "text_1": "adds an arg after the command and any options .",
    "text_2": "public void add Tail Arg ( String arg ) { tail Args . add ( arg ) ; }",
    "label": 1
  },
  {
    "text_1": "find the angle in degrees between two tangent points",
    "text_2": "private float sweep ( float tan NUM X , float tan NUM Y , float tan NUM X , float tan NUM Y ) { final float minor Sweep = ( float ) Math . to Degrees ( NUM * ( Math . asin ( NUM * Geometry . distance ( tan NUM X , tan NUM Y , tan NUM X , tan NUM Y ) / m Scaled Touch Slop ) ) ) ; return NUM - minor Sweep ; }",
    "label": 1
  },
  {
    "text_1": "adds the key - value mapping to the cache .",
    "text_2": "public V put ( final K k , final V v ) { final Weak Reference < V > ref = new Weak Ref ( k , v , reference Queue ) ; final Weak Reference < V > old Ref = map . put ( k , ref ) ; final V old Val = old Ref = = null ? null : old Ref . get ( ) ; if ( queue . add ( v ) & & DEBUG ) { log . debug ( STRING + k + STRING + v ) ; } did Update ( k , ref , old Ref ) ; return old Val ; }",
    "label": 1
  },
  {
    "text_1": "replaces resource names of a policy in the resource tree .",
    "text_2": "void replace Policy In Resource Tree ( Policy old Policy , Policy new Policy ) throws Policy Exception , SSO Exception { remove Policy From Resource Tree ( old Policy ) ; add Policy To Resource Tree ( new Policy ) ; }",
    "label": 1
  },
  {
    "text_1": "zero based position of the highest one - bit of the given long . returns minus one if num is zero .",
    "text_2": "static int hi Bit Pos ( long num ) { return NUM - Long . number Of Leading Zeros ( num ) ; }",
    "label": 1
  },
  {
    "text_1": "this method is called via reflection from the database .",
    "text_2": "public static Result Set optimize In Join Select ( ) { Simple Result Set rs = new Simple Result Set ( ) ; rs . add Column ( STRING , Types . INTEGER , NUM , NUM ) ; rs . add Row ( NUM ) ; return rs ; }",
    "label": 1
  },
  {
    "text_1": "add a key / value to the hint store for the given store",
    "text_2": "@ Log Message Doc ( level = STRING , message = STRING , explanation = STRING + STRING , recommendation = Log Message Doc . REPORT CONTROLLER BUG ) public void queue Hint ( String store Name , Byte Array key , Versioned < byte [ ] > value ) { try { Hint Key hk = new Hint Key ( store Name , key ) ; hint Lock . lock ( ) ; try { boolean needed = ! hints . contains Key ( hk ) ; needed & = hints . do put ( hk , value ) ; if ( needed ) { hint Queue . add ( hk ) ; hints Available . signal ( ) ; } } finally { hint Lock . unlock ( ) ; } } catch ( Sync Exception e ) { logger . error ( STRING + store Name , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns true if the device is currently acceler ating .",
    "text_2": "private boolean is Acceler ating ( Sensor Event event ) { float ax = event . values [ NUM ] ; float ay = event . values [ NUM ] ; float az = event . values [ NUM ] ; final double magnitude = Math . sqrt ( ax * ax + ay * ay + az * az ) ; return magnitude > ACCELER ATION THRESHOLD ; }",
    "label": 1
  },
  {
    "text_1": "determine whether a char is an unreserved character .",
    "text_2": "private static boolean is Unreserved Character ( char p char ) { return ( is Alphanum ( p char ) | | MARK CHARACTERS . index Of ( p char ) ! = - NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "receive notification of a xslt processing warning .",
    "text_2": "public void warning ( org . xml . sax . SAX Parse Exception e ) throws org . xml . sax . SAX Exception { String formatted Msg = e . get Message ( ) ; SAX Source Locator locator = get Locator ( ) ; Error Listener handler = m stylesheet Processor . get Error Listener ( ) ; try { handler . warning ( new Transformer Exception ( formatted Msg , locator ) ) ; } catch ( Transformer Exception te ) { throw new org . xml . sax . SAX Exception ( te ) ; } }",
    "label": 1
  },
  {
    "text_1": "create an x509 trust chain key selector instance which will accept a chain rooted at any of the provided certificates .",
    "text_2": "public X509 Trust Chain Key Selector ( X509 Certificate . . . trusted Roots ) { log = Logger Factory . get Logger ( X509 Trust Chain Key Selector . class ) ; check Ctor Args Not Null ( trusted Roots ) ; trust Anchors = new Hash Set < Trust Anchor > ( ) ; for ( X509 Certificate cert : trusted Roots ) { trust Anchors . add ( new Trust Anchor ( cert , null ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "builds the application user from the header map .",
    "text_2": "protected Application User build User ( Map < String , String > header Map , boolean include Roles ) { LOGGER . debug ( STRING ) ; Map < String , String > header Names = get Header Names ( ) ; Application User application User = create New Application User ( ) ; build User Id ( application User , header Map , header Names . get ( HTTP HEADER USER ID ) ) ; build First Name ( application User , header Map , header Names . get ( HTTP HEADER FIRST NAME ) ) ; build Last Name ( application User , header Map , header Names . get ( HTTP HEADER LAST NAME ) ) ; build Email ( application User , header Map , header Names . get ( HTTP HEADER EMAIL ) ) ; build Session Id ( application User , header Map , HTTP HEADER SESSION ID ) ; build Session Init Time ( application User , header Map , header Names . get ( HTTP HEADER SESSION INIT TIME ) ) ; user Namespace Authorization Helper . build Namespace Authorizations ( application User ) ; if ( include Roles ) { build Roles ( application User , header Map , header Names . get ( HTTP HEADER ROLES ) ) ; } LOGGER . debug ( STRING + application User ) ; return application User ; }",
    "label": 1
  },
  {
    "text_1": "parse html tags , returning a collection of html token objects .",
    "text_2": "public Collection < HTML Token > tokenize HTML ( ) { List < HTML Token > tokens = new Array List < HTML Token > ( ) ; String nested Tags = nested Tags Regex ( NUM ) ; Pattern p = Pattern . compile ( STRING + STRING + STRING + STRING + STRING + nested Tags + STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( text ) ; int last Pos = NUM ; while ( m . find ( ) ) { if ( last Pos < m . start ( ) ) { tokens . add ( HTML Token . text ( text . substring ( last Pos , m . start ( ) ) ) ) ; } tokens . add ( HTML Token . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; last Pos = m . end ( ) ; } if ( last Pos < text . length ( ) ) { tokens . add ( HTML Token . text ( text . substring ( last Pos , text . length ( ) ) ) ) ; } return tokens ; }",
    "label": 1
  },
  {
    "text_1": "store the all of the operation car objects in the default place , including making a backup if needed",
    "text_2": "public void write Operations Car File ( ) { make Backup File ( default Operations Filename ( ) ) ; try { if ( ! check File ( default Operations Filename ( ) ) ) { java . io . File file = new java . io . File ( default Operations Filename ( ) ) ; java . io . File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { log . error ( STRING ) ; } } if ( file . create New File ( ) ) { log . debug ( STRING ) ; } } write File ( default Operations Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a clone of a volume .",
    "text_2": "public Driver Task create Volume Clone ( List < Volume Clone > clones ) { LOG . info ( STRING ) ; Dell SC Driver Task task = new Dell SC Driver Task ( STRING ) ; String Builder err Buffer = new String Builder ( ) ; int create Count = NUM ; for ( Volume Clone clone : clones ) { try { Storage Center API api = connection Manager . get Connection ( clone . get Storage System Id ( ) ) ; Sc Replay replay = null ; api . check And Init Volume ( clone . get Parent Id ( ) ) ; if ( clone . get Source Type ( ) = = Source Type . SNAPSHOT ) { replay = api . get Replay ( clone . get Parent Id ( ) ) ; } else { replay = api . create Replay ( clone . get Parent Id ( ) , NUM ) ; } Sc Volume sc Vol = api . create View Volume ( clone . get Display Name ( ) , replay . instance Id ) ; clone . set Provisioned Capacity ( Size Util . size Str To Bytes ( sc Vol . configured Size ) ) ; clone . set Allocated Capacity ( NUM ) ; clone . set Wwn ( sc Vol . device Id ) ; clone . set Native Id ( sc Vol . instance Id ) ; clone . set Device Label ( sc Vol . name ) ; clone . set Access Status ( Access Status . READ WRITE ) ; clone . set Replication State ( Replication State . SYNCHRONIZED ) ; create Count + + ; } catch ( Dell SC Driver Exception | Storage Center API Exception dex ) { String error = String . format ( STRING , clone . get Parent Id ( ) , dex ) ; err Buffer . append ( String . format ( STRING , error ) ) ; } } task . set Message ( err Buffer . to String ( ) ) ; if ( create Count = = clones . size ( ) ) { task . set Status ( Task Status . READY ) ; } else if ( create Count = = NUM ) { task . set Status ( Task Status . FAILED ) ; } else { task . set Status ( Task Status . PARTI ALLY FAILED ) ; } return task ; }",
    "label": 1
  },
  {
    "text_1": "adds rdf data to the remote repository .",
    "text_2": "public long add ( final Add Op add ) throws Exception { return add ( add , UUID . random UUID ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "draws a vertical span into the graph and optionally adds a legend .",
    "text_2": "public void v span ( long start , long end , Paint color , String legend ) { Legend Text legend Text = new Legend Text ( color , legend ) ; comments . add ( legend Text ) ; plot Elements . add ( new V Span ( start , end , color , legend Text ) ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a implementation of dom test documentbuilderfactory using j tidy ' s html parser and dom implementation",
    "text_2": "public J Tidy Document Builder Factory ( Document Builder Setting [ ] settings ) throws DOM Test Incompatible Exception { super ( settings ) ; try { Class Loader class Loader = Class Loader . get System Class Loader ( ) ; Class tidy Class = class Loader . load Class ( STRING ) ; tidy Constructor = tidy Class . get Constructor ( NO CLASSES ) ; parse DOM Method = tidy Class . get Method ( STRING , new Class [ ] { java . io . Input Stream . class , java . io . Output Stream . class } ) ; dom Impl = new J Tidy DOM Implementation ( ) ; } catch ( Exception ex ) { throw new DOM Test Incompatible Exception ( ex , null ) ; } if ( settings ! = null ) { for ( int i = NUM ; i < settings . length ; i + + ) { } } }",
    "label": 1
  },
  {
    "text_1": "handles edit bootstrap resource offering request .",
    "text_2": "public void handle Tbl Bootstrap Res Off Href Action Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SM Discovery Bootstrap Ref Off Edit View Bean vb = ( SM Discovery Bootstrap Ref Off Edit View Bean ) get View Bean ( SM Discovery Bootstrap Ref Off Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( ( String ) get Display Field Value ( TBL BOOTSTRAP RES OFF HREF ACTION ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "checks whether an npc with the given name exists .",
    "text_2": "public boolean has ( final String name ) { return contents . contains Key ( name . to Lower Case ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "we are adding an entity to this list .",
    "text_2": "public void add ( int index , Entity entity ) { if ( entities . contains ( entity ) ) { throw new Illegal State Exception ( STRING + entity + STRING ) ; } if ( entity . get Entity Type ( ) ! = entity Type ) { throw new Illegal State Exception ( STRING + entity . get Entity Type ( ) + STRING + get Parent ( ) + STRING + get Name ( ) ) ; } if ( entity . is Cl early Not In Database ( ) ) { new Entities . add ( entity ) ; } entities . add ( index , entity ) ; }",
    "label": 1
  },
  {
    "text_1": "check if any label text is obscured .",
    "text_2": "private static boolean is Text Obs cu red ( J Component c , String s ) { Graphics g = c . get Graphics ( ) ; Font Metrics fm = g . get Font Metrics ( c . get Font ( ) ) ; int sw = fm . string Width ( s ) ; return ( sw > c . get Width ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "is this logger instance enabled for level severe ?",
    "text_2": "@ Override public boolean is Error Enabled ( ) { return logger . is Loggable ( Level . SEVERE ) ; }",
    "label": 1
  },
  {
    "text_1": "creates code snippet language classi fying task .",
    "text_2": "public Future < String > classify ( String snippet ) { final Executor Service service = Executors . new Single Thread Executor ( ) ; return service . submit ( new Clas si f ying Task ( snippet ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if it ' s possible that the given string represents a valid floating point value ( excluding nan , inf and - inf ) .",
    "text_2": "static boolean is Possible FP ( String val ) { final int length = val . length ( ) ; for ( int i = NUM ; i < length ; + + i ) { char c = val . char At ( i ) ; if ( ! ( c > = STRING & & c < = STRING | | c = = STRING | | c = = STRING | | c = = STRING | | c = = STRING | | c = = STRING ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "returns a string describing this result listener",
    "text_2": "@ Override public String global Info ( ) { return STRING + STRING + STRING ; }",
    "label": 1
  },
  {
    "text_1": "determines the number of consecutive characters that are encodable using numeric compaction .",
    "text_2": "private static int determine Consecutive Digit Count ( Char Sequence msg , int startpos ) { int count = NUM ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . char At ( idx ) ; while ( is Digit ( ch ) & & idx < len ) { count + + ; idx + + ; if ( idx < len ) { ch = msg . char At ( idx ) ; } } } return count ; }",
    "label": 1
  },
  {
    "text_1": "have the specified consumer accept the value if a value is present , otherwise do nothing .",
    "text_2": "public void if Present ( Long Consumer consumer ) { if ( is Present ) consumer . accept ( value ) ; }",
    "label": 1
  },
  {
    "text_1": "don ' t use this when obfus cating class names !",
    "text_2": "public static String make Log Tag ( Class cls ) { return make Log Tag ( cls . get Simple Name ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method returns an iterator which joins the given entry ' s binding set to all binding sets which matching the entry ' s key .",
    "text_2": "private Iterator < Binding Set > join Binding Set Entry ( Map . Entry < String , Binding Set > entry ) { List < Collection < Binding Set > > matches = new Array List < > ( ) ; if ( type = = Hash Join Type . CONSTANT JOIN VAR ) { if ( binding Join Var Hash . contains Key ( entry . get Key ( ) ) ) { matches . add ( binding Join Var Hash . get ( entry . get Key ( ) ) ) ; } } else { List < String > val Orders = get Value Orders ( entry . get Key ( ) ) ; for ( String s : val Orders ) { if ( binding Join Var Hash . contains Key ( s ) ) { matches . add ( binding Join Var Hash . get ( s ) ) ; } } } if ( matches . size ( ) = = NUM ) { return Collections . empty Iterator ( ) ; } else { return new Binding Set Collections Join Iterator ( entry . get Value ( ) , matches ) ; } }",
    "label": 1
  },
  {
    "text_1": "serialize an object as a raw byte array",
    "text_2": "public static byte [ ] serialize As Byte Array ( Object b ) throws IO Exception { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; Object Output Stream out = new Object Output Stream ( bos ) ; try { out . write Object ( b ) ; } finally { out . close ( ) ; } return bos . to Byte Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks the reference to a type in a type annotation .",
    "text_2": "static void check Type Ref And Path ( int type Ref , Type Path type Path ) { int mask = NUM ; switch ( type Ref > > > NUM ) { case Type Reference . CLASS TYPE PARAMETER : case Type Reference . METHOD TYPE PARAMETER : case Type Reference . METHOD FORMAL PARAMETER : mask = NUM ; break ; case Type Reference . FIELD : case Type Reference . METHOD RETURN : case Type Reference . METHOD RECEIVER : case Type Reference . LOCAL VARIABLE : case Type Reference . RESOURCE VARIABLE : case Type Reference . INSTANCEOF : case Type Reference . NEW : case Type Reference . CONSTRUCTOR REFERENCE : case Type Reference . METHOD REFERENCE : mask = NUM ; break ; case Type Reference . CLASS EXTENDS : case Type Reference . CLASS TYPE PARAMETER BOUND : case Type Reference . METHOD TYPE PARAMETER BOUND : case Type Reference . TH ROWS : case Type Reference . EXCEPTION PARAMETER : mask = NUM ; break ; case Type Reference . CAST : case Type Reference . CONSTRUCTOR INVOCATION TYPE ARGUMENT : case Type Reference . METHOD INVOCATION TYPE ARGUMENT : case Type Reference . CONSTRUCTOR REFERENCE TYPE ARGUMENT : case Type Reference . METHOD REFERENCE TYPE ARGUMENT : mask = NUM ; break ; default : throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref > > > NUM ) ) ; } if ( ( type Ref & ~ mask ) ! = NUM ) { throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref ) ) ; } if ( type Path ! = null ) { for ( int i = NUM ; i < type Path . get Length ( ) ; + + i ) { int step = type Path . get Step ( i ) ; if ( step ! = Type Path . ARRAY ELEMENT & & step ! = Type Path . INNER TYPE & & step ! = Type Path . TYPE ARGUMENT & & step ! = Type Path . WILDCARD BOUND ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } if ( step ! = Type Path . TYPE ARGUMENT & & type Path . get Step Argument ( i ) ! = NUM ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "casts string to integer or returns null if value is not integer",
    "text_2": "public static Integer to Integer ( String str ) { try { return Integer . value Of ( str ) ; } catch ( Exception ex ) { return null ; } }",
    "label": 1
  },
  {
    "text_1": "checks if the retry delay has passed .",
    "text_2": "private boolean retry Delay Has Passed By ( Long last Fail Time ) { return last Fail Time = = null | | last Fail Time + this . retry After Ms < System . current Time Millis ( ) ; }",
    "label": 1
  },
  {
    "text_1": "this method was generated by mybatis generator . this method corresponds to the database table customer",
    "text_2": "public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) = = NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }",
    "label": 1
  },
  {
    "text_1": "examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are re established : 1 . run len [ i - 3 ] > run len [ i - 2 ] + run len [ i - 1 ] 2 . run len [ i - 2 ] > run len [ i - 1 ] this method is called each time a new run is pushed onto the stack , so the invariants are guaranteed to hold for i < stack size upon entry to the method .",
    "text_2": "private void merge Collapse ( ) { while ( stack Size > NUM ) { int n = stack Size - NUM ; if ( n > NUM & & run Len [ n - NUM ] < = run Len [ n ] + run Len [ n + NUM ] ) { if ( run Len [ n - NUM ] < run Len [ n + NUM ] ) n - - ; merge At ( n ) ; } else if ( run Len [ n ] < = run Len [ n + NUM ] ) { merge At ( n ) ; } else { break ; } } }",
    "label": 1
  },
  {
    "text_1": "remove a test set listener",
    "text_2": "@ Override public synchronized void remove Test Set Listener ( Test Set Listener tsl ) { m test Listeners . remove Element ( tsl ) ; }",
    "label": 1
  },
  {
    "text_1": "builds a new fuzzy query instance",
    "text_2": "protected Query new Fuzzy Query ( Term term , float minimum Similarity , int prefix Length ) { String text = term . text ( ) ; int num Edits = Fuzzy Query . float To Edits ( minimum Similarity , text . code Point Count ( NUM , text . length ( ) ) ) ; return new Fuzzy Query ( term , num Edits , prefix Length ) ; }",
    "label": 1
  },
  {
    "text_1": "af ri ca / cairo standard time is e et and daylight time is e est . they no longer use their dst zone but we should continue to parse it properly .",
    "text_2": "public void test Obsolete Dst Zone Name ( ) throws Exception { Simple Date Format format = new Simple Date Format ( STRING , Locale . US ) ; Date normal = format . parse ( STRING ) ; Date dst = format . parse ( STRING ) ; assert Equals ( NUM * NUM * NUM , normal . get Time ( ) - dst . get Time ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "std : copy : copy range of elements copies the elements in the range [ first , last ) into a range beginning at result . returns an iterator to the last element in the destination range parameters first , last input iterators to the initial and final positions in a sequence to be copied . the range used is [ first , last ) , which contains all the elements between first and last , including the element pointed by first but not the element pointed by last . result output iterator to the initial position in the destination sequence . this shall not point to any element in the range [ first , last ) .",
    "text_2": "public static < T > int copy ( final List < T > from , int first , int last , List < T > to ) { int i = first ; for ( ; i < last ; i + + ) { to . add ( from . get ( i ) ) ; } return i ; }",
    "label": 1
  },
  {
    "text_1": "for keyboard mode , processes key events .",
    "text_2": "private boolean process Key Up ( int key Code ) { if ( key Code = = Key Event . KEYCODE ESCAPE | | key Code = = Key Event . KEYCODE BACK ) { dismiss ( ) ; return BOOL ; } else if ( key Code = = Key Event . KEYCODE TAB ) { if ( m In Kb Mode ) { if ( is Typed Time Fully Legal ( ) ) { finish Kb Mode ( BOOL ) ; } return BOOL ; } } else if ( key Code = = Key Event . KEYCODE ENTER ) { if ( m In Kb Mode ) { if ( ! is Typed Time Fully Legal ( ) ) { return BOOL ; } finish Kb Mode ( BOOL ) ; } if ( m Callback ! = null ) { m Callback . on Time Set ( m Time Picker , m Time Picker . get Hours ( ) , m Time Picker . get Minutes ( ) ) ; } dismiss ( ) ; return BOOL ; } else if ( key Code = = Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted = = get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted = = get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STRING , get Val From Key Code ( deleted ) ) ; } Utils . try Accessibility Announce ( m Time Picker , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( BOOL ) ; } } } else if ( key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | key Code = = Key Event . KEYCODE NUM | | ( ! m Is NUMNUM Hour Mode & & ( key Code = = get Am Or Pm Key Code ( AM ) | | key Code = = get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Time Picker = = null ) { Log . e ( TAG , STRING ) ; return BOOL ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return BOOL ; } if ( add Key If Legal ( key Code ) ) { update Display ( BOOL ) ; } return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "this runnable sends a h trace span to the fl ume .",
    "text_2": "@ Override public void run ( ) { List < Span > de queued Spans = new Array List < Span > ( max Span Batch Size ) ; long error Count = NUM ; while ( running . get ( ) | | queue . size ( ) > NUM ) { Span first Span = null ; try { first Span = queue . poll ( NUM , Time Unit . SECONDS ) ; if ( first Span ! = null ) { de queued Spans . add ( first Span ) ; queue . drain To ( de queued Spans , max Span Batch Size - NUM ) ; } } catch ( Interrupted Exception ie ) { } start Client ( ) ; if ( de queued Spans . is Empty ( ) ) { continue ; } try { List < Event > events = new Array List < Event > ( de queued Spans . size ( ) ) ; for ( Span span : de queued Spans ) { Map < String , String > headers = new Hash Map < String , String > ( ) ; headers . put ( STRING , span . to String ( ) ) ; headers . put ( STRING , span . get Tracer Id ( ) ) ; headers . put ( STRING , span . get Description ( ) ) ; String body = span . to Json ( ) ; Event evt = Event Builder . with Body ( body , Charset . for Name ( STRING ) , headers ) ; events . add ( evt ) ; } fl ume Client . append Batch ( events ) ; de queued Spans . clear ( ) ; error Count = NUM ; } catch ( Exception e ) { error Count + = NUM ; if ( error Count < MAX ERRORS ) { try { queue . add All ( de queued Spans ) ; } catch ( Illegal State Exception ex ) { LOG . error ( STRING + de queued Spans . size ( ) + STRING ) ; } } close Client ( ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e1 ) { } } } close Client ( ) ; }",
    "label": 1
  },
  {
    "text_1": "fills the example table with the data from the dataset .",
    "text_2": "private void fill Example Table ( Data Set data Set , Progress Listener listener , int [ ] attribute Columns , Memory Example Table example Table ) throws Data Set Exception , Process Stopped Exception , Parse Exception { Attribute [ ] attributes = example Table . get Attributes ( ) ; data Set . reset ( ) ; int number Of Rows = data Set . get Number Of Rows ( ) ; Data Row Factory factory = new Data Row Factory ( data Management Type , Data Row Factory . POINT AS DECIMAL CHARACTER ) ; boolean is Running In Process = is Operator Running ( ) ; while ( data Set . has Next ( ) ) { if ( is Running In Process ) { operator . check For Stop ( ) ; } if ( should Stop ) { throw new Process Stopped Exception ( ) ; } Data Set Row current Row = data Set . next Row ( ) ; if ( listener ! = null ) { update Process ( listener , data Set . get Current Row Index ( ) , number Of Rows ) ; } Data Row row = factory . create ( attributes . length ) ; example Table . add Data Row ( row ) ; int attribute Index = NUM ; for ( Attribute attribute : attributes ) { if ( current Row . is Missing ( attribute Columns [ attribute Index ] ) ) { row . set ( attribute , Double . Na N ) ; } else { switch ( attribute . get Value Type ( ) ) { case Ontology . INTEGER : case Ontology . NUMERICAL : case Ontology . REAL : row . set ( attribute , get Number ( current Row , attribute Columns [ attribute Index ] ) ) ; break ; case Ontology . DATE TIME : case Ontology . TIME : case Ontology . DATE : row . set ( attribute , get Date ( current Row , attribute Columns [ attribute Index ] ) ) ; break ; default : row . set ( attribute , get String Index ( attribute , current Row , attribute Columns [ attribute Index ] ) ) ; } } attribute Index + + ; } } }",
    "label": 1
  },
  {
    "text_1": "determine whether the provided method name is valid in java .",
    "text_2": "private static boolean is Valid Method Name ( String method Name ) { return method Name . matches ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "mor alize dag and calculate adjacency matrix representation for a bayes network , effec ively converting the directed acyclic graph to an undirected graph .",
    "text_2": "public boolean [ ] [ ] mor alize ( Bayes Net bayes Net ) { int n Nodes = bayes Net . get Nr Of Nodes ( ) ; boolean [ ] [ ] b Adjacency Matrix = new boolean [ n Nodes ] [ n Nodes ] ; for ( int i Node = NUM ; i Node < n Nodes ; i Node + + ) { Parent Set parents = bayes Net . get Parent Sets ( ) [ i Node ] ; mor alize Node ( parents , i Node , b Adjacency Matrix ) ; } return b Adjacency Matrix ; }",
    "label": 1
  },
  {
    "text_1": "gwt maven plugin 1 test launch",
    "text_2": "public void test Creating Launcher With Jetty NUM ( ) { Swt Bot Project Creation . create Maven Gwt Project Is Created NUM ( bot , PROJECT NAME , PACKAGE NAME ) ; Swt Bot Project Debug . launch GWT Dev Mode With Jetty Then Terminate It ( bot , PROJECT NAME ) ; String persisted Args = Swt Bot Project Debug . get The Program Args Text Box ( bot ) ; assert True ( persisted Args . contains ( STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "after processing to delete storage that might be created in the test .",
    "text_2": "@ After Method public void delete Storage ( ) throws Business Exception , IO Exception , Serialization Exception { if ( null ! = storage Data ) { if ( storage Manager . get Recording State ( ) = = Recording State . ON ) { storage Manager . stop Recording ( ) ; } if ( ! storage Manager . is Storage Closed ( storage Data ) ) { storage Manager . close Storage ( storage Data ) ; } storage Manager . delete Storage ( storage Data ) ; storage Data = null ; } assert That ( storage Manager . get Existing Storages ( ) , is ( empty ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method will be used to read the byte array from file based on length ( number of bytes )",
    "text_2": "@ Override public byte [ ] read Byte Array ( String file Path , int length ) { File Channel file Channel = update Cache ( file Path ) ; Byte Buffer byte Bffer = read ( file Channel , length ) ; return byte Bffer . array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "return true if c is part of the currently used menu",
    "text_2": "public boolean is Component Part Of Current Menu ( Component c ) { if ( selection . size ( ) > NUM ) { Menu Element me = selection . element At ( NUM ) ; return is Component Part Of Current Menu ( me , c ) ; } else return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "replaces un printable characters by their e spaced ( or unicode escaped ) equivalents in the given string",
    "text_2": "protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i + + ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM | | ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create an image warp with some additional transform information .",
    "text_2": "public Image Warp ( Buffered Image bi , Geo Coord Transformation transform , Data Bounds image Bounds ) { if ( bi ! = null ) { iwidth = bi . get Width ( ) ; iheight = bi . get Height ( ) ; set Geo Trans ( transform ) ; set Image Bounds ( image Bounds ) ; pixels = get Pixels ( bi , NUM , NUM , iwidth , iheight ) ; bi = null ; } }",
    "label": 1
  },
  {
    "text_1": "encodes the given bytes as a base 58 string ( no checksum is appended ) .",
    "text_2": "public static String encode ( byte [ ] input ) { if ( input . length = = NUM ) { return STRING ; } int zeros = NUM ; while ( zeros < input . length & & input [ zeros ] = = NUM ) { + + zeros ; } input = Arrays . copy Of ( input , input . length ) ; char [ ] encoded = new char [ input . length * NUM ] ; int output Start = encoded . length ; for ( int input Start = zeros ; input Start < input . length ; ) { encoded [ - - output Start ] = ALPHABET [ div mod ( input , input Start , NUM , NUM ) ] ; if ( input [ input Start ] = = NUM ) { + + input Start ; } } while ( output Start < encoded . length & & encoded [ output Start ] = = ENCODED ZERO ) { + + output Start ; } while ( - - zeros > = NUM ) { encoded [ - - output Start ] = ENCODED ZERO ; } return new String ( encoded , output Start , encoded . length - output Start ) ; }",
    "label": 1
  },
  {
    "text_1": "transforms multiple paths will all matrices .",
    "text_2": "public void path Values To Pixel ( List < Path > paths ) { for ( int i = NUM ; i < paths . size ( ) ; i + + ) { path Value To Pixel ( paths . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "set a directory to which pictures taken by camera will be saved . useful only when camera is a pick source",
    "text_2": "public Pick Request with Camera Pics Directory ( @ Nullable final File p Dir File ) { this . m Custom Camera Pics Dir Path = p Dir File = = null ? null : p Dir File . get Absolute Path ( ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "calculate interval distance between items",
    "text_2": "private void calc Interval Dis ( ) { if ( m Mark Text Paint = = null ) { return ; } String default Text = STRING ; Rect temp = new Rect ( ) ; int max = NUM ; if ( m Items ! = null & & m Items . size ( ) > NUM ) { for ( String i : m Items ) { m Mark Text Paint . get Text Bounds ( i , NUM , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { m Mark Text Paint . get Text Bounds ( default Text , NUM , default Text . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! Text Utils . is Empty ( m Addition Center Mark ) ) { m Mark Text Paint . set Text Size ( m Normal Text Size ) ; m Mark Text Paint . get Text Bounds ( m Addition Center Mark , NUM , m Addition Center Mark . length ( ) , temp ) ; m Addition Center Mark Width = temp . width ( ) ; max + = temp . width ( ) ; } m Interval Dis = max * m Interval Factor ; }",
    "label": 1
  },
  {
    "text_1": "removes all graphics from the overlay .",
    "text_2": "public void clear ( ) { synchronized ( m Lock ) { m Graphics . clear ( ) ; } post Invalidate ( ) ; }",
    "label": 1
  },
  {
    "text_1": "removes a listener receiving progress notifications .",
    "text_2": "public synchronized void remove Listener ( Listener l ) { listeners . remove ( l ) ; }",
    "label": 1
  },
  {
    "text_1": "process the datastream and update the variables",
    "text_2": "private void process ( ) { Array List < Point NUM D > p List = new Array List < Point NUM D > ( ) ; Array List < Color > c List = new Array List < Color > ( ) ; while ( reader . get Pointer ( ) < reader . get Total Bit Len ( ) ) { Point NUM D p = get Point Coords ( ) ; p List . add ( p ) ; float [ ] cc = { NUM , NUM , NUM , NUM } ; for ( int z = NUM ; z < col Comp Count ; z + + ) { cc [ z ] = reader . get Float ( bits Per Component ) ; } Color c = new Color ( cc [ NUM ] , cc [ NUM ] , cc [ NUM ] , cc [ NUM ] ) ; c List . add ( c ) ; } int total Rows = p List . size ( ) / vertices Per Row ; for ( int mm = NUM ; mm < ( total Rows - NUM ) ; mm + + ) { int m Rows = mm * total Rows ; for ( int nn = NUM ; nn < ( vertices Per Row - NUM ) ; nn + + ) { int nm = nn + m Rows ; int [ ] t = new int [ NUM ] ; t [ NUM ] = nm ; t [ NUM ] = t [ NUM ] = nm + NUM ; t [ NUM ] = t [ NUM ] = nm + vertices Per Row ; t [ NUM ] = nm + vertices Per Row + NUM ; for ( int z = NUM ; z < t . length ; z + + ) { triangles . add ( p List . get ( t [ z ] ) ) ; tri Colors . add ( c List . get ( t [ z ] ) ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "converts the last path segment to a long . this supports a common convention for content uris where an id is stored in the last segment .",
    "text_2": "public static long parse Id ( Uri content Uri ) { String last = content Uri . get Last Path Segment ( ) ; return last = = null ? - NUM : Long . parse Long ( last ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the requested relation resources to the included block of the json api document .",
    "text_2": "private void add Included Resources ( Json Api Document json Api Document , Persistent Resource rec , List < String > requested Relation Paths ) { requested Relation Paths . for Each ( null ) ; }",
    "label": 1
  },
  {
    "text_1": "release transport mbean registration .",
    "text_2": "public static void unregister Transport M Bean ( String container Name ) throws Exception { M Bean Server m Bean Server = get M Bean Server ( container Name ) ; if ( m Bean Server = = null ) return ; Object Name transport M Bean Object Name = Transport Constants . create Transport M Bean Object Name ( container Name ) ; if ( m Bean Server . is Registered ( transport M Bean Object Name ) ) { m Bean Server . unregister M Bean ( transport M Bean Object Name ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } } }",
    "label": 1
  },
  {
    "text_1": "returns length if expression has fixed length , - 1 otherwise . negation operators are treated as always variable length .",
    "text_2": "public static int length ( Reg Exp re ) { Reg Exp NUM r ; switch ( re . type ) { case sym . BAR : { r = ( Reg Exp NUM ) re ; int l NUM = length ( r . r NUM ) ; if ( l NUM < NUM ) return - NUM ; int l NUM = length ( r . r NUM ) ; if ( l NUM = = l NUM ) return l NUM ; else return - NUM ; } case sym . CONCAT : { r = ( Reg Exp NUM ) re ; int l NUM = length ( r . r NUM ) ; if ( l NUM < NUM ) return - NUM ; int l NUM = length ( r . r NUM ) ; if ( l NUM < NUM ) return - NUM ; return l NUM + l NUM ; } case sym . STAR : case sym . PLUS : case sym . QUESTION : return - NUM ; case sym . C CLASS : case sym . C CLASS NOT : case sym . CHAR : case sym . CHAR I : return NUM ; case sym . STRING : case sym . STRING I : { String content = ( String ) ( ( Reg Exp NUM ) re ) . content ; return content . length ( ) ; } case sym . TIL DE : case sym . BANG : return - NUM ; case sym . MACRO USE : return length ( macros . get Definition ( ( String ) ( ( Reg Exp NUM ) re ) . content ) ) ; } throw new Error ( STRING + re . type + STRING + re ) ; }",
    "label": 1
  },
  {
    "text_1": "removes a video from the adapter and notify the change .",
    "text_2": "public void remove ( Video video ) { video List . remove ( video ) ; notify Data Set Changed ( ) ; }",
    "label": 1
  },
  {
    "text_1": "return printable form of the object .",
    "text_2": "public String to String ( ) { String s = STRING + ids . to String ( ) + STRING ; return ( s ) ; }",
    "label": 1
  },
  {
    "text_1": "checks to see if the mis si le will hit within the range of the radar station",
    "text_2": "public boolean is Missile Going To Hit ( Entity Missile missile ) { if ( missile = = null | | missile . target Vector = = null ) { return BOOL ; } return ( Vector NUM . distance ( new Vector NUM ( new Pos NUM D ( missile ) ) , new Vector NUM ( x Coord , z Coord ) ) < alarm Range & & Vector NUM . distance ( new Vector NUM ( missile . target Vector ) , new Vector NUM ( x Coord , z Coord ) ) < safety Range ) ; }",
    "label": 1
  },
  {
    "text_1": "performs operations associated with the updated managed object . the operations include : activity logging , executing the post update script of the managed object , and performing a notify update sync action on the managed object .",
    "text_2": "private void perform Update Operations ( Context context , Request request , Json Value after Value , Json Value before Value ) throws Resource Exception { final String managed Id = get Managed Object Id ( context ) ; activity Logger . log ( context , request , STRING , get Managed Object Path ( context ) , before Value , after Value , Status . SUCCESS ) ; managed Object Set Service . update ( context , new Update Request ( managed Id , after Value ) , managed Id , null , before Value , after Value , new Hash Set < > ( Arrays . as List ( property Ptr ) ) , new Hash Set < > ( Arrays . as List ( property Ptr ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "method deletes all files and subdirectories recursively from given directory . returns true if all files deleted false if at least one doesn ' t",
    "text_2": "public static boolean delete Files And Dirs Recursive ( final File directory ) { if ( directory = = null | | ! directory . is Directory ( ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } return delete Files And Dirs ( directory ) ; }",
    "label": 1
  },
  {
    "text_1": "return the hashcode for the key parameter",
    "text_2": "public int hash Code ( Object key ) { return ( key . hash Code ( ) & NUM ) % this . key Table . length ; }",
    "label": 1
  },
  {
    "text_1": "write the map out using a custom routine .",
    "text_2": "private void write Object ( Object Output Stream out ) throws IO Exception { out . default Write Object ( ) ; do Write Object ( out ) ; }",
    "label": 1
  },
  {
    "text_1": "runs the test case .",
    "text_2": "public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . replace Data ( NUM , NUM , STRING ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }",
    "label": 1
  },
  {
    "text_1": "this method pops a node of the defined class and optional uri from the stack . if the uri is not defined , then the latest node of the approach class will be chosen .",
    "text_2": "protected Node pop Node ( Stack < Node > stack , Class < ? extends Node > cls , String uri ) { Node top = stack . is Empty ( ) ? null : stack . peek ( ) ; if ( top ! = null ) { if ( node Matches ( top , cls , uri ) ) { Node node = stack . pop ( ) ; popped Nodes . push ( node ) ; return node ; } else { for ( int i = stack . size ( ) - NUM ; i > = NUM ; i - - ) { if ( node Matches ( stack . get ( i ) , cls , uri ) ) { Node node = stack . remove ( i ) ; popped Nodes . push ( node ) ; return node ; } } } } return null ; }",
    "label": 1
  },
  {
    "text_1": "frees any resources associated with this stream . the internal stream close is called .",
    "text_2": "@ Override public void close ( ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; stream . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "constant , use when the value is null .",
    "text_2": "public static Constant Expression constant ( Object value , Class constant Type ) { return new Constant Expression ( value , constant Type . get Name ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "find ' \\ n ' from \" start \" position if not find , return - 1",
    "text_2": "protected static int find Next New Line Char ( Char Sequence s , int start ) { for ( int i = start ; i < s . length ( ) ; i + + ) { if ( s . char At ( i ) = = STRING ) { return i ; } } return - NUM ; }",
    "label": 1
  },
  {
    "text_1": "returns whether or not a query is currently running for the provided song",
    "text_2": "public boolean is Query Running ( final Bound Entity song ) { synchronized ( m Running Queries ) { return m Running Queries . contains ( song ) ; } }",
    "label": 1
  },
  {
    "text_1": "reads a block starting from the current file pointer .",
    "text_2": "public int read ( char [ ] buffer , int offset , int length ) throws IO Exception { byte [ ] bytes = new byte [ length ] ; int count = file . read ( bytes , NUM , length ) ; for ( int i = NUM ; i < count ; i + + ) { buffer [ offset + i ] = ( char ) bytes [ i ] ; } return count ; }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . list Options ( ) ; while ( enm . has More Elements ( ) ) result . add ( enm . next Element ( ) ) ; result . add Element ( new Option ( STRING + stopwords Tip Text ( ) + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "converts the loggingevent data in xml string format into an actual xml document class instance .",
    "text_2": "private Document parse ( final String data , Document Builder doc Builder ) { if ( doc Builder = = null | | data = = null ) { return null ; } Document document = null ; try { String Builder buf = new String Builder ( NUM ) ; if ( ! data . starts With ( STRING ) ) { buf . append ( BEGIN PART ) ; } buf . append ( data ) ; if ( ! data . ends With ( END PART ) ) { buf . append ( END PART ) ; } Input Source input Source = new Input Source ( new String Reader ( buf . to String ( ) ) ) ; document = doc Builder . parse ( input Source ) ; } catch ( Exception e ) { LOGGER . warn ( STRING + e . get Message ( ) ) ; } return document ; }",
    "label": 1
  },
  {
    "text_1": "quickly converts a hexadecimal string to a byte array .",
    "text_2": "public static byte [ ] decode Hex ( String hex String ) { int length = hex String . length ( ) ; if ( ( length & NUM ) ! = NUM ) { throw new Illegal Argument Exception ( STRING ) ; } boolean bad Hex = BOOL ; byte [ ] out = new byte [ length > > NUM ] ; for ( int i = NUM , j = NUM ; j < length ; i + + ) { int c1 = hex String . char At ( j + + ) ; if ( c1 > STRING ) { bad Hex = BOOL ; break ; } final byte d1 = DIGITS [ c1 ] ; if ( d1 = = - NUM ) { bad Hex = BOOL ; break ; } int c2 = hex String . char At ( j + + ) ; if ( c2 > STRING ) { bad Hex = BOOL ; break ; } final byte d2 = DIGITS [ c2 ] ; if ( d2 = = - NUM ) { bad Hex = BOOL ; break ; } out [ i ] = ( byte ) ( d1 < < NUM | d2 ) ; } if ( bad Hex ) { throw new Illegal Argument Exception ( STRING + hex String ) ; } return out ; }",
    "label": 1
  },
  {
    "text_1": "puts an array of bytes into this byte vector . the byte vector is automatically enlarged if necessary .",
    "text_2": "public Byte Vector put Byte Array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b ! = null ) { System . arraycopy ( b , off , data , length , len ) ; } length + = len ; return this ; }",
    "label": 1
  },
  {
    "text_1": "push the current stylesheet being constructed . if no other stylesheets have been pushed onto the stack , assume the argument is a stylesheet root , and also set the stylesheet root member .",
    "text_2": "public void push Stylesheet ( Stylesheet s ) { if ( m stylesheets . size ( ) = = NUM ) m stylesheet Root = ( Stylesheet Root ) s ; m stylesheets . push ( s ) ; }",
    "label": 1
  },
  {
    "text_1": "return the instructions that appear ( lexically ) after the given instruction .",
    "text_2": "public List < Dex lib Abstract Instruction > instructions After ( Dex lib Abstract Instruction instruction ) { int i = instructions . index Of ( instruction ) ; if ( i = = - NUM ) throw new Illegal Argument Exception ( STRING + instruction + STRING ) ; return instructions . sub List ( i + NUM , instructions . size ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "creates an os r point instruction with its dependent o sr barrier which provides type and variable information . the o sr point instruction is going to be re filled immediately after bc 2 ir , before any other optimizations .",
    "text_2": "public static Instruction osr Helper ( Instruction barrier , Generation Context gc ) { Instruction inst = Osr Point . create ( Y I EL D POINT OSR , null , NUM ) ; gc . save OSR Barrier For Inst ( barrier , inst ) ; return inst ; }",
    "label": 1
  },
  {
    "text_1": "runs the test case .",
    "text_2": "public void run Test ( ) throws Throwable { Document doc ; Node List gender List ; Node gender Node ; Entity Reference ent Ref ; Element ent Element ; Character Data ent Element Text ; int node Type ; doc = ( Document ) load ( STRING , BOOL ) ; gender List = doc . get Elements By Tag Name ( STRING ) ; gender Node = gender List . item ( NUM ) ; ent Ref = ( Entity Reference ) gender Node . get First Child ( ) ; assert Not Null ( STRING , ent Ref ) ; node Type = ( int ) ent Ref . get Node Type ( ) ; if ( equals ( NUM , node Type ) ) { ent Ref = doc . create Entity Reference ( STRING ) ; assert Not Null ( STRING , ent Ref ) ; } ent Element = ( Element ) ent Ref . get First Child ( ) ; assert Not Null ( STRING , ent Element ) ; ent Element Text = ( Character Data ) ent Element . get First Child ( ) ; assert Not Null ( STRING , ent Element Text ) ; { boolean success = BOOL ; try { ent Element Text . set Node Value ( STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code = = DOM Exception . NO MODIFICATION ALLOWED ERR ) ; } assert True ( STRING , success ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns true if this server requires encrypted connections .",
    "text_2": "public boolean is Use SSL ( ) { return use SSL ; }",
    "label": 1
  },
  {
    "text_1": "add a position with the given range and highlighting if it does not exist already .",
    "text_2": "public void add Position ( int offset , int length , String . . . ids ) { Text Attribute highlighting = ids . length = = NUM ? attribute Provider . get Attribute ( ids [ NUM ] ) : attribute Provider . get Merged Attributes ( ids ) ; boolean is Existing = BOOL ; for ( int i = NUM , n = removed Positions . size ( ) ; i < n ; i + + ) { Attributed Position position = removed Positions . get ( i ) ; if ( position = = null ) continue ; if ( position . is Equal ( offset , length , highlighting ) ) { is Existing = BOOL ; removed Positions . set ( i , null ) ; removed Position Count - - ; break ; } } if ( ! is Existing ) { Attributed Position position = presenter . create Highlighted Position ( offset , length , highlighting ) ; added Positions . add ( position ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a child to this node . used solely by the native code .",
    "text_2": "@ Visible For Testing @ Called By Native Unchecked ( STRING ) public void add Child ( Bookmark Node child ) { m Children . add ( child ) ; }",
    "label": 1
  },
  {
    "text_1": "read an integer value from backed bytebuffer .",
    "text_2": "public int read ( ) throws IO Exception { if ( ! buf . has Remaining ( ) ) { return - NUM ; } return buf . get ( ) & NUM ; }",
    "label": 1
  },
  {
    "text_1": "byte compaction mode ( see 5 . 4 . 3 ) permits all 256 possible 8 - bit byte values to be encoded . this includes all ascii characters value 0 to 127 inclusive and provides for international character set support .",
    "text_2": "private static int byte Compaction ( int mode , int [ ] codewords , int code Index , String Builder result ) { if ( mode = = BYTE COMPACTION MODE LATCH ) { int count = NUM ; long value = NUM ; char [ ] decoded Data = new char [ NUM ] ; int [ ] byte Compacted Codewords = new int [ NUM ] ; boolean end = BOOL ; int next Code = codewords [ code Index + + ] ; while ( ( code Index < codewords [ NUM ] ) & & ! end ) { byte Compacted Codewords [ count + + ] = next Code ; value = NUM * value + next Code ; next Code = codewords [ code Index + + ] ; if ( next Code = = TEXT COMPACTION MODE LATCH | | next Code = = BYTE COMPACTION MODE LATCH | | next Code = = NUMERIC COMPACTION MODE LATCH | | next Code = = BYTE COMPACTION MODE LATCH NUM | | next Code = = BEGIN MACRO PDF NUM CONTROL BLOCK | | next Code = = BEGIN MACRO PDF NUM OPTIONAL FIELD | | next Code = = MACRO PDF NUM TERMINATOR ) { code Index - - ; end = BOOL ; } else { if ( ( count % NUM = = NUM ) & & ( count > NUM ) ) { for ( int j = NUM ; j < NUM ; + + j ) { decoded Data [ NUM - j ] = ( char ) ( value % NUM ) ; value > > = NUM ; } result . append ( decoded Data ) ; count = NUM ; } } } if ( code Index = = codewords [ NUM ] & & next Code < TEXT COMPACTION MODE LATCH ) { byte Compacted Codewords [ count + + ] = next Code ; } for ( int i = NUM ; i < count ; i + + ) { result . append ( ( char ) byte Compacted Codewords [ i ] ) ; } } else if ( mode = = BYTE COMPACTION MODE LATCH NUM ) { int count = NUM ; long value = NUM ; boolean end = BOOL ; while ( code Index < codewords [ NUM ] & & ! end ) { int code = codewords [ code Index + + ] ; if ( code < TEXT COMPACTION MODE LATCH ) { count + + ; value = NUM * value + code ; } else { if ( code = = TEXT COMPACTION MODE LATCH | | code = = BYTE COMPACTION MODE LATCH | | code = = NUMERIC COMPACTION MODE LATCH | | code = = BYTE COMPACTION MODE LATCH NUM | | code = = BEGIN MACRO PDF NUM CONTROL BLOCK | | code = = BEGIN MACRO PDF NUM OPTIONAL FIELD | | code = = MACRO PDF NUM TERMINATOR ) { code Index - - ; end = BOOL ; } } if ( ( count % NUM = = NUM ) & & ( count > NUM ) ) { char [ ] decoded Data = new char [ NUM ] ; for ( int j = NUM ; j < NUM ; + + j ) { decoded Data [ NUM - j ] = ( char ) ( value & NUM ) ; value > > = NUM ; } result . append ( decoded Data ) ; count = NUM ; } } } return code Index ; }",
    "label": 1
  },
  {
    "text_1": "the open interface for other classes in crud package to query multiple records by an id array . pass no ids means query all rows .",
    "text_2": "< T > List < T > on Find All ( Class < T > model Class , boolean is Eager , long . . . ids ) { List < T > data List ; if ( is Affect All Lines ( ids ) ) { data List = query ( model Class , null , null , null , null , null , STRING , null , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; } else { data List = query ( model Class , null , get Where Of Ids With Or ( ids ) , null , null , null , STRING , null , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; } return data List ; }",
    "label": 1
  },
  {
    "text_1": "adds an insn to the head of this basic block , just after any phi in sns .",
    "text_2": "public void add Insn To Head ( Insn insn ) { Ssa Insn new Insn = Ssa Insn . make From Rop ( insn , this ) ; insns . add ( get Count Phi Insns ( ) , new Insn ) ; parent . on Insn Added ( new Insn ) ; }",
    "label": 1
  },
  {
    "text_1": "java . lang . boolean intersec t son eof ( java . awt . geom . rectangle 2 d , java . tools . collection ) function to test if the given 2d rectangle intersects any of the shapes given in the collection .",
    "text_2": "private static boolean intersects One Of ( final Rectangle NUM D r , final Collection < ? extends Shape > shapes ) { if ( shapes . is Empty ( ) ) { return BOOL ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "method to extract the url from shared data and delete trackers",
    "text_2": "private String extract Url ( String shared Url ) { String final Url ; final Url = shared Url . trim ( ) ; String [ ] possible urls = final Url . split ( STRING ) ; for ( String url : possible urls ) { if ( Network Manager . is Url ( url ) ) { final Url = url ; break ; } } final Url = final Url . substring ( final Url . last Index Of ( STRING ) + NUM ) ; final Url = final Url . substring ( final Url . last Index Of ( STRING ) + NUM ) ; if ( Network Manager . is Url ( STRING + final Url ) & & ! Network Manager . is Url ( final Url ) ) { final Url = STRING + final Url ; } if ( final Url . contains ( STRING ) ) { final Url = final Url . substring ( NUM , final Url . index Of ( STRING ) ) ; } if ( final Url . contains ( STRING ) ) { final Url = final Url . substring ( NUM , final Url . index Of ( STRING ) ) ; } if ( final Url . contains ( STRING ) ) { final Url = final Url . substring ( NUM , final Url . index Of ( STRING ) ) ; } return final Url ; }",
    "label": 1
  },
  {
    "text_1": "ensures that this vector can hold the specified number of elements without growing .",
    "text_2": "public synchronized void ensure Capacity ( int minimum Capacity ) { if ( element Data . length < minimum Capacity ) { int next = ( capacity Increment < = NUM ? element Data . length : capacity Increment ) + element Data . length ; grow ( minimum Capacity > next ? minimum Capacity : next ) ; } }",
    "label": 1
  },
  {
    "text_1": "moves a box up and down ( rotation poin ty ) . useful for bodies . note : just keep f and f1 from the set rotation angles ( ) method .",
    "text_2": "public void bob ( Mo w zie Model Renderer box , float speed , float degree , boolean bounce , float f , float f1 ) { float bob = ( float ) ( Math . sin ( f * speed ) * f1 * degree - f1 * degree ) ; if ( bounce ) bob = ( float ) - Math . abs ( ( Math . sin ( f * speed ) * f1 * degree ) ) ; box . rotation Point Y + = bob ; }",
    "label": 1
  },
  {
    "text_1": "do the test on the datetime",
    "text_2": "private void assert Serialize And Des Date Time ( String date Time String ) throws Rya Type Resolver Exception { assert Serialize And Des Date Time ( date Time String , date Time String ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a drag context keeping track of touch events , so that a node is made draggable .",
    "text_2": "public Drag Context ( Node draggable ) { this . node = draggable ; this . go To Foreground On Contact = BOOL ; this . touch Id = NULL ID ; this . activated = BOOL ; this . drag Limits = new Bounding Box ( NUM , NUM , Integer . MAX VALUE , Integer . MAX VALUE ) ; this . drag Threshold = NUM ; this . drag Started = BOOL ; this . relocate Threshold = NUM ; this . drag Init Action = null ; this . drag Finish Action = null ; touch Handler = null ; mouse Handler = null ; draggable . add Event Handler ( Touch Event . ANY , touch Handler ) ; draggable . add Event Handler ( Mouse Event . ANY , mouse Handler ) ; }",
    "label": 1
  },
  {
    "text_1": "convert a phone string into a list of string representations of individual phones . the input can use the suffix \" 1 \" to indicate st ressed vowels .",
    "text_2": "protected Linked List < String > split Into Allo phones ( String phone String ) { Linked List < String > phone List = new Linked List < String > ( ) ; for ( int i = NUM ; i < phone String . length ( ) ; i + + ) { String name = null ; for ( int j = NUM ; j > = NUM ; j - - ) { if ( i + j < = phone String . length ( ) ) { String candidate = phone String . substring ( i , i + j ) ; if ( get Allophone ( candidate ) ! = null ) { name = candidate ; i + = j - NUM ; break ; } } } if ( name ! = null ) { phone List . add ( name ) ; } } return phone List ; }",
    "label": 1
  },
  {
    "text_1": "runs single bench am ark configuration .",
    "text_2": "public void run ( ) throws IO Exception , Interrupted Exception { for ( int i = NUM ; i < conn Cnt ; i + + ) exec . submit ( new Client Thread ( ) ) ; Thread . sleep ( NUM * NUM * NUM ) ; exec . shutdown Now ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if the launcher should start another thread .",
    "text_2": "protected boolean do Start ( ) { if ( ! lifecycle . is Active ( ) ) { return BOOL ; } if ( ! is Enable ( ) ) { return BOOL ; } int starting Count = starting Count . get And Increment ( ) ; int thread Count = thread Count . get ( ) + starting Count ; if ( thread Max < thread Count ) { starting Count . decrement And Get ( ) ; on Thread Max ( ) ; return BOOL ; } else if ( is Idle Too Low ( starting Count ) ) { return BOOL ; } else { starting Count . decrement And Get ( ) ; return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "initializes atom ( component ) distributions . this method works great with finite mixture model .",
    "text_2": "public void initialize Atoms For Finite ( List < Datum > data , String filename , Random random ) { beta = new double [ K ] ; dof = new double [ K ] ; omega = new Array List < > ( K ) ; if ( filename ! = null ) { try { loc = Batch Mixture Model . initialize Clusters From File ( filename , K ) ; if ( loc . size ( ) < K ) { loc = Batch Mixture Model . g on z al ez Initialize Mixture Centers ( loc , data , K , random ) ; } } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; loc = Batch Mixture Model . g on z al ez Initialize Mixture Centers ( data , K , random ) ; } } else { loc = Batch Mixture Model . g on z al ez Initialize Mixture Centers ( data , K , random ) ; } log . debug ( STRING , loc ) ; for ( int k = NUM ; k < this . K ; k + + ) { beta [ k ] = base Beta ; dof [ k ] = base Nu ; omega . add ( base Omega ) ; } }",
    "label": 1
  },
  {
    "text_1": "decode the payload if the content - type is text or json .",
    "text_2": "public String decode ( String encoded ) { Json Object object = new Json Object ( encoded ) ; Json Array headers = object . get Json Array ( STRING ) ; for ( Object header Obj : headers ) { Json Array header = ( Json Array ) header Obj ; String key = header . get String ( NUM ) ; String value = header . get String ( NUM ) ; if ( key . equals Ignore Case ( CONTENT TYPE ) & & ( value . contains ( STRING ) | | value . contains ( APPLICATION JSON ) ) ) { try { object . put ( STRING , new Json Object ( new String ( object . get Binary ( PAYLOAD ) , Charset . for Name ( UTF NUM ) ) ) ) ; } catch ( Decode Exception e ) { object . put ( STRING , new String ( object . get Binary ( PAYLOAD ) , Charset . for Name ( UTF NUM ) ) ) ; } object . remove ( PAYLOAD ) ; break ; } } return object . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "construct a reactiveseq from an publisher",
    "text_2": "public static < T > Reactive Seq < T > from Publisher ( final Publisher < ? extends T > publisher ) { Objects . require Non Null ( publisher ) ; final Seq Subscriber < T > sub = Seq Subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . stream ( ) ; }",
    "label": 1
  },
  {
    "text_1": "should be called whenever a field was updated",
    "text_2": "public void fire State Changed ( ) { Change Event e = new Change Event ( this ) ; for ( Change Listener listener : listeners ) { listener . state Changed ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "updates the font of a given fontname to be newname .",
    "text_2": "private static boolean check Font ( String font Name , String new Name , String test String , boolean force ) { boolean displayable = BOOL ; Font f = UI Manager . get Font ( font Name ) ; if ( f ! = null & & ! new Name . equals Ignore Case ( f . get Name ( ) ) ) { if ( ! GUI Utils . can Display ( f , test String ) | | force ) { f = new Font ( new Name , f . get Style ( ) , f . get Size ( ) ) ; if ( GUI Utils . can Display ( f , test String ) ) UI Manager . put ( font Name , f ) ; else displayable = BOOL ; } } else if ( f ! = null ) { displayable = GUI Utils . can Display ( f , test String ) ; } else { displayable = BOOL ; } return displayable ; }",
    "label": 1
  },
  {
    "text_1": "json . org spec says that all control characters must be escaped .",
    "text_2": "private boolean should Be Escaped ( char c ) { return c < STRING | | ( c > = STRING & & c < STRING ) | | ( c > = STRING & & c < STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "notify this object that it has been deregistered as a listener with a source with respect to the supplied event name",
    "text_2": "@ Override public synchronized void dis connection Notification ( String event Name , Object source ) { List < Object > listenees = m listenees . get ( event Name ) ; if ( listenees ! = null ) { listenees . remove ( source ) ; if ( listenees . size ( ) = = NUM ) { m listenees . remove ( event Name ) ; } } if ( event Name . compare To ( STRING ) = = NUM ) { stop ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "writes personid usergroup delay in hr",
    "text_2": "private void write Exper iec ed And Causing Person Delay ( ) { Sorted Map < Double , Map < Id < Person > , Double > > time Bin NUM Affected Person NUM Delay = get Exper ien ced Person Delay ( NUM ) ; Sorted Map < Double , Map < Id < Person > , Double > > time Bin NUM Causing Person NUM Delay = get Causing Person Delay ( NUM ) ; if ( time Bin NUM Affected Person NUM Delay . size ( ) ! = NUM ) throw new Runtime Exception ( STRING ) ; Map < Id < Person > , Double > aff ec ted person NUM Delay = time Bin NUM Affected Person NUM Delay . get ( simulation End Time ) ; Map < Id < Person > , Double > caused Person NUM Delay = time Bin NUM Causing Person NUM Delay . get ( simulation End Time ) ; Buffered Writer writer = IO Utils . get Buffered Writer ( run Dir + STRING + pricing Scenario + suffix For S oring + STRING ) ; try { writer . write ( STRING ) ; for ( Id < Person > id : caused Person NUM Delay . key Set ( ) ) { writer . write ( id + STRING + pf . get Mun ich User Group From Person Id ( id ) + STRING + aff ec ted person NUM Delay . get ( id ) / NUM + STRING + caused Person NUM Delay . get ( id ) / NUM + STRING ) ; } writer . close ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( STRING + e ) ; } }",
    "label": 1
  },
  {
    "text_1": "gets the socks proxy server port .",
    "text_2": "private int socks Get Server Port ( ) { Inet Socket Address addr = ( Inet Socket Address ) proxy . address ( ) ; return addr . get Port ( ) ; }",
    "label": 1
  },
  {
    "text_1": "strip out all characters not accepted by given filter",
    "text_2": "@ Not Null @ Contract ( pure = BOOL ) public static String strip ( @ Not Null final String s , @ Not Null final Char Filter filter ) { final String Builder result = new String Builder ( s . length ( ) ) ; for ( int i = NUM ; i < s . length ( ) ; i + + ) { char ch = s . char At ( i ) ; if ( filter . accept ( ch ) ) { result . append ( ch ) ; } } return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks whether the given entity is near this entity .",
    "text_2": "public boolean next To ( final Entity entity , final double step ) { final Rectangle NUM D this Area = new Rectangle NUM D . Double ( x - step , y - step , area . get Width ( ) + NUM * step , area . get Height ( ) + NUM * step ) ; return this Area . intersects ( entity . get Area ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a new instance with the union of the param expressions from \" this \" and the \" other \" instance .",
    "text_2": "@ Override public Params Request Condition combine ( Params Request Condition other ) { Set < Param Expression > set = new Linked Hash Set < > ( this . expressions ) ; set . add All ( other . expressions ) ; return new Params Request Condition ( set ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs a new quarter .",
    "text_2": "public Quarter ( int quarter , Year year ) { if ( ( quarter < FIRST QUARTER ) | | ( quarter > LAST QUARTER ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . year = ( short ) year . get Year ( ) ; this . quarter = ( byte ) quarter ; peg ( Calendar . get Instance ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a database configuration with the required parameters for opening a database and default values for all other parameters .",
    "text_2": "public SQ Lite Database Configuration ( String path , int open Flags ) { if ( path = = null ) { throw new Illegal Argument Exception ( STRING ) ; } this . path = path ; label = strip Path For Logs ( path ) ; this . open Flags = open Flags ; max Sql Cache Size = NUM ; locale = Locale . get Default ( ) ; }",
    "label": 1
  },
  {
    "text_1": "decides if given x - coordinate in screen space needs to be interpreted as \" within \" the normalized thumb x - coordinate .",
    "text_2": "private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) < = thumb Half Width ; }",
    "label": 1
  },
  {
    "text_1": "unregister the x tiff tile codec corresponding to the tiff compression type .",
    "text_2": "public static void un Register Tile Codec ( int comp ) { XTIFF Tile Codec cod = get Tile Codec ( comp ) ; tile Codecs . remove ( cod ) ; }",
    "label": 1
  },
  {
    "text_1": "determine if given vs an is an iv r vs an",
    "text_2": "public boolean is Ivr Vsan ( int vsan Id ) { boolean in Range = v sans . contains ( vsan Id ) ; if ( ! in Range ) { for ( Int Range range : get V sans Ranges ( ) ) { in Range = range . contains Integer ( vsan Id ) ; if ( in Range ) { break ; } } } return in Range ; }",
    "label": 1
  },
  {
    "text_1": "add time for a filter operation interval .",
    "text_2": "public void end Filter Interval ( ) { end Millis = System . current Time Millis ( ) ; total Filter Millis + = ( end Millis - interval Start Millis ) ; state = Task State . other ; }",
    "label": 1
  },
  {
    "text_1": "returns a parseable string representation of this constant size .",
    "text_2": "@ Override public String encode ( ) { return value = = int Value ( ) ? Integer . to String ( int Value ( ) ) + unit . encode ( ) : Double . to String ( value ) + unit . encode ( ) ; }",
    "label": 1
  },
  {
    "text_1": "test where each operation locks only a single resource ( high concurrency ) .",
    "text_2": "public void test single Resource Locking high Concurrency NUM ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . N THREADS , STRING ) ; properties . set Property ( Test Options . N TASKS , STRING ) ; properties . set Property ( Test Options . N RESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PRE DECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }",
    "label": 1
  },
  {
    "text_1": "writes the value of the property to the given object . it uses reflection and looks for a method starting with \" set \" followed by the capitalized property name and with one parameter with the same type as the property .",
    "text_2": "public void write To Object ( Object object ) { try { Method method = Bean Utils . get Write Method ( object . get Class ( ) , get Name ( ) , get Type ( ) ) ; if ( method ! = null ) { method . invoke ( object , new Object [ ] { get Value ( ) } ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns an rgb value from color components in the specified color space .",
    "text_2": "public static int to RGB ( Color Space color Space , float . . . components ) { float [ ] rgb = color Space . to RGB ( components ) ; if ( rgb [ NUM ] < NUM | | rgb [ NUM ] < NUM | | rgb [ NUM ] < NUM | | rgb [ NUM ] > NUM | | rgb [ NUM ] > NUM | | rgb [ NUM ] > NUM ) { return NUM ; } return NUM | ( ( int ) ( rgb [ NUM ] * NUM ) < < NUM ) | ( ( int ) ( rgb [ NUM ] * NUM ) < < NUM ) | ( int ) ( rgb [ NUM ] * NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "replaces un printable characters by their escaped ( or unicode escaped ) equivalents in the given string",
    "text_2": "protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i + + ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM | | ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "record file share related event and audit",
    "text_2": "public void record Mirror Operation ( Db Client db Client , Operation Type Enum op Type , Operation . Status status , Object . . . ext Param ) { try { boolean op Status = ( Operation . Status . ready = = status ) ? BOOL : BOOL ; String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ; String ev Desc = op Type . get Description ( ) ; String op Stage = Audit Log Manager . AUDITOP END ; logger . info ( STRING , op Type . to String ( ) , ev Type . to String ( ) + STRING + ev Desc ) ; record Bourne Mirror Event ( db Client , get Id ( ) , ev Type , status , ev Desc ) ; switch ( op Type ) { case CREATE FILE MIRROR : case START FILE MIRROR : case SUSPEND FILE MIRROR : case DETACH FILE MIRROR : case PAUSE FILE MIRROR : case RESUME FILE MIRROR : case FAILOVER FILE MIRROR : case STOP FILE MIRROR : case FAIL BACK FILE MIRROR : case RES Y NC FILE MIRROR : case REFRESH FILE MIRROR : case MODIFY FILE MIRROR R PO : audit File ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; default : logger . error ( STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , op Type . to String ( ) , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns true if the virtual volume is a distributed volume .",
    "text_2": "public boolean is Distributed ( ) { return ! is Local ( ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new server side sort request control with the provided criticality and list of sort keys .",
    "text_2": "public static Server Side Sort Request Control new Control ( final boolean is Critical , final Collection < Sort Key > keys ) { Reject . if Null ( keys ) ; Reject . if False ( ! keys . is Empty ( ) , STRING ) ; return new Server Side Sort Request Control ( is Critical , Collections . unmodifiable List ( new Array List < Sort Key > ( keys ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns if this entity triggers block . on entity walking on the blocks they walk on . used for spid ers and wol ves to prevent them from tr ampl ing crops",
    "text_2": "protected boolean can Trigger Walking ( ) { return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "force buffered operations to the filesystem .",
    "text_2": "public synchronized void flush ( ) throws IO Exception { check Not Closed ( ) ; trim To Size ( ) ; trim To File Count ( ) ; journal Writer . flush ( ) ; }",
    "label": 1
  },
  {
    "text_1": "use interpolator to get t",
    "text_2": "private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }",
    "label": 1
  },
  {
    "text_1": "creates the \" null \" security descriptor",
    "text_2": "private Windows Security Descriptor ( ) { this . sid List = null ; this . acl Buffer = null ; this . sd Buffer = null ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the database is in - memory .",
    "text_2": "public boolean is In Memory Db ( ) { return path . equals Ignore Case ( MEMORY DB PATH ) ; }",
    "label": 1
  },
  {
    "text_1": "avoids tur k ish ' i ' problem .",
    "text_2": "public static String upper ( String s ) { return s . to Upper Case ( Locale . ENGLISH ) ; }",
    "label": 1
  },
  {
    "text_1": "fill the nibble array with the specified value .",
    "text_2": "public void fill ( byte value ) { value & = NUM ; Arrays . fill ( data , ( byte ) ( value < < NUM | value ) ) ; }",
    "label": 1
  },
  {
    "text_1": "update functionality test test update 4 ( ) . updates values in a several columns in the table using where condition in update command",
    "text_2": "public void test Update NUM ( ) { int new Value NUM = - NUM ; int new Value NUM = - NUM ; String update Query = STRING + Database Creator . TEST TABLE NUM + STRING + new Value NUM + STRING + new Value NUM + STRING ; try { int num = statement . execute Update ( update Query ) ; int expected Updated = NUM ; assert Equals ( STRING , expected Updated , num ) ; String select Query = STRING + Database Creator . TEST TABLE NUM ; Result Set result = statement . execute Query ( select Query ) ; while ( result . next ( ) ) { int id = result . get Int ( STRING ) ; } result . close ( ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "partition the given files into the specified bins trying to approximately balance the size of the bins according to the lengths of the files . note that some bins may be empty , in the presence of 0 length files .",
    "text_2": "static List < List < File > > partition ( final int bin Count , final File . . . files ) { final File [ ] sort = Arrays . copy Of ( files , files . length ) ; return bin Th em ( bin Count , sort ) ; }",
    "label": 1
  },
  {
    "text_1": "called when fragment ing a handshake message .",
    "text_2": "public Fragmented Handshake Message ( byte [ ] frag mented Bytes , Handshake Type type , int fragment Offset , int message Length , Inet Socket Address peer Address ) { super ( peer Address ) ; this . type = type ; this . message Length = message Length ; this . frag mented Bytes = Arrays . copy Of ( frag mented Bytes , frag mented Bytes . length ) ; set Fragment Offset ( fragment Offset ) ; set Fragment Length ( frag mented Bytes . length ) ; }",
    "label": 1
  },
  {
    "text_1": "creates default implementation of task distributor",
    "text_2": "public static Executor create Task Distributor ( ) { return Executors . new Cached Thread Pool ( create Thread Factory ( Thread . NORM PRIORITY , STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "java . util . enumset of ( e , e , e , e )",
    "text_2": "public void test Of EE EE ( ) { Enum Set < Enum With Inner Class > enum Set = Enum Set . of ( Enum With Inner Class . a , Enum With Inner Class . b , Enum With Inner Class . c , Enum With Inner Class . d ) ; assert Equals ( STRING , NUM , enum Set . size ( ) ) ; assert True ( STRING , enum Set . contains ( Enum With Inner Class . a ) ) ; assert True ( STRING , enum Set . contains ( Enum With Inner Class . d ) ) ; try { Enum Set . of ( ( Enum With Inner Class ) null , null , null , null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } Enum Set < Huge Enum With Inner Class > huge Enum Set = Enum Set . of ( Huge Enum With Inner Class . a , Huge Enum With Inner Class . b , Huge Enum With Inner Class . c , Huge Enum With Inner Class . d ) ; assert Equals ( NUM , huge Enum Set . size ( ) ) ; assert True ( huge Enum Set . contains ( Huge Enum With Inner Class . a ) ) ; assert True ( huge Enum Set . contains ( Huge Enum With Inner Class . d ) ) ; try { Enum Set . of ( ( Huge Enum With Inner Class ) null , null , null , null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } }",
    "label": 1
  },
  {
    "text_1": "create a push able lazy future stream using the supplied react pool",
    "text_2": "public < T > Push able Lazy Future Stream < T > future Stream ( final Lazy React s ) { final Queue < T > q = create Queue ( ) ; return new Push able Lazy Future Stream < T > ( q , s . from Stream ( q . stream ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "inserts new drive files from tracks without a drive id .",
    "text_2": "private void insert New Drive Files ( ) throws IO Exception { Cursor cursor = null ; try { cursor = my Tracks Provider Utils . get Track Cursor ( Sync Utils . NO DRIVE ID TRACK S QUERY , null , null ) ; long recording Track Id = Preferences Utils . get Long ( context , R . string . recording track id key ) ; if ( cursor ! = null & & cursor . move To First ( ) ) { do { Track track = my Tracks Provider Utils . create Track ( cursor ) ; if ( track . get Id ( ) = = recording Track Id ) { continue ; } Sync Utils . insert Drive File ( drive , folder Id , context , my Tracks Provider Utils , track , BOOL , BOOL ) ; } while ( cursor . move To Next ( ) ) ; } } finally { if ( cursor ! = null ) { cursor . close ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "constructs a new instan ted model editor from a bayes im wrapper .",
    "text_2": "public Bayes Im Editor Obs ( Bayes Im Wrapper Obs bayes Im Wrapper Obs ) { this ( bayes Im Wrapper Obs , bayes Im Wrapper Obs . get Bayes Im ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "construct a new neuron group from a list of neurons .",
    "text_2": "public Neuron Group ( final Network net , final List < Neuron > neurons ) { super ( net ) ; neuron List = new Array List < Neuron > ( neurons . size ( ) ) ; for ( Neuron neuron : neurons ) { add Neuron ( neuron ) ; } neuron List = new Copy On Write Array List < Neuron > ( neuron List ) ; update Rule = get Neuron Type ( ) ; reset Subsampling Indices ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true for a public method .",
    "text_2": "public boolean is Public ( ) { return Modifier . is Public ( method . get Modifiers ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convert hex string to byte [ ]",
    "text_2": "public static byte [ ] hex String To Bytes ( String hex String ) { if ( hex String = = null | | hex String . equals ( STRING ) ) { return null ; } hex String = hex String . to Upper Case ( ) ; int length = hex String . length ( ) / NUM ; char [ ] hex Chars = hex String . to Char Array ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = NUM ; i < length ; i + + ) { int pos = i * NUM ; d [ i ] = ( byte ) ( char To Byte ( hex Chars [ pos ] ) < < NUM | char To Byte ( hex Chars [ pos + NUM ] ) ) ; } return d ; }",
    "label": 1
  },
  {
    "text_1": "creates a bitset based on a string representation of binary digits .",
    "text_2": "private Bit Set create Bit Set ( final String binary String ) { final Bit Set bset = new Bit Set ( binary String . length ( ) ) ; boolean bit True = BOOL ; for ( int i = NUM ; i < binary String . length ( ) ; i + + ) { if ( binary String . char At ( i ) = = STRING ) { bit True = BOOL ; } else { bit True = BOOL ; } bset . set ( i , bit True ) ; } return bset ; }",
    "label": 1
  },
  {
    "text_1": "helper to get a list of item from a list o model",
    "text_2": "protected List < Item > to Items ( List < Model > models ) { if ( models = = null ) { return Collections . empty List ( ) ; } int size = models . size ( ) ; List < Item > items = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i + + ) { items . add ( to Item ( models . get ( i ) ) ) ; } return items ; }",
    "label": 1
  },
  {
    "text_1": "( since linux 2 . 2 . 8 ) cpu number last executed on .",
    "text_2": "public int processor ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }",
    "label": 1
  },
  {
    "text_1": "closes the file writer and deletes the lockfile ( if possible ) .",
    "text_2": "@ Override public void close ( ) throws IO Exception { try { out . close ( ) ; } finally { lock File . delete ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "zlib compress 2 byte",
    "text_2": "public static byte [ ] compress For Zlib ( byte [ ] bytes To Compress ) { Deflater deflater = new Deflater ( ) ; deflater . set Input ( bytes To Compress ) ; deflater . finish ( ) ; byte [ ] bytes Compressed = new byte [ Short . MAX VALUE ] ; int number Of Bytes After Compression = deflater . deflate ( bytes Compressed ) ; byte [ ] return Values = new byte [ number Of Bytes After Compression ] ; System . arraycopy ( bytes Compressed , NUM , return Values , NUM , number Of Bytes After Compression ) ; return return Values ; }",
    "label": 1
  },
  {
    "text_1": "given a set of query params , executes as a query against a random solr client and asserts that exactly one document is returned",
    "text_2": "public static Solr Document assert Search One Doc ( Solr Params p ) throws Exception { Solr Document List docs = assert Search ( p ) ; assert Equals ( STRING + p . to String ( ) + STRING + docs . to String ( ) , NUM , docs . get Num Found ( ) ) ; assert Equals ( STRING + p . to String ( ) + STRING + docs . to String ( ) , NUM , docs . size ( ) ) ; return docs . get ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs an adaptive grid archive with the specified capacity with the specified number of divisions along each objective .",
    "text_2": "public Adaptive Grid Archive ( int capacity , Problem problem , int number Of Divisions ) { this . capacity = capacity ; this . problem = problem ; this . number Of Divisions = number Of Divisions ; minimum = new double [ problem . get Number Of Objectives ( ) ] ; maximum = new double [ problem . get Number Of Objectives ( ) ] ; density = new int [ ( int ) Math . pow ( number Of Divisions , problem . get Number Of Objectives ( ) ) ] ; adapt Grid ( ) ; }",
    "label": 1
  },
  {
    "text_1": "calculates the quotient of this div b and places the quotient in the provided mutable biginteger objects and the remainder object is returned . uses algorithm d in knuth section 4 . 3 . 1 . many optimizations to that algorithm have been adapted from the col in pl um b c library . it special cases one word divis ors for speed . the content of b is not changed .",
    "text_2": "Mutable Big Integer divide Kn uth ( Mutable Big Integer b , Mutable Big Integer quotient , boolean need Remainder ) { if ( b . int Len = = NUM ) throw new Arithmetic Exception ( STRING ) ; if ( int Len = = NUM ) { quotient . int Len = quotient . offset = NUM ; return need Remainder ? new Mutable Big Integer ( ) : null ; } int cmp = compare ( b ) ; if ( cmp < NUM ) { quotient . int Len = quotient . offset = NUM ; return need Remainder ? new Mutable Big Integer ( this ) : null ; } if ( cmp = = NUM ) { quotient . value [ NUM ] = quotient . int Len = NUM ; quotient . offset = NUM ; return need Remainder ? new Mutable Big Integer ( ) : null ; } quotient . clear ( ) ; if ( b . int Len = = NUM ) { int r = divide One Word ( b . value [ b . offset ] , quotient ) ; if ( need Remainder ) { if ( r = = NUM ) return new Mutable Big Integer ( ) ; return new Mutable Big Integer ( r ) ; } else { return null ; } } if ( int Len > = K NU TH POW NUM THRES H LEN ) { int trailing Zero Bits = Math . min ( get Lowest Set Bit ( ) , b . get Lowest Set Bit ( ) ) ; if ( trailing Zero Bits > = K NU TH POW NUM THRES H ZEROS * NUM ) { Mutable Big Integer a = new Mutable Big Integer ( this ) ; b = new Mutable Big Integer ( b ) ; a . right Shift ( trailing Zero Bits ) ; b . right Shift ( trailing Zero Bits ) ; Mutable Big Integer r = a . divide Kn uth ( b , quotient ) ; r . left Shift ( trailing Zero Bits ) ; return r ; } } return divide Magnitude ( b , quotient , need Remainder ) ; }",
    "label": 1
  },
  {
    "text_1": "called when all the tabs in the current stack need to be closed . when called , the tabs will still be part of the model .",
    "text_2": "public void on Tabs All Closing ( long time , boolean incognito ) { }",
    "label": 1
  },
  {
    "text_1": "return the static singleton for the p ta",
    "text_2": "public static PTA Bridge v ( ) { return v ; }",
    "label": 1
  },
  {
    "text_1": "adds an un - parameterized view to the named window .",
    "text_2": "public Create Window Clause add View ( String namespace , String name ) { views . add ( View . create ( namespace , name ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "returns the sample standard deviation . ref : r . r . so k al , f . j . ro h lf , bio metry : the princi ples and practice of statistics in biological research ( w . h . fre em an and company , new york , 1998 , 3rd edition ) p . 53 .",
    "text_2": "public static double sample Standard Deviation ( int size , double sample Variance ) { double s , Cn ; int n = size ; s = Math . sqrt ( sample Variance ) ; if ( n > NUM ) { Cn = NUM + NUM / ( NUM * ( n - NUM ) ) ; } else { Cn = Math . sqrt ( ( n - NUM ) * NUM ) * Gamma . gamma ( ( n - NUM ) * NUM ) / Gamma . gamma ( n * NUM ) ; } return Cn * s ; }",
    "label": 1
  },
  {
    "text_1": "parse yyyy - mm - dd into a 3 element array [ yyyy , mm , dd ] .",
    "text_2": "private int [ ] parse YMD ( String string ) { string = string . trim ( ) ; try { if ( string . char At ( NUM ) ! = STRING | | string . char At ( NUM ) ! = STRING ) { throw new Illegal Argument Exception ( STRING ) ; } int [ ] ymd = new int [ NUM ] ; ymd [ NUM ] = Integer . value Of ( string . substring ( NUM , NUM ) ) ; ymd [ NUM ] = Integer . value Of ( string . substring ( NUM , NUM ) ) ; ymd [ NUM ] = Integer . value Of ( string . substring ( NUM , NUM ) ) ; return ymd ; } catch ( Number Format Exception ex ) { throw new Illegal Argument Exception ( STRING , ex ) ; } }",
    "label": 1
  },
  {
    "text_1": "a ' | ' separated list of path expressions which define sub sections of the json stream that are to be emitted as separate records . it is possible to have multiple levels of split one for parent and one for child each child record ( or a list of records ) will be emitted as a part of the parent record with null as the key",
    "text_2": "void add Split ( String split Path ) { String [ ] splits = split Path . split ( STRING ) ; for ( String split : splits ) { split = split . trim ( ) ; if ( split . starts With ( STRING ) ) throw new Runtime Exception ( STRING + split ) ; if ( split . length ( ) = = NUM ) continue ; add Field ( split , split , BOOL , BOOL ) ; } }",
    "label": 1
  },
  {
    "text_1": "gets a set of components that this component provider provides .",
    "text_2": "public final Collection < Component > components ( ) { return new Hash Set < > ( components . values ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method removes the end part of a string beginning at a specified marker .",
    "text_2": "public String remove After ( String original , String marker ) { int index = original . index Of ( marker ) ; if ( index ! = - NUM ) { return original . substring ( NUM , index ) ; } return original ; }",
    "label": 1
  },
  {
    "text_1": "writes a formatted string to this object ' s destination using the specified locale , format string , and arguments .",
    "text_2": "public Formatter format ( Locale l , String format , Object . . . args ) { ensure Open ( ) ; int last = - NUM ; int last o = - NUM ; Format String [ ] fsa = parse ( format ) ; for ( int i = NUM ; i < fsa . length ; i + + ) { Format String fs = fsa [ i ] ; int index = fs . index ( ) ; try { switch ( index ) { case - NUM : fs . print ( null , l ) ; break ; case - NUM : if ( last < NUM | | ( args ! = null & & last > args . length - NUM ) ) throw new Missing Format Argument Exception ( fs . to String ( ) ) ; fs . print ( ( args = = null ? null : args [ last ] ) , l ) ; break ; case NUM : last o + + ; last = last o ; if ( args ! = null & & last o > args . length - NUM ) throw new Missing Format Argument Exception ( fs . to String ( ) ) ; fs . print ( ( args = = null ? null : args [ last o ] ) , l ) ; break ; default : last = index - NUM ; if ( args ! = null & & last > args . length - NUM ) throw new Missing Format Argument Exception ( fs . to String ( ) ) ; fs . print ( ( args = = null ? null : args [ last ] ) , l ) ; break ; } } catch ( IO Exception x ) { last Exception = x ; } } return this ; }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "set bounds for the right textview including clip padding .",
    "text_2": "private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }",
    "label": 1
  },
  {
    "text_1": "reports result using future . get conventions .",
    "text_2": "private static < T > T report Get ( Object r ) throws Interrupted Exception , Execution Exception { if ( r = = null ) throw new Interrupted Exception ( ) ; if ( r instanceof Alt Result ) { Throwable x , cause ; if ( ( x = ( ( Alt Result ) r ) . ex ) = = null ) return null ; if ( x instanceof Cancellation Exception ) throw ( Cancellation Exception ) x ; if ( ( x instanceof Completion Exception ) & & ( cause = x . get Cause ( ) ) ! = null ) x = cause ; throw new Execution Exception ( x ) ; } @ Suppress Warnings ( STRING ) T t = ( T ) r ; return t ; }",
    "label": 1
  },
  {
    "text_1": "returns a byte [ ] containing the remainder of ' in ' , closing it when done .",
    "text_2": "public static byte [ ] read Fully ( Input Stream in ) throws IO Exception { try { return read Fully No Close ( in ) ; } finally { in . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "appends ' k : v ' to pw if v is non null .",
    "text_2": "private void append ( Print Writer pw , final String k , final String v ) { if ( v ! = null ) { pw . println ( k + STRING + v ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns an array containing all non - grant permission permissions in the given permission array , including those contained in nested grant permissions in the array .",
    "text_2": "private static Permission [ ] flatten ( Permission [ ] pa ) { List l = new Array List ( pa . length ) ; for ( int i = NUM ; i < pa . length ; i + + ) { Permission p = pa [ i ] ; if ( p instanceof Grant Permission ) { l . add All ( Arrays . as List ( ( ( Grant Permission ) p ) . grants ) ) ; } else { l . add ( p ) ; } } return ( Permission [ ] ) l . to Array ( new Permission [ l . size ( ) ] ) ; }",
    "label": 1
  },
  {
    "text_1": "gettype ( ) method testing . tests that gettype ( ) method returns the value \" x . 509 \"",
    "text_2": "public void test Get Type ( ) { assert Equals ( STRING , tbt crl . get Type ( ) , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "computes the azimuth angle ( clockwise from north ) for the great circle path between this location and a specified location . this angle can be used as the starting azimuth for a great circle path beginning at this location , and passing through the specified location . this function uses a spherical model , not elliptical .",
    "text_2": "public double great Circle Azimuth ( Location location ) { if ( location = = null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat NUM = Math . to Radians ( this . latitude ) ; double lon NUM = Math . to Radians ( this . longitude ) ; double lat NUM = Math . to Radians ( location . latitude ) ; double lon NUM = Math . to Radians ( location . longitude ) ; if ( lat NUM = = lat NUM & & lon NUM = = lon NUM ) { return NUM ; } if ( lon NUM = = lon NUM ) { return lat NUM > lat NUM ? NUM : NUM ; } double y = Math . cos ( lat NUM ) * Math . sin ( lon NUM - lon NUM ) ; double x = Math . cos ( lat NUM ) * Math . sin ( lat NUM ) - Math . sin ( lat NUM ) * Math . cos ( lat NUM ) * Math . cos ( lon NUM - lon NUM ) ; double azimuth Radians = Math . atan NUM ( y , x ) ; return Double . is Na N ( azimuth Radians ) ? NUM : Math . to Degrees ( azimuth Radians ) ; }",
    "label": 1
  },
  {
    "text_1": "generates a new dataset",
    "text_2": "public Instances generate ( ) throws Exception { return generate ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "parses the supplied xsd : double string and returns its value .",
    "text_2": "public static double parse Double ( String s ) { if ( POSITIVE INFINITY . equals ( s ) ) { return Double . POSITIVE INFINITY ; } else if ( NEGATIVE INFINITY . equals ( s ) ) { return Double . NEGATIVE INFINITY ; } else if ( Na N . equals ( s ) ) { return Double . Na N ; } else { s = trim Plus Sign ( s ) ; return Double . parse Double ( s ) ; } }",
    "label": 1
  },
  {
    "text_1": "used to communicate a progress update between a plugin tool and the main whitebox user interface .",
    "text_2": "private void update Progress ( String progress Label , int progress ) { if ( my Host ! = null & & ( ( progress ! = previous Progress ) | | ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }",
    "label": 1
  },
  {
    "text_1": "given a collection of widgets evaluates probability of a connection and makes connections",
    "text_2": "public static Constraint Widget [ ] infer Table List ( Widgets Scene list ) { for ( Constraint Widget widget : list . get Widgets ( ) ) { widget . reset Anchors ( ) ; } return infer Table List ( list . get Root ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "add a listener which will be triggered whenever the asset represented by this panel is modified in any way .",
    "text_2": "public void add Asset Listener ( @ Not Null Action Listener listener ) { my Asset Listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "if the hand back object passed is an ag entimpl , updates the jmx client count",
    "text_2": "@ edu . umd . cs . findbugs . annotations . Suppress Warnings ( value = STRING , justification = STRING ) public void handle Notification ( Notification notification , Object handback ) { if ( handback instanceof Agent Impl ) { Agent Impl agent = ( Agent Impl ) handback ; JMX Connection Notification jmx No tif n = ( JMX Connection Notification ) notification ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , jmx No tif n . get Connection Id ( ) ) ; } agent . update Rmi Clients Count ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "construct alignment state object from a virg in rule and its source span . determines if state is complete ( if no nt present )",
    "text_2": "public Word Alignment State ( final Rule rule , final int start ) { trg Points = new Linked List < > ( ) ; src Length = rule . get French ( ) . length ; num NT = rule . get Arity ( ) ; src Start = start ; final Map < Integer , List < Integer > > alignment Map = rule . get Alignment Map ( ) ; final int [ ] non Terminal Source Positions = rule . get Non Terminal Source Positions ( ) ; final int [ ] trg = rule . get English ( ) ; for ( int trg Index = NUM ; trg Index < trg . length ; trg Index + + ) { final Aligned Source Tokens trg Point = new Aligned Source Tokens ( ) ; if ( trg [ trg Index ] > = NUM ) { if ( alignment Map . contains Key ( trg Index ) ) { for ( int src Idx : alignment Map . get ( trg Index ) ) { trg Point . add ( src Start + src Idx ) ; } } else { trg Point . set Null ( ) ; } } else { trg Point . set Non Terminal ( ) ; final int absolute Non Terminal Source Position = src Start + non Terminal Source Positions [ Math . abs ( trg [ trg Index ] ) - NUM ] ; trg Point . add ( absolute Non Terminal Source Position ) ; } trg Points . add ( trg Point ) ; } }",
    "label": 1
  },
  {
    "text_1": "is this property a solr - standard property , or is it an extra property defined per - core by the user ?",
    "text_2": "protected static boolean is User Defined Property ( String prop Name ) { return ! standard Prop Names . contains ( prop Name ) ; }",
    "label": 1
  },
  {
    "text_1": "draws the specified value label for the specified shape .",
    "text_2": "protected void draw Value Label ( Drawing Context context , Slice slice , double radius , Row row , int row Index ) { Comparable < ? > value = slice . end - slice . start ; Format format = get Value Format ( ) ; if ( ( format = = null ) & & ( value instanceof Number ) ) { format = Number Format . get Instance ( ) ; } String text = ( format ! = null ) ? format . format ( value ) : value . to String ( ) ; Color Mapper colors = get Value Color ( ) ; Paint paint = colors . get ( row Index ) ; Font font = get Value Font ( ) ; double font Size = font . get Size NUM D ( ) ; Location location = get Value Location ( ) ; double align X = get Value Alignment X ( ) ; double align Y = get Value Alignment Y ( ) ; double rotation = get Value Rotation ( ) ; double distance = get Value Distance ( ) ; if ( Math Utils . is Calcul atable ( distance ) ) { distance * = font Size ; } else { distance = NUM ; } double radius Rel Outer = get Outer Radius ( ) ; double radius Rel Inner = get Inner Radius ( ) ; double radius Outer = radius * radius Rel Outer ; double radius Inner = radius * radius Rel Inner ; double distance V = distance ; double label Pos V ; if ( location = = Location . NORTH ) { label Pos V = radius Outer + distance V ; } else if ( location = = Location . SOUTH ) { label Pos V = Math . max ( radius Inner - distance V , NUM ) ; } else { double slice Height = radius Outer - radius Inner ; if ( NUM * distance > = slice Height ) { align Y = NUM ; distance V = NUM ; } label Pos V = radius Inner + distance V + align Y * ( slice Height - NUM * distance V ) ; } double sum = plot . get Sum ( row . get Source ( ) ) ; if ( sum = = NUM ) { return ; } double slice Start Rel = slice . start / sum ; double slice End Rel = slice . end / sum ; double circum ference = NUM * label Pos V * Math . PI ; double distance Rel H = distance / circum ference ; double slice Width Rel = slice End Rel - slice Start Rel ; if ( NUM * distance Rel H > = slice Width Rel ) { align X = NUM ; distance Rel H = NUM ; } double label Pos Rel H = slice Start Rel + distance Rel H + align X * ( slice Width Rel - NUM * distance Rel H ) ; double start = plot . get Start ( ) ; double angle Start = Math . to Radians ( - start ) ; double direction = NUM ; if ( ! plot . is Clockwise ( ) ) { direction = - NUM ; } double angle = angle Start + direction * label Pos Rel H * NUM * Math . PI ; double dir X = Math . cos ( angle ) ; double dir Y = Math . sin ( angle ) ; Label label = new Label ( text ) ; label . set Alignment X ( NUM - NUM * dir X - NUM ) ; label . set Alignment Y ( NUM * dir Y + NUM ) ; label . set Rotation ( rotation ) ; label . set Color ( paint ) ; label . set Font ( font ) ; Dimension NUM D size Label = label . get Preferred Size ( ) ; double anchor X = NUM ; double anchor Y = NUM ; if ( location = = Location . NORTH | | location = = Location . SOUTH ) { anchor X = dir X * size Label . get Width ( ) / NUM ; anchor Y = dir Y * size Label . get Height ( ) / NUM ; if ( location = = Location . SOUTH ) { anchor X = - anchor X ; anchor Y = - anchor Y ; } } double x = label Pos V * dir X + anchor X - size Label . get Width ( ) / NUM ; double y = label Pos V * dir Y + anchor Y - size Label . get Height ( ) / NUM ; double w = size Label . get Width ( ) ; double h = size Label . get Height ( ) ; label . set Bounds ( x , y , w , h ) ; label . draw ( context ) ; }",
    "label": 1
  },
  {
    "text_1": "create a new signal barrier without an owner .",
    "text_2": "public Signal Barrier ( ) { owner = null ; }",
    "label": 1
  },
  {
    "text_1": "4 - integer version of kar at z ub a multiplication .",
    "text_2": "private static int [ ] mult NUM ( int [ ] a , int [ ] b ) { int [ ] result = new int [ NUM ] ; int [ ] a0 = new int [ NUM ] ; System . arraycopy ( a , NUM , a0 , NUM , Math . min ( NUM , a . length ) ) ; int [ ] a1 = new int [ NUM ] ; if ( a . length > NUM ) { System . arraycopy ( a , NUM , a1 , NUM , Math . min ( NUM , a . length - NUM ) ) ; } int [ ] b0 = new int [ NUM ] ; System . arraycopy ( b , NUM , b0 , NUM , Math . min ( NUM , b . length ) ) ; int [ ] b1 = new int [ NUM ] ; if ( b . length > NUM ) { System . arraycopy ( b , NUM , b1 , NUM , Math . min ( NUM , b . length - NUM ) ) ; } if ( a1 [ NUM ] = = NUM & & b1 [ NUM ] = = NUM ) { if ( a1 [ NUM ] ! = NUM | | b1 [ NUM ] ! = NUM ) { int [ ] c = mult NUM ( a1 [ NUM ] , b1 [ NUM ] ) ; result [ NUM ] ^ = c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ; } } else { int [ ] c = mult NUM ( a1 , b1 ) ; result [ NUM ] ^ = c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ^ c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ^ c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ; result [ NUM ] ^ = c [ NUM ] ; } a1 [ NUM ] ^ = a0 [ NUM ] ; a1 [ NUM ] ^ = a0 [ NUM ] ; b1 [ NUM ] ^ = b0 [ NUM ] ; b1 [ NUM ] ^ = b0 [ NUM ] ; if ( a1 [ NUM ] = = NUM & & b1 [ NUM ] = = NUM ) { int [ ] d = mult NUM ( a1 [ NUM ] , b1 [ NUM ] ) ; result [ NUM ] ^ = d [ NUM ] ; result [ NUM ] ^ = d [ NUM ] ; } else { int [ ] d = mult NUM ( a1 , b1 ) ; result [ NUM ] ^ = d [ NUM ] ; result [ NUM ] ^ = d [ NUM ] ; result [ NUM ] ^ = d [ NUM ] ; result [ NUM ] ^ = d [ NUM ] ; } if ( a0 [ NUM ] = = NUM & & b0 [ NUM ] = = NUM ) { int [ ] e = mult NUM ( a0 [ NUM ] , b0 [ NUM ] ) ; result [ NUM ] ^ = e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ; } else { int [ ] e = mult NUM ( a0 , b0 ) ; result [ NUM ] ^ = e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ^ e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ^ e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ; result [ NUM ] ^ = e [ NUM ] ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "specifies a single uppercase alphanumeric character from the set a - z , 0 - 9 .",
    "text_2": "public Builder label ( char label ) { this . label = Character . to Upper Case ( label ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "adds a table sort key . the table will be sorted according to the provided string comparator .",
    "text_2": "public void add Sort Key ( int column , Comparator < String > comparator ) { sort Keys . add ( column ) ; sort Comparators . add ( comparator ) ; }",
    "label": 1
  },
  {
    "text_1": "generate a sha 1 sum digest for a file . exposed for unit testing .",
    "text_2": "String generate Digest ( File file Dir , String file Name ) { final String algorithm = STRING ; Input Stream file Stream = null ; Digest Input Stream d = null ; try { file Stream = get File Stream ( file Dir , file Name ) ; Message Digest md = Message Digest . get Instance ( algorithm ) ; d = new Digest Input Stream ( file Stream , md ) ; byte [ ] buffer = new byte [ NUM ] ; while ( d . read ( buffer ) ! = - NUM ) { } return to Hex String ( md . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { return algorithm + STRING ; } catch ( IO Exception e ) { C Log . e ( e ) ; } finally { Stream Util . close Stream ( d ) ; Stream Util . close Stream ( file Stream ) ; } return STRING ; }",
    "label": 1
  },
  {
    "text_1": "converts a string into its java - style utf - 8 form . java - style utf - 8 differs from normal utf - 8 in the handling of character ' \\ 0 ' and surrogate pairs .",
    "text_2": "public static byte [ ] string To Utf NUM Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len * NUM ] ; int out At = NUM ; for ( int i = NUM ; i < len ; i + + ) { char c = string . char At ( i ) ; if ( ( c ! = NUM ) & & ( c < NUM ) ) { bytes [ out At ] = ( byte ) c ; out At + + ; } else if ( c < NUM ) { bytes [ out At ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( c & NUM ) | NUM ) ; out At + = NUM ; } else { bytes [ out At ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( c & NUM ) | NUM ) ; out At + = NUM ; } } byte [ ] result = new byte [ out At ] ; System . arraycopy ( bytes , NUM , result , NUM , out At ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "polls the solr core stats using the specified client until the \" starttime \" time for collection is after the specified \" min \" . will loop for at most \" timeout \" milliseconds before throwing an assertion failure .",
    "text_2": "private Date watch Core Start At ( Solr Server client , final long timeout , final Date min ) throws Interrupted Exception , IO Exception , Solr Server Exception { final long sleep Interval = NUM ; long time Sle pt = NUM ; Solr Params p = params ( STRING , STRING , STRING , STRING ) ; while ( time Sle pt < timeout ) { Query Request req = new Query Request ( p ) ; req . set Path ( STRING ) ; try { Named List data = client . request ( req ) ; for ( String k : new String [ ] { STRING , STRING } ) { Object o = data . get ( k ) ; assert Not Null ( STRING + k , o ) ; data = ( Named List ) o ; } Date start Time = ( Date ) data . get ( STRING ) ; assert Not Null ( STRING , start Time ) ; if ( null = = min | | start Time . after ( min ) ) { return start Time ; } } catch ( Solr Exception e ) { if ( NUM ! = e . code ( ) ) { throw e ; } } time Sle pt + = sleep Interval ; Thread . sleep ( sleep Interval ) ; } fail ( STRING + min ) ; return min ; }",
    "label": 1
  },
  {
    "text_1": "compute usages based upon the table .",
    "text_2": "private void calculate Slot Usage ( ) { num Entries = NUM ; for ( int i = NUM ; i < table . table . length ; i + + ) { Linked List < V > list = ( Linked List < V > ) table . table [ i ] ; if ( list ! = null ) { num Entries + = list . size ( ) ; int Hash Table [ i ] + = list . size ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "copies the state of the given frame into this frame .",
    "text_2": "public Frame < V > init ( final Frame < ? extends V > src ) { return Value = src . return Value ; System . arraycopy ( src . values , NUM , values , NUM , values . length ) ; top = src . top ; return this ; }",
    "label": 1
  },
  {
    "text_1": "sets a list of large message files into the replication manager for synchronization . collects a list of existing large messages and their current size , passing re . so we know how much of a given message to sync with the backup . further data appends to the messages will be replicated normally .",
    "text_2": "private Map < Long , Pair < String , Long > > recover Pending Large Messages ( ) throws Exception { Map < Long , Pair < String , Long > > large Messages = new Hash Map < > ( ) ; List < String > filenames = large Messages Factory . list Files ( STRING ) ; List < Long > id List = new Array List < > ( ) ; for ( String filename : filenames ) { Long id = get Large Message Id From Filename ( filename ) ; if ( ! large Messages To Delete . contains ( id ) ) { id List . add ( id ) ; Sequential File seq File = large Messages Factory . create Sequential File ( filename ) ; long size = seq File . size ( ) ; large Messages . put ( id , new Pair < > ( filename , size ) ) ; } } return large Messages ; }",
    "label": 1
  },
  {
    "text_1": "activates a watchdog watching over a registration . if lookup fails , will issue a process termination .",
    "text_2": "public void monitor ( String key ) { Timer t = new Timer ( BOOL ) ; t . schedule ( new Watchable Registration ( key ) , NUM * NUM , NUM * NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "before the websocket is used , it ' s recommended to call this method to ensure that any exceptions caught while processing the messages received are acknowledged .",
    "text_2": "public void assert Usable ( ) throws IO Exception { if ( throwable . get ( ) = = null ) { if ( connection = = null ) { throw new IO Exception ( STRING ) ; } return ; } Throwable t = throwable . get ( ) ; if ( t instanceof IO Exception ) { throw ( IO Exception ) t ; } else { throw Throwables . propagate ( t ) ; } }",
    "label": 1
  },
  {
    "text_1": "close all existing windows .",
    "text_2": "public final synchronized void close All ( ) { if ( on Close All ( ) ) { Log . w ( TAG , STRING ) ; return ; } Linked List < Integer > ids = new Linked List < Integer > ( ) ; for ( int id : get Existing Ids ( ) ) { ids . add ( id ) ; } for ( int id : ids ) { close ( id ) ; } }",
    "label": 1
  },
  {
    "text_1": "add projec ted field : add field details ( name , type , getter and setter ) for field with given name in projec ted fields list",
    "text_2": "protected void add Projected Field ( String s ) { try { Field f = in Clazz . get Declared Field ( s ) ; Type Info t = new Type Info ( f . get Name ( ) , Class Utils . primitive To Wrapper ( f . get Type ( ) ) ) ; t . getter = Pojo Utils . create Getter ( in Clazz , t . name , t . type ) ; t . setter = Pojo Utils . create Setter ( projected Clazz , t . name , t . type ) ; projected Fields . add ( t ) ; } catch ( No Such Field Exception e ) { throw new Runtime Exception ( STRING + s + STRING + in Clazz , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "bor rows a register to use as a temp . used in the phi removal process . call return sp are registers ( ) when done .",
    "text_2": "public int borrow Spare Register ( int category ) { int result = spare Register Base + bor rowed Spare Registers ; bor rowed Spare Registers + = category ; register Count = Math . max ( register Count , result + category ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "perform the named request",
    "text_2": "@ Override public void perform Request ( String request ) { if ( request . compare To ( STRING ) = = NUM ) { stop ( ) ; } else { throw new Illegal Argument Exception ( request + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "generates a signed certificate and a private key .",
    "text_2": "public static Cert Chain Key Pair generate Signed ( String fqdn , X509 Certificate issuer Certificate , Private Key issuer Private Key ) { try { return generate Certificate And Sign ( fqdn , issuer Certificate , issuer Private Key , get Server Extensions ( issuer Certificate ) ) ; } catch ( Certificate Exception | Operator Creation Exception | No Such Algorithm Exception | IO Exception e ) { throw new Runtime Exception ( String . format ( STRING , e . get Message ( ) ) , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "output the sql type for a java long string .",
    "text_2": "protected static void append Long String Type ( String Builder sb ) { sb . append ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "produce a string from a number .",
    "text_2": "public static String number To String ( Number number ) throws JSON Exception { if ( number = = null ) { throw new JSON Exception ( STRING ) ; } test Validity ( number ) ; String string = number . to String ( ) ; if ( string . index Of ( STRING ) > NUM & & string . index Of ( STRING ) < NUM & & string . index Of ( STRING ) < NUM ) { while ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } if ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } } return string ; }",
    "label": 1
  },
  {
    "text_1": "prepares the data for volume tests .",
    "text_2": "private void prepare Volume Data ( ) throws Exception { prepare V Plex Volume Data ( ) ; prepare RP Volume Data ( ) ; }",
    "label": 1
  },
  {
    "text_1": "a variant test in there is a blank node in the bindings to be flow ed through to the remote service . in this test the blank nodes are not correlated so we do not need to impose a filter on the remote service .",
    "text_2": "public void test service NUM ( ) throws Exception { final Bigdata URI service URI = value Factory . create URI ( STRING ) ; final Graph Pattern Group < I Group Member Node > group Node = new Join Group Node ( ) ; { group Node . add Child ( new Statement Pattern Node ( new Var Node ( STRING ) , new Var Node ( STRING ) , new Var Node ( STRING ) ) ) ; } final String expr Image = STRING + service URI + STRING ; final Map < String , String > prefix Decls = new Linked Hash Map < String , String > ( Prefix Decl Processor . default Decls ) ; final Service Node service Node = new Service Node ( new Constant Node ( make IV ( service URI ) ) , group Node ) ; { final Set < I Variable < ? > > projected Vars = new Linked Hash Set < I Variable < ? > > ( ) ; { projected Vars . add ( Var . var ( STRING ) ) ; projected Vars . add ( Var . var ( STRING ) ) ; projected Vars . add ( Var . var ( STRING ) ) ; } service Node . set Expr Image ( expr Image ) ; service Node . set Prefix Decls ( prefix Decls ) ; service Node . set Projected Vars ( projected Vars ) ; } final List < Binding Set > binding Sets = new Linked List < Binding Set > ( ) ; { final Map Binding Set bset = new Map Binding Set ( ) ; bset . add Binding ( STRING , new B Node Impl ( STRING ) ) ; binding Sets . add ( bset ) ; } final Binding Set [ ] a = binding Sets . to Array ( new Binding Set [ binding Sets . size ( ) ] ) ; final I Remote Sparql Query Builder fixture = new Fixture ( service Node , a ) ; final String query Str = fixture . get Sparql Query ( a ) ; final Query Root expected = new Query Root ( Query Type . SELECT ) ; { expected . set Prefix Decls ( prefix Decls ) ; final Projection Node projection = new Projection Node ( ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; expected . set Projection ( projection ) ; final Join Group Node where Clause = new Join Group Node ( ) ; where Clause . add Child ( new Statement Pattern Node ( new Var Node ( STRING ) , new Var Node ( STRING ) , new Var Node ( STRING ) , null , Scope . DEFAULT CONTEXTS ) ) ; expected . set Where Clause ( where Clause ) ; { final Linked Hash Set < I Variable < ? > > vars = new Linked Hash Set < I Variable < ? > > ( ) ; final List < I Binding Set > solutions In = new Linked List < I Binding Set > ( ) ; final Bindings Clause bindings Clause = new Bindings Clause ( vars , solutions In ) ; expected . set Bindings Clause ( bindings Clause ) ; { vars . add ( Var . var ( STRING ) ) ; } { final List Binding Set bset = new List Binding Set ( ) ; solutions In . add ( bset ) ; } } } final Query Root actual = parse ( query Str , base URI ) ; assert Same AST ( query Str , expected , actual ) ; }",
    "label": 1
  },
  {
    "text_1": "then combine result completes exceptionally if either source cancelled",
    "text_2": "public void test Then Combine source Cancelled ( ) throws Throwable { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean may Interrupt If Running : new boolean [ ] { BOOL , BOOL } ) for ( boolean f First : new boolean [ ] { BOOL , BOOL } ) for ( boolean fail First : new boolean [ ] { BOOL , BOOL } ) for ( Integer v NUM : new Integer [ ] { NUM , null } ) { final Completable Future < Integer > f = new Completable Future < > ( ) ; final Completable Future < Integer > g = new Completable Future < > ( ) ; final Subtract Function r NUM = new Subtract Function ( m ) ; final Subtract Function r NUM = new Subtract Function ( m ) ; final Subtract Function r3 = new Subtract Function ( m ) ; final Completable Future < Integer > fst = f First ? f : g ; final Completable Future < Integer > snd = ! f First ? f : g ; final Callable < Boolean > complete NUM = fail First ? null : null ; final Callable < Boolean > complete NUM = fail First ? null : null ; final Completable Future < Integer > h NUM = m . then Combine ( f , g , r NUM ) ; assert True ( complete NUM . call ( ) ) ; final Completable Future < Integer > h NUM = m . then Combine ( f , g , r NUM ) ; check Incomplete ( h NUM ) ; check Incomplete ( h NUM ) ; assert True ( complete NUM . call ( ) ) ; final Completable Future < Integer > h3 = m . then Combine ( f , g , r3 ) ; check Completed With Wrapped Cancellation Exception ( h NUM ) ; check Completed With Wrapped Cancellation Exception ( h NUM ) ; check Completed With Wrapped Cancellation Exception ( h3 ) ; r NUM . assert Not Invoked ( ) ; r NUM . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v NUM ) ; check Cancelled ( fail First ? fst : snd ) ; } }",
    "label": 1
  },
  {
    "text_1": "loads and links the library specified by the argument .",
    "text_2": "public void load Library ( String lib Name ) { load Library NUM ( lib Name , RVM Class . get Class Loader From Stack Frame ( NUM ) , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "generates 64 bit hash from a string .",
    "text_2": "public static long hash NUM ( final String text ) { final byte [ ] bytes = text . get Bytes ( ) ; return hash NUM ( bytes , bytes . length ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the float conversion of the most negative ( i . e . closest to negative infinity ) integer value which is greater than the argument .",
    "text_2": "@ Lay outl ib Delegate static float ceil ( float value ) { return ( float ) Math . ceil ( value ) ; }",
    "label": 1
  },
  {
    "text_1": "determines whether all nodes for which the menu is built are unloaded .",
    "text_2": "private boolean can Open ( ) { for ( final I Navi Project project : m projects ) { if ( project . is Loaded ( ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "creates the g map s fx model polyline",
    "text_2": "public void create Underlying ( ) { if ( options ! = null ) { options . create Underlying ( ) ; if ( Platform . is Fx Application Thread ( ) ) { line = new com . ly n den . g map sfx . shapes . Polyline ( options . convert ( ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "creates a an alive timer for the equipment .",
    "text_2": "public static Control Tag Cache Object create Test Equipment Alive ( ) { Control Tag Cache Object cache Object = new Control Tag Cache Object ( new Long ( NUM ) , STRING , STRING , Data Tag Constants . MODE TEST ) ; cache Object . set Description ( STRING ) ; cache Object . set Logged ( BOOL ) ; cache Object . set Unit ( STRING ) ; cache Object . set Dip Address ( STRING ) ; cache Object . set J ap c Address ( STRING ) ; cache Object . set Value ( new Long ( System . current Time Millis ( ) ) ) ; cache Object . set Value Description ( STRING ) ; cache Object . set Simulated ( BOOL ) ; cache Object . set Min Value ( Long . MIN VALUE ) ; cache Object . set Max Value ( Long . MAX VALUE ) ; cache Object . set Value Dictionary ( new Data Tag Value Dictionary ( ) ) ; cache Object . set Address ( new Data Tag Address ( ) ) ; cache Object . set Data Tag Quality ( create Valid Quality ( ) ) ; cache Object . set Cache Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; cache Object . set Daq Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; cache Object . set Source Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; return cache Object ; }",
    "label": 1
  },
  {
    "text_1": "method currently used by on get defaultvalue method to convert hex string provided in android : defaultvalue to color integer .",
    "text_2": "public static String convert To RGB ( int color ) { String red = Integer . to Hex String ( Color . red ( color ) ) ; String green = Integer . to Hex String ( Color . green ( color ) ) ; String blue = Integer . to Hex String ( Color . blue ( color ) ) ; if ( red . length ( ) = = NUM ) { red = STRING + red ; } if ( green . length ( ) = = NUM ) { green = STRING + green ; } if ( blue . length ( ) = = NUM ) { blue = STRING + blue ; } return STRING + red + green + blue ; }",
    "label": 1
  },
  {
    "text_1": "removes the connection manager from this class . the idle connections from the connection manager will no longer be automatically closed by this class .",
    "text_2": "public synchronized void remove Connection Manager ( final Http Connection Manager connection Manager ) { if ( shutdown ) { throw new Illegal State Exception ( STRING ) ; } connection Managers . remove ( connection Manager ) ; }",
    "label": 1
  },
  {
    "text_1": "enable or disable the upper and lower bounds fields depending on state of rounding button .",
    "text_2": "public void check Bounds ( ) { tf Low Bound . set Enabled ( ts Clipping . is Selected ( ) ) ; tf Up Bound . set Enabled ( ts Clipping . is Selected ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "the count of pad stacks from this . pad stacks , which can be used in routing",
    "text_2": "public int via padstack count ( ) { return via pad stacks . size ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds all the given service definitions to the zookeeper tree",
    "text_2": "public void add Services ( List < Service Definition > services ) throws Exception { ensure Path Exists ( ) ; Set < String > remaining Descriptors = new Hash Set < > ( data Manager . get Children ( ZK SERVICE DEFINITION PATH ) ) ; for ( Service Definition service : services ) { LOG . debug ( String . format ( STRING , service . service Id ) ) ; String path = get Service Definition Path ( service . service Id ) ; try { Stat before = data Manager . check Exists ( path ) ; data Manager . put Data ( path , service ) ; Stat after = data Manager . check Exists ( path ) ; node Updated ( path , before , after ) ; remaining Descriptors . remove ( service . service Id ) ; } catch ( Exception e ) { LOG . error ( String . format ( STRING , service . service Id , path ) , e ) ; throw e ; } } for ( String descriptor Name : remaining Descriptors ) { LOG . info ( String . format ( STRING , descriptor Name ) ) ; data Manager . remove Node ( ZK SERVICE DEFINITION PATH + STRING + descriptor Name ) ; } }",
    "label": 1
  },
  {
    "text_1": "solr zk client does not guarantee that a watch object will only be triggered once for a given notification if we does not wrap the watcher - see solr - 66 21 .",
    "text_2": "private Watcher init Watcher ( Solr Zk Client zk Client ) { wrapped Watcher = new Buffer State Watcher ( ) ; return zk Client . wrap Watcher ( wrapped Watcher ) ; }",
    "label": 1
  },
  {
    "text_1": "runs the test case .",
    "text_2": "public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Element test Employee ; Node first C ; String child Name ; int node Type ; Character Data employee ID Node ; String employee ID ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; test Employee = ( Element ) element List . item ( NUM ) ; first C = test Employee . get First Child ( ) ; node Type = ( int ) first C . get Node Type ( ) ; while ( equals ( NUM , node Type ) ) { first C = first C . get Next Sibling ( ) ; node Type = ( int ) first C . get Node Type ( ) ; } child Name = first C . get Node Name ( ) ; assert Equals Auto Case ( STRING , STRING , STRING , child Name ) ; employee ID Node = ( Character Data ) first C . get First Child ( ) ; employee ID = employee ID Node . get Node Value ( ) ; assert Equals ( STRING , STRING , employee ID ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a ctclass object representing the specified class . it first examines whether or not the corresponding class file exists . if yes , it creates a ctclass object .",
    "text_2": "protected Ct Class create Ct Class ( String classname , boolean use Cache ) { if ( classname . char At ( NUM ) = = STRING ) classname = Descriptor . to Class Name ( classname ) ; if ( classname . ends With ( STRING ) ) { String base = classname . substring ( NUM , classname . index Of ( STRING ) ) ; if ( ( ! use Cache | | get Cached ( base ) = = null ) & & find ( base ) = = null ) return null ; else return new Ct Array ( classname , this ) ; } else if ( find ( classname ) = = null ) return null ; else return new Ct Class Type ( classname , this ) ; }",
    "label": 1
  },
  {
    "text_1": "add dat echangelistener , this adds a date change listener to this date picker . for additional details , see the dat echangelistener class documentation .",
    "text_2": "public void add Date Change Listener ( Date Change Listener listener ) { date Change Listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "save the utilization history to a file .",
    "text_2": "public void save History ( String filename ) throws Exception { File Output Stream fos = new File Output Stream ( filename ) ; Object Output Stream oos = new Object Output Stream ( fos ) ; oos . write Object ( get History ( ) ) ; oos . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "remove all the payment methods based on the payment metho dids",
    "text_2": "public void clear Payment Methods By Id ( List < String > payment Method Ids To Remove ) { if ( Util Validate . is Empty ( payment Method Ids To Remove ) ) return ; for ( Iterator < Cart Payment Info > iter = payment Info . iterator ( ) ; iter . has Next ( ) ; ) { Cart Payment Info info = iter . next ( ) ; if ( payment Method Ids To Remove . contains ( info . payment Method Id ) ) { iter . remove ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "sets the ssl key store password .",
    "text_2": "public Builder with Key Store Password ( String trust Store Password ) { properties . set Property ( Netty Options . SSL KEY STORE PASSWORD , Assert . not Null ( trust Store Password , STRING ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "adds a class and all of the types it exposes . the cause of the class being exposed is given , and the cause of everything within the class is that class itself .",
    "text_2": "private void add Exposed Types ( Class < ? > clazz , Class < ? > cause ) { if ( pruned ( clazz ) ) { return ; } boolean already Done = done ( clazz ) ; visit ( clazz ) ; record Exposure ( clazz , cause ) ; if ( already Done | | pruned ( clazz ) ) { return ; } Type Token < ? > token = Type Token . of ( clazz ) ; for ( Type Token < ? > super Type : token . get Types ( ) ) { if ( ! super Type . equals ( token ) ) { logger . debug ( STRING , super Type , clazz ) ; add Exposed Types ( super Type , clazz ) ; } } for ( Class inner Class : clazz . get Declared Classes ( ) ) { if ( exposed ( inner Class . get Modifiers ( ) ) ) { logger . debug ( STRING , inner Class , clazz ) ; add Exposed Types ( inner Class , clazz ) ; } } for ( Field field : clazz . get Declared Fields ( ) ) { if ( exposed ( field . get Modifiers ( ) ) ) { logger . debug ( STRING , field , clazz ) ; add Exposed Types ( field , clazz ) ; } } for ( Invokable invokable : get Exposed Invok ables ( token ) ) { logger . debug ( STRING , invokable , clazz ) ; add Exposed Types ( invokable , clazz ) ; } }",
    "label": 1
  },
  {
    "text_1": "abort a data send to a matching target",
    "text_2": "@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM ) public int sce Net Adhoc Matching Abort Send Data ( @ Check Argument ( STRING ) int matching Id , psp Net Mac Address mac Address ) { return NUM ; }",
    "label": 1
  },
  {
    "text_1": "where there are multiple indices , and we have an order by , select the index that already has the required ordering .",
    "text_2": "private void test Ordered Indexes ( ) throws SQL Exception { delete Db ( STRING ) ; Connection conn = get Connection ( STRING ) ; Statement stat = conn . create Statement ( ) ; stat . execute ( STRING + STRING ) ; stat . execute ( STRING ) ; Result Set rs = stat . execute Query ( STRING + STRING ) ; rs . next ( ) ; assert Contains ( rs . get String ( NUM ) , STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; rs = stat . execute Query ( STRING + STRING ) ; rs . next ( ) ; assert Contains ( rs . get String ( NUM ) , STRING ) ; conn . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "creates an array list and fills it with elements of this list . used by toarray .",
    "text_2": "private Array List < E > to Array List ( ) { Array List < E > list = new Array List < E > ( ) ; for ( Node < E > p = first ( ) ; p ! = null ; p = succ ( p ) ) { E item = p . item ; if ( item ! = null ) list . add ( item ) ; } return list ; }",
    "label": 1
  },
  {
    "text_1": "this is the method that should be implemented by specific filtered match dao impl ' s to persist filtered matches .",
    "text_2": "@ Override @ Transactional protected void persist ( Collection < Raw Protein < Prints Raw Match > > filtered Proteins , Map < String , Signature > model Id To Signature Map , Map < String , Protein > protein Id To Protein Map ) { for ( Raw Protein < Prints Raw Match > raw Protein : filtered Proteins ) { Protein protein = protein Id To Protein Map . get ( raw Protein . get Protein Identifier ( ) ) ; if ( protein = = null ) { throw new Illegal State Exception ( STRING + STRING + raw Protein . get Protein Identifier ( ) + STRING ) ; } Set < Finger Prints Match . Finger Prints Location > locations = null ; String current Signature Ac = null ; Signature current Signature = null ; Prints Raw Match last Raw Match = null ; final Tree Set < Prints Raw Match > sorted Matches = new Tree Set < Prints Raw Match > ( PRIN TS RAW MATCH COMPARATOR ) ; sorted Matches . add All ( raw Protein . get Matches ( ) ) ; Finger Prints Match match = null ; for ( Prints Raw Match raw Match : sorted Matches ) { if ( raw Match = = null ) { continue ; } if ( current Signature Ac = = null | | ! current Signature Ac . equals ( raw Match . get Model Id ( ) ) ) { if ( current Signature Ac ! = null ) { if ( match ! = null ) { entity Manager . persist ( match ) ; } match = new Finger Prints Match ( current Signature , last Raw Match . get Evalue ( ) , last Raw Match . get Graph scan ( ) , locations ) ; protein . add Match ( match ) ; } locations = new Hash Set < Finger Prints Match . Finger Prints Location > ( ) ; current Signature Ac = raw Match . get Model Id ( ) ; current Signature = model Id To Signature Map . get ( current Signature Ac ) ; if ( current Signature = = null ) { throw new Illegal State Exception ( STRING + current Signature Ac + STRING ) ; } } locations . add ( new Finger Prints Match . Finger Prints Location ( raw Match . get Location Start ( ) , bounded Location End ( protein , raw Match ) , raw Match . get Pvalue ( ) , raw Match . get Score ( ) , raw Match . get Motif Number ( ) ) ) ; last Raw Match = raw Match ; } if ( last Raw Match ! = null ) { match = new Finger Prints Match ( current Signature , last Raw Match . get Evalue ( ) , last Raw Match . get Graph scan ( ) , locations ) ; protein . add Match ( match ) ; entity Manager . persist ( match ) ; } } }",
    "label": 1
  },
  {
    "text_1": "checks if the window is empty .",
    "text_2": "boolean is Single Window Standard Offset ( ) { return window End . equals ( Local Date Time . MAX ) & & time Definition = = Time Definition . WALL & & fixed Saving Amount Secs = = null & & last Rule List . is Empty ( ) & & rule List . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "true if inserted ; false if was already in table can not insert a variable of name x if there is a global with name x or another variable in the same context with name x . /",
    "text_2": "public boolean Insert Sym ( int type , String id , String context , String c Type , int line , int col ) { int i ; if ( type = = PROCE DUR EVAR | | type = = PROCES SV AR | | type = = PARAMETER ) { i = Find Sym ( GLOBAL , id , STRING ) ; if ( i < symtab . size ( ) ) return BOOL ; i = Find Sym ( id , context ) ; if ( i < symtab . size ( ) ) return BOOL ; } else { i = Find Sym ( type , id , context ) ; if ( i < symtab . size ( ) ) return BOOL ; } Sym Tab Entry se = new Sym Tab Entry ( type , id , context , c Type , line , col ) ; symtab . add Element ( se ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "adds a map object to this map layer .",
    "text_2": "public void add Map Object ( Internal Map Object map Object ) { map Objects . add ( map Object ) ; }",
    "label": 1
  },
  {
    "text_1": "appends names of the specified array classes to the buffer . the array elements may represent a simple type , a reference type or an array type . output format : java . lang . object [ ] , java . io . file , void",
    "text_2": "void append Array Generic Type ( String Builder sb , Type [ ] types ) { if ( types . length > NUM ) { append Generic Type ( sb , types [ NUM ] ) ; for ( int i = NUM ; i < types . length ; i + + ) { sb . append ( STRING ) ; append Generic Type ( sb , types [ i ] ) ; } } }",
    "label": 1
  },
  {
    "text_1": "pauses the spider crawling .",
    "text_2": "public void pause ( ) { pause Lock . lock ( ) ; try { paused = BOOL ; } finally { pause Lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a listener to the set of listeners that are sent update events through the life of an animation . this method is called on all listeners for every frame of the animation , after the values for the animation have been calculated .",
    "text_2": "public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners = = null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "given a post operation and a file , post the file to the uri .",
    "text_2": "public static void put File ( Service Client h , final Operation put , File f ) throws IO Exception { final Asynchronous File Channel ch = Asynchronous File Channel . open ( f . to Path ( ) , Standard Open Option . READ ) ; Atomic Integer completion Count = new Atomic Integer ( NUM ) ; String content Type = File Utils . get Content Type ( f . to URI ( ) ) ; final boolean [ ] file Is Done = { BOOL } ; put Chunks ( h , put , ch , content Type , f . length ( ) , NUM , completion Count , file Is Done ) ; }",
    "label": 1
  },
  {
    "text_1": "split a text into a list of strings . reduce the texts to a string of hashes where each unicode character represents one word .",
    "text_2": "private String diff words To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { String pattern Str = STRING ; Pattern pattern = Pattern . compile ( pattern Str ) ; Matcher matcher = pattern . matcher ( text ) ; matcher . region ( line Start , text . length ( ) ) ; if ( matcher . find ( ) ) { line End = matcher . start ( ) ; } else line End = - NUM ; if ( line End = = - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "performs a check whether this setup is valid .",
    "text_2": "public boolean check ( ) { return ( m File ! = null ) & & ( m Handler ! = null ) & & m File . exists ( ) ; }",
    "label": 1
  },
  {
    "text_1": "logical and of a and b",
    "text_2": "private Set < Storage Port > and Storage Port Sets ( Set < Storage Port > a , Set < Storage Port > b ) { Set < Storage Port > result = new Hash Set < Storage Port > ( ) ; for ( Storage Port port : a ) { if ( b . contains ( port ) ) { result . add ( port ) ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "canonicalize the given return or param type . return null if the type is already canonicalized .",
    "text_2": "static Class < ? > canonicalize ( Class < ? > t , int how ) { Class < ? > ct ; if ( t = = Object . class ) { } else if ( ! t . is Primitive ( ) ) { switch ( how ) { case UNWRAP : ct = Wrapper . as Primitive Type ( t ) ; if ( ct ! = t ) return ct ; break ; case RAW RETURN : case ERASE : return Object . class ; } } else if ( t = = void . class ) { switch ( how ) { case RAW RETURN : return int . class ; case WRAP : return Void . class ; } } else { switch ( how ) { case WRAP : return Wrapper . as Wrapper Type ( t ) ; case INTS : if ( t = = int . class | | t = = long . class ) return null ; if ( t = = double . class ) return long . class ; return int . class ; case LONGS : if ( t = = long . class ) return null ; return long . class ; case RAW RETURN : if ( t = = int . class | | t = = long . class | | t = = float . class | | t = = double . class ) return null ; return int . class ; } } return null ; }",
    "label": 1
  },
  {
    "text_1": "removes previously added no - op handler for root java logger .",
    "text_2": "public static void remove Java No Op Logger ( Collection < Handler > rmv H nds ) { Logger log = Logger . get Logger ( STRING ) ; for ( Handler h : log . get Handlers ( ) ) log . remove Handler ( h ) ; if ( ! F . is Empty ( rmv H nds ) ) { for ( Handler h : rmv H nds ) log . add Handler ( h ) ; } }",
    "label": 1
  },
  {
    "text_1": "disables pan te th ering on the local device and checks to make sure that te th ering is disabled .",
    "text_2": "public void disable Pan ( Bluetooth Adapter adapter ) { if ( m Pan = = null ) m Pan = ( Bluetooth Pan ) connect Proxy ( adapter , Bluetooth Profile . PAN ) ; assert Not Null ( m Pan ) ; long start = System . current Time Millis ( ) ; m Pan . set Bluetooth T eth ering ( BOOL ) ; long stop = System . current Time Millis ( ) ; assert False ( m Pan . is T eth ering On ( ) ) ; write Output ( String . format ( STRING , ( stop - start ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "add to the consolidated result message which will be displayed in the notification on closing the window . each message that will be added in new line of previous messages using html",
    "text_2": "public void add To Consol it ated Msg ( final String message ) { if ( consolidated Message ! = null & & consolidated Message . length ( ) > NUM ) { consolidated Message = consolidated Message + STRING ; } consolidated Message = consolidated Message + message ; }",
    "label": 1
  },
  {
    "text_1": "records the upload entry to a log file similar to what is done in chrome / app / break pad linux . cc",
    "text_2": "private void append Uploaded Entry To Log ( String id ) throws IO Exception { File Writer writer = new File Writer ( m Logfile , BOOL ) ; String Builder sb = new String Builder ( ) ; sb . append ( System . current Time Millis ( ) / NUM ) ; sb . append ( STRING ) ; sb . append ( id ) ; sb . append ( STRING ) ; try { writer . write ( sb . to String ( ) ) ; } finally { writer . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "called when a downloading event is triggered",
    "text_2": "protected void on Downloading ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , messages . downloading Resources ( ) ) ; } updating = BOOL ; fire Application Cache Event ( Cache Event . on Downloading ) ; }",
    "label": 1
  },
  {
    "text_1": "reads in attributes of a configuration object .",
    "text_2": "public Map read ( SSO Token token , String obj Name ) throws SMS Exception , SSO Exception { if ( obj Name = = null | | obj Name . length ( ) = = NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String obj Key = obj Name . to Lower Case ( ) ; Map attr Map = null ; m RW Lock . read Request ( ) ; try { String filepath = m Name Map . get Property ( obj Key ) ; if ( filepath = = null ) { if ( m Debug . message Enabled ( ) ) { m Debug . message ( STRING + obj Name + STRING ) ; } } else { File filehandle = new File ( filepath ) ; Properties props = null ; try { props = load Properties ( filehandle , obj Name ) ; } catch ( Service Not Found Exception e ) { } if ( props ! = null ) { attr Map = new Case Insensitive Hash Map ( ) ; Enumeration keys = props . property Names ( ) ; while ( keys . has More Elements ( ) ) { String key = ( String ) keys . next Element ( ) ; String vals = props . get Property ( key ) ; if ( ( vals ! = null ) & & ( vals . length ( ) > NUM ) ) { attr Map . put ( key , to Val Set ( key , vals ) ) ; } } } } } finally { m RW Lock . read Done ( ) ; } return attr Map ; }",
    "label": 1
  },
  {
    "text_1": "determine if this message should be dropped for lat eness . live publish data does not come through this section , only outgoing data does . - determine latency between server and client using ping - ping timestamp is unsigned int ( 4 bytes ) and is set from value on sender 1st drop disposable frames - lowest mark 2nd drop inter frames - middle 3rd drop key frames - high mark",
    "text_2": "protected boolean drop Message ( RTMP rtmp , int channel Id , IR TMP Event message ) { boolean drop = BOOL ; if ( rtmp . get Mode ( ) = = RTMP . MODE SERVER ) { boolean is Video = BOOL ; if ( message instanceof Ping ) { final Ping ping Message = ( Ping ) message ; if ( ping Message . get Event Type ( ) = = Ping . STREAM PLAY BUFFER CLEAR ) { final int channel = ( NUM + ( ( ping Message . get Value NUM ( ) - NUM ) * NUM ) ) ; rtmp . set Last Timestamp Mapping ( channel , null ) ; rtmp . set Last Timestamp Mapping ( channel + NUM , null ) ; rtmp . set Last Timestamp Mapping ( channel + NUM , null ) ; } return BOOL ; } if ( ( is Video = message instanceof Video Data ) | | message instanceof Audio Data ) { if ( message . get Timestamp ( ) = = NUM ) { return BOOL ; } boolean is Live = message . get Source Type ( ) = = Constants . SOURCE TYPE LIVE ; long timestamp = ( message . get Timestamp ( ) & NUM ) ; Live Timestamp Mapping mapping = rtmp . get Last Timestamp Mapping ( channel Id ) ; long now = System . current Time Millis ( ) ; if ( mapping = = null | | timestamp < mapping . get Last Stream Time ( ) ) { log . debug ( STRING , now , timestamp ) ; mapping = new Live Timestamp Mapping ( now , timestamp ) ; rtmp . set Last Timestamp Mapping ( channel Id , mapping ) ; } mapping . set Last Stream Time ( timestamp ) ; long clock Time Of Message = mapping . get Clock Start Time ( ) + timestamp - mapping . get Stream Start Time ( ) ; long tar diness = clock Time Of Message - now ; if ( is Live & & drop Live Future ) { tar diness = Math . abs ( tar diness ) ; } I Connection conn = Red NUM . get Connection Local ( ) ; if ( conn ! = null ) { tar diness - = conn . get Last Ping Time ( ) ; } else { log . debug ( STRING ) ; } if ( tar diness < base Tolerance ) { } else if ( tar diness > highest Tolerance ) { log . debug ( STRING , message ) ; if ( is Video ) { mapping . set Key Frame Needed ( BOOL ) ; } drop = BOOL ; } else { if ( is Video ) { Video Data video = ( Video Data ) message ; if ( video . get Frame Type ( ) = = Frame Type . KEY FRAME ) { mapping . set Key Frame Needed ( BOOL ) ; } else if ( tar diness > = base Tolerance & & tar diness < mid Tolerance ) { if ( video . get Frame Type ( ) = = Frame Type . DISPO SABLE INTER FRAME ) { log . debug ( STRING , message ) ; drop = BOOL ; } } else if ( tar diness > = mid Tolerance & & tar diness < = highest Tolerance ) { log . debug ( STRING , message ) ; drop = BOOL ; } } } } log . debug ( STRING , drop ) ; } return drop ; }",
    "label": 1
  },
  {
    "text_1": "adds a new pan listener .",
    "text_2": "public synchronized void add Pan Listener ( Pan Listener listener ) { m Pan Listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "tests core validation process",
    "text_2": "public boolean verify ( ) throws Missing Resource Failure Exception , XML Security Exception { return super . verify References ( BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "executes an sql query",
    "text_2": "public Result Set execute Query ( String query ) throws SQL Exception , No Connection Exception { if ( connection ! = null ) { Statement st = connection . create Statement ( ) ; return st . execute Query ( query ) ; } throw new No Connection Exception ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true for empty .",
    "text_2": "public boolean is Empty ( ) { return array List . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "unregister an object , so it is no longer tracked .",
    "text_2": "public static void unregister ( Close Watcher w ) { w . closeable = null ; refs . remove ( w ) ; }",
    "label": 1
  },
  {
    "text_1": "extract the jacobian matrix with respect to state .",
    "text_2": "public double [ ] [ ] extract Main Set Jacobian ( final ODE State state ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] [ ] d Y d Y NUM = new double [ j ode . get Dimension ( ) ] [ j ode . get Dimension ( ) ] ; int j = NUM ; for ( int i = NUM ; i < j ode . get Dimension ( ) ; i + + ) { System . arraycopy ( p , j , d Y d Y NUM [ i ] , NUM , j ode . get Dimension ( ) ) ; j + = j ode . get Dimension ( ) ; } return d Y d Y NUM ; }",
    "label": 1
  },
  {
    "text_1": "attempts to cas - increment the worker count field of ctl .",
    "text_2": "private boolean compare And Increment Worker Count ( int expect ) { return ctl . compare And Set ( expect , expect + NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "ensure that , if double buffering is enabled , the offscreen image buffer exists and is the correct size .",
    "text_2": "protected void check Offscreen Image ( Dimension d ) { if ( double Buffered ) { if ( offscreen = = null | | offscreen . get Width ( ) ! = d . width | | offscreen . get Height ( ) ! = d . height ) { offscreen = new Buffered Image ( d . width , d . height , Buffered Image . TYPE INT ARGB ) ; offscreen G NUM d = offscreen . create Graphics ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "method to be invoked for firing audit event .",
    "text_2": "public void audit Operation ( String operation , List < ? extends Tagged Log API Entity > entities , List < String > encoded Row Keys , Entity Definition entity Definition ) { if ( is Auditing Required ( entity Definition . get Service ( ) ) ) { List < Generic Audit Entity > audit Entities = build Audit Entities ( operation , entities , encoded Row Keys , entity Definition ) ; if ( null ! = audit Entities & & NUM ! = audit Entities . size ( ) ) { audit Support . fire Audit ( entity Definition . get Service ( ) , audit Entities ) ; } } }",
    "label": 1
  },
  {
    "text_1": "load propertyeditor from cl z through reflection .",
    "text_2": "private Property Editor load Property Editor ( Class clz ) { Property Editor editor = null ; try { editor = ( Property Editor ) clz . new Instance ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return editor ; }",
    "label": 1
  },
  {
    "text_1": "convert this list to an array . the target array must be big enough .",
    "text_2": "public void to Array ( int [ ] array ) { System . arraycopy ( data , NUM , array , NUM , size ) ; }",
    "label": 1
  },
  {
    "text_1": "processes the next item on the sync list , or cleans up if it is finished .",
    "text_2": "private void next Sync ( ) { if ( sync Item Iterator . has Next ( ) ) { partial Start Time = System . current Time Millis ( ) ; current Sync Item = sync Item Iterator . next ( ) ; current Sync Item . sync ( this , host Connection , callback Handler , content Resolver ) ; } else { Log Utils . LOGD ( TAG , STRING + ( System . current Time Millis ( ) - start Time ) ) ; if ( listener ! = null ) { listener . on Sync Finished ( this ) ; } sync Service . stop Self ( service Start Id ) ; } }",
    "label": 1
  },
  {
    "text_1": "calculate matrix for fit center",
    "text_2": "private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null = = image View | | null = = d ) { return ; } final float view Width = image View . get Width ( ) ; final float view Height = image View . get Height ( ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type = = Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM , ( view Height - drawable Height ) / NUM ) ; } else if ( m Scale Type = = Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else if ( m Scale Type = = Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else { Rect F m Temp Src = new Rect F ( NUM , NUM , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM , NUM , view Width , view Height ) ; switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }",
    "label": 1
  },
  {
    "text_1": "calculate the requirements needed along the major axis . this is called by the superclass whenever the requirements need to be updated ( i . e . a preferen c echanged was messaged through this view ) . this is implemented to delegate to the superclass , but indicate the maximum size is very large ( i . e . the cell is willing to exp end to occupy the full height of the row ) .",
    "text_2": "protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }",
    "label": 1
  },
  {
    "text_1": "primitive implementation to decide if the object is a \" full \" or a partial .",
    "text_2": "private boolean has Non Special Attribute ( Collection < String > keys ) { for ( String attr : keys ) { if ( ! attr . starts With ( STRING ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "writes a spe ex header to the given byte array .",
    "text_2": "public static int write Spe ex Header ( byte [ ] buf , int offset , int sample Rate , int mode , int channels , boolean v br , int nframes , int packet length ) { write String ( buf , offset , STRING ) ; write String ( buf , offset + NUM , STRING ) ; System . arraycopy ( new byte [ NUM ] , NUM , buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , sample Rate ) ; write Int ( buf , offset + NUM , mode ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , channels ) ; write Int ( buf , offset + NUM , - NUM ) ; write Int ( buf , offset + NUM , NUM < < mode ) ; write Int ( buf , offset + NUM , v br ? NUM : NUM ) ; write Int ( buf , offset + NUM , nframes ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , packet length ) ; write Int ( buf , offset + NUM , NUM ) ; return NUM ; }",
    "label": 1
  },
  {
    "text_1": "prints a character to standard output and then terminates the line .",
    "text_2": "public static void println ( char x ) { out . println ( x ) ; }",
    "label": 1
  },
  {
    "text_1": "create and persist database entities required for testing .",
    "text_2": "public void create Database Entities For Business Object Data Notification Registration Testing ( String namespace , List < String > notification Event Types , String business Object Definition Namespace , String business Object Definition Name , List < String > file Types , List < String > storage Names , List < String > business Object Data Statuses , List < Job Action > job Actions ) { Namespace Entity namespace Entity = namespace Dao . get Namespace By Cd ( namespace ) ; if ( namespace Entity = = null ) { namespace Dao Test Helper . create Namespace Entity ( namespace ) ; } if ( ! Collection Utils . is Empty ( notification Event Types ) ) { for ( String notification Event Type : notification Event Types ) { Notification Event Type Entity notification Event Type Entity = notification Event Type Dao . get Notification Event Type By Code ( notification Event Type ) ; if ( notification Event Type Entity = = null ) { notification Registration Dao Test Helper . create Notification Event Type Entity ( notification Event Type ) ; } } } Business Object Definition Entity business Object Definition Entity = business Object Definition Dao . get Business Object Definition By Key ( new Business Object Definition Key ( business Object Definition Namespace , business Object Definition Name ) ) ; if ( business Object Definition Entity = = null ) { business Object Definition Dao Test Helper . create Business Object Definition Entity ( business Object Definition Namespace , business Object Definition Name , Abstract Service Test . DATA PROVIDER NAME , Abstract Service Test . B DEF DESCRIPTION ) ; } if ( ! Collection Utils . is Empty ( file Types ) ) { for ( String business Object Format File Type : file Types ) { file Type Dao Test Helper . create File Type Entity ( business Object Format File Type ) ; } } if ( ! Collection Utils . is Empty ( storage Names ) ) { for ( String storage Name : storage Names ) { storage Dao Test Helper . create Storage Entity ( storage Name , Storage Platform Entity . S3 ) ; } } if ( ! Collection Utils . is Empty ( business Object Data Statuses ) ) { for ( String business Object Data Status : business Object Data Statuses ) { Business Object Data Status Entity business Object Data Status Entity = business Object Data Status Dao . get Business Object Data Status By Code ( business Object Data Status ) ; if ( business Object Data Status Entity = = null ) { business Object Data Status Dao Test Helper . create Business Object Data Status Entity ( business Object Data Status ) ; } } } if ( ! Collection Utils . is Empty ( job Actions ) ) { for ( Job Action job Action : job Actions ) { job Definition Dao Test Helper . create Job Definition Entity ( job Action . get Namespace ( ) , job Action . get Job Name ( ) , String . format ( STRING , job Action . get Namespace ( ) , job Action . get Job Name ( ) ) , String . format ( STRING , job Action . get Namespace ( ) , job Action . get Job Name ( ) , Abstract Service Test . ACTIV IT I ID ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "return characters as an array of bytes in utf 8 representation .",
    "text_2": "public static byte [ ] chars NUM utf ( char [ ] src , int sindex , int len ) { byte [ ] dst = new byte [ len * NUM ] ; int len NUM = chars NUM utf ( src , sindex , dst , NUM , len ) ; byte [ ] result = new byte [ len NUM ] ; System . arraycopy ( dst , NUM , result , NUM , len NUM ) ; return result ; }",
    "label": 1
  },
  {
    "text_1": "formats the double array d with the default number format .",
    "text_2": "public static String Builder format To ( String Builder buf , double [ ] d , String sep ) { if ( d = = null ) { return buf . append ( STRING ) ; } if ( d . length = = NUM ) { return buf ; } buf . append ( d [ NUM ] ) ; for ( int i = NUM ; i < d . length ; i + + ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }",
    "label": 1
  },
  {
    "text_1": "can be overriden by subclasses to do additional work .",
    "text_2": "protected void on Network Type Change ( Network Info old Network , Network Info new Network ) throws Router Exception { log . info ( String . format ( STRING , old Network = = null ? STRING : old Network . get Type Name ( ) , new Network = = null ? STRING : new Network . get Type Name ( ) ) ) ; if ( disable ( ) ) { log . info ( String . format ( STRING , old Network = = null ? STRING : old Network . get Type Name ( ) ) ) ; } network Info = new Network ; if ( enable ( ) ) { log . info ( String . format ( STRING , new Network = = null ? STRING : new Network . get Type Name ( ) ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "return a string of all the information of this method object : line numbers , receiver and signature .",
    "text_2": "public String to Complete String ( ) { String ret = STRING ; if ( ! lines . is Empty ( ) & & ! Config . v ( ) . no Source Info ) { for ( Source Location Tag line : lines ) { ret + = STRING + line + STRING ; } } ret + = to Signature String ( ) ; return ret ; }",
    "label": 1
  },
  {
    "text_1": "converts a sit map into a human readable string",
    "text_2": "public static String SI T Info ( Enum Map < SI T , Enum Map < C IT , Boolean > > shp ) { String Builder result = new String Builder ( ) ; for ( SI T key : shp . key Set ( ) ) { result . append ( STRING + key . to String ( ) + STRING + C IT Info ( shp . get ( key ) ) + STRING ) ; } return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "global info for this bean",
    "text_2": "@ Override public String global Info ( ) { return STRING + STRING ; }",
    "label": 1
  },
  {
    "text_1": "helper for javascri p te scape and javascri p te scape to ascii",
    "text_2": "private static String java Script Escape Helper ( String s , boolean escape To Ascii ) { String Builder sb = new String Builder ( s . length ( ) * NUM / NUM ) ; for ( int i = NUM ; i < s . length ( ) ; i + + ) { char c = s . char At ( i ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : append Hex Java Script Representation ( sb , c ) ; break ; case STRING : case STRING : boolean is Unsafe = BOOL ; for ( String tag : UNSAFE TAGS ) { if ( s . region Matches ( BOOL , i + NUM , tag , NUM , tag . length ( ) ) ) { is Unsafe = BOOL ; break ; } } if ( is Unsafe ) { append Hex Java Script Representation ( sb , c ) ; } else { sb . append ( c ) ; } break ; case STRING : if ( sb . length ( ) > NUM & & sb . char At ( sb . length ( ) - NUM ) = = STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : if ( c > = NUM & & escape To Ascii ) { append Hex Java Script Representation ( sb , c ) ; } else { sb . append ( c ) ; } } } return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "check if we ' ve crossed a reasonable touch slop for the given child view . if the child cannot be dragged along the horizontal or vertical axis , motion along that axis will not count toward the slop check .",
    "text_2": "private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child = = null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal & & check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "management method for the wan dere r , that steps through the children of the directory and calls handle entry for them .",
    "text_2": "protected boolean handle Directory ( File directory , String [ ] content Names ) throws Security Exception { boolean continue W and ering = BOOL ; for ( String child : content Names ) { boolean keep Going = handle Entry ( new File ( directory . get Absolute Path ( ) + File . separator , child ) ) ; if ( ! keep Going ) { continue W and ering = exhau stive Search ; if ( ! continue W and ering ) { break ; } } } return continue W and ering ; }",
    "label": 1
  },
  {
    "text_1": "this function kills an application given the applicationid",
    "text_2": "public void kill Application ( String application Id ) throws IO Exception , Yarn Exception { log . info ( STRING + application Id ) ; yarn Client . kill Application ( get Application ID From String ( application Id ) ) ; }",
    "label": 1
  },
  {
    "text_1": "copies the content from one stream to another stream .",
    "text_2": "public static void copy Stream ( final Input Stream from Stream , final Output Stream to Stream ) throws IO Exception { byte [ ] buffer = new byte [ NUM ] ; int bytes Read ; while ( ( bytes Read = from Stream . read ( buffer ) ) ! = - NUM ) { to Stream . write ( buffer , NUM , bytes Read ) ; } }",
    "label": 1
  },
  {
    "text_1": "setbit ( int n ) of a negative n",
    "text_2": "public void test Set Bit Exception ( ) { byte a Bytes [ ] = { - NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; try { a Number . set Bit ( number ) ; fail ( STRING ) ; } catch ( Arithmetic Exception e ) { } }",
    "label": 1
  },
  {
    "text_1": "remove the indicated weave on next installation",
    "text_2": "public synchronized void un weave ( Byte String id ) { if ( wo ven . contains Key ( id ) ) { removed . add ( wo ven . remove ( id ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "construct a contour path or line using the given arrays of x & y values .",
    "text_2": "public Contour Path ( Contour Attrib attr , int level Index , double [ ] x , double [ ] y ) { x Arr = x ; y Arr = y ; this . level Index = level Index ; attributes = attr ; int np = x Arr . length ; if ( Math . abs ( x [ NUM ] - x [ np - NUM ] ) < k Small X & & Math . abs ( y [ NUM ] - y [ np - NUM ] ) < k Small Y ) { closed = BOOL ; x [ np - NUM ] = x [ NUM ] ; y [ np - NUM ] = y [ NUM ] ; } else closed = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "write a thread dump onto the http response as an aid to diagno se both node - local and distributed deadlocks . note : this code should not obtain any locks . this is necessary in order for the code to run even when the server is in a deadlock .",
    "text_2": "private static void do Thread Dump ( final Http Servlet Request req , final Http Servlet Response resp ) throws IO Exception { resp . set Status ( HTTP OK ) ; resp . add Header ( STRING , STRING ) ; resp . set Content Type ( MIME TEXT PLAIN ) ; final Print Writer w = resp . get Writer ( ) ; try { Bigdata Statics . thread Dump ( w ) ; w . flush ( ) ; } catch ( Throwable t ) { laun der Throwable ( t , resp , STRING ) ; } finally { w . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "fetches a chunk and filters ( if required ) .",
    "text_2": "private void fetch Chunk ( Bulk Id Param input , List < T > results ) { List < T > items = get Bulk Resources ( input ) ; for ( T item : items ) { results . add ( item ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a hash code value for the object .",
    "text_2": "@ Override public int hash Code ( ) { if ( hash = = NUM ) { int result = NUM ; result = NUM * result + range . hash Code ( ) ; long bits Weight = Double . double To Long Bits ( weight ) ; result = NUM * result + ( int ) ( bits Weight ^ ( bits Weight > > > NUM ) ) ; hash = result ; } return hash ; }",
    "label": 1
  },
  {
    "text_1": "un - hides the main menu and tries to clean up the client or server .",
    "text_2": "void un launch ( ) { if ( server ! = null ) { server . die ( ) ; server = null ; } frame . set Visible ( BOOL ) ; client = null ; System . gc ( ) ; System . run Finalization ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a simple renderer to the multiple renderer .",
    "text_2": "public void add Series Renderer ( Simple Series Renderer renderer ) { m Renderers . add ( renderer ) ; }",
    "label": 1
  },
  {
    "text_1": "convert qname to a string of the form < prefix > : < localpart >",
    "text_2": "public String q Name NUM String ( Q Name q Name , boolean write NS ) { String prefix = null ; String namespace URI = q Name . get Namespace ( ) ; String local Part = q Name . get Local Part ( ) ; if ( local Part ! = null & & local Part . length ( ) > NUM ) { int index = local Part . index Of ( STRING ) ; if ( index ! = - NUM ) { prefix = local Part . substring ( NUM , index ) ; if ( prefix . length ( ) > NUM & & ! prefix . equals ( STRING ) ) { register Prefix For URI ( prefix , namespace URI ) ; local Part = local Part . substring ( index + NUM ) ; } else { prefix = null ; } } local Part = get Last Local Part ( local Part ) ; } if ( namespace URI . length ( ) = = NUM ) { if ( write NS ) { String default NS = ns Stack . get Namespace URI ( STRING ) ; if ( default NS ! = null & & default NS . length ( ) > NUM ) { register Prefix For URI ( STRING , STRING ) ; } } } else { prefix = get Prefix For URI ( namespace URI , q Name . get Preferred Prefix ( ) ) ; } if ( ( prefix = = null ) | | ( prefix . length ( ) = = NUM ) ) return local Part ; return prefix + STRING + local Part ; }",
    "label": 1
  },
  {
    "text_1": "filters the target port list from the response based on the varray tagging .",
    "text_2": "private List < String > filter Targets From Response ( Set < String > varray Tagged Port WW Ns , Map < String , List < String > > initiator Target Map , String initiator Key ) { log . debug ( STRING ) ; List < String > filtered Target List = new Array List < String > ( ) ; List < String > target Port List From Response = initiator Target Map . get ( initiator Key ) ; for ( String port WWN : target Port List From Response ) { if ( varray Tagged Port WW Ns . contains ( port WWN ) | | varray Tagged Port WW Ns . contains ( port WWN . to Upper Case ( ) ) ) { filtered Target List . add ( port WWN . to Upper Case ( ) ) ; } } log . debug ( STRING ) ; return filtered Target List ; }",
    "label": 1
  },
  {
    "text_1": "combine lista and list b to a single list without duplicates .",
    "text_2": "private List < File > combine ( List < File > list A , List < File > list B ) { Linked Hash Set < File > combined Projects = Sets . new Linked Hash Set ( list A ) ; combined Projects . add All ( list B ) ; return new Array List < > ( combined Projects ) ; }",
    "label": 1
  },
  {
    "text_1": "move the selected item to the first position",
    "text_2": "protected void move Selection To First Position ( ) { if ( selection Table . get Selection Count ( ) = = NUM ) { return ; } int index = NUM ; for ( final Table Item table Item : selection Table . get Selection ( ) ) { final DL Item item = ( DL Item ) table Item . get Data ( ) ; selection . remove ( item ) ; selection . add ( index + + , item ) ; } redraw Tables ( ) ; selection Table . select ( NUM , index - NUM ) ; selection Table . force Focus ( ) ; }",
    "label": 1
  },
  {
    "text_1": "equality comparision between two",
    "text_2": "public boolean equals ( Object obj ) { if ( obj = = null ) return BOOL ; if ( this = = obj ) return BOOL ; if ( get Class ( ) ! = obj . get Class ( ) ) return BOOL ; Choice Format other = ( Choice Format ) obj ; return ( Arrays . equals ( choice Limits , other . choice Limits ) & & Arrays . equals ( choice Formats , other . choice Formats ) ) ; }",
    "label": 1
  },
  {
    "text_1": "add mention suggestions to a given bucket in the adapter . the adapter tracks the latest result for every given bucket , and passes this information to the suggestion smanager to construct the list of suggestions in the appropriate order . note : this should be called exactly once for every bucket returned from the query client .",
    "text_2": "public void add Suggestions ( final @ Non Null Suggestions Result result , final @ Non Null String bucket , final @ Non Null Token Source source ) { Query Token query = result . get Query Token ( ) ; synchronized ( m Lock ) { m Result Map . put ( bucket , result ) ; Set < String > waiting For Buckets = m Waiting For Results . get ( query ) ; if ( waiting For Buckets ! = null ) { waiting For Buckets . remove ( bucket ) ; if ( waiting For Buckets . size ( ) = = NUM ) { m Waiting For Results . remove ( query ) ; } } } String current Token String = source . get Current Token String ( ) ; synchronized ( m Lock ) { m Suggestions . clear ( ) ; List < Sugg est ible > suggestions = m Suggestions List Builder . build Suggestions ( m Result Map , current Token String ) ; if ( suggestions . size ( ) > NUM ) { m Suggestions . add All ( suggestions ) ; m Suggestions Visibility Manager . display Suggestions ( BOOL ) ; } else { hide Suggestions If Necessary ( result . get Query Token ( ) , source ) ; } } notify Data Set Changed ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the seconds until account expiration .",
    "text_2": "public void request Seconds Until Account Expiration ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL ACCOUNT EXPIRATION ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a deep copy of this iterator . the cloned iterator is not reset .",
    "text_2": "public DTM Axis Iterator clone Iterator ( ) { is Restartable = BOOL ; try { final Preceding Iterator clone = ( Preceding Iterator ) super . clone ( ) ; final int [ ] stack Copy = new int [ stack . length ] ; System . arraycopy ( stack , NUM , stack Copy , NUM , stack . length ) ; clone . stack = stack Copy ; return clone ; } catch ( Clone Not Supported Exception e ) { throw new DTM Exception ( XML Messages . create XML Message ( XML Error Resources . ER ITERATOR CLONE NOT SUPPORTED , null ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "removes and returns last element , or null if empty .",
    "text_2": "private E unlink Last ( ) { Node < E > l = last ; if ( l = = null ) return null ; Node < E > p = l . prev ; E item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p = = null ) first = null ; else p . next = null ; - - count ; not Full . signal ( ) ; return item ; }",
    "label": 1
  },
  {
    "text_1": "simply return a task that indicates that the operation completed .",
    "text_2": "private Task Resource Rep finish Deactivate Task ( Block Consistency Group consistency Group , String task ) { URI id = consistency Group . get Id ( ) ; Operation op = new Operation ( ) ; op . ready ( ) ; op . set Progress ( NUM ) ; op . set Resource Type ( Resource Operation Type Enum . DELETE CONSISTENCY GROUP ) ; Operation status = db Client . create Task Op Status ( Block Consistency Group . class , id , task , op ) ; return to Task ( consistency Group , task , status ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize the membership matrix with random values .",
    "text_2": "private void initialize Membership Matrix ( ) { for ( int i = NUM ; i < points . size ( ) ; i + + ) { for ( int j = NUM ; j < k ; j + + ) { membership Matrix [ i ] [ j ] = random . next Double ( ) ; } membership Matrix [ i ] = Math Arrays . normalize Array ( membership Matrix [ i ] , NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "much more accurate than log ( 1 + value ) , for values close to zero .",
    "text_2": "public static double log NUM p ( double value ) { if ( USE JDK MATH ) { return STRICT MATH ? Strict Math . log NUM p ( value ) : Math . log NUM p ( value ) ; } if ( BOOL ) { if ( value = = Double . POSITIVE INFINITY ) { return Double . POSITIVE INFINITY ; } double value Plus One = NUM + value ; if ( value Plus One = = NUM ) { return value ; } else { return Fast Math . log ( value Plus One ) * ( value / ( value Plus One - NUM ) ) ; } } if ( value > - NUM ) { if ( value = = Double . POSITIVE INFINITY ) { return Double . POSITIVE INFINITY ; } double value Plus One = NUM + value ; if ( value Plus One = = NUM ) { return value ; } else if ( Math . abs ( value ) < NUM ) { double z = value / ( value + NUM ) ; double z NUM = z * z ; return z * ( NUM + z NUM * ( ( NUM / NUM ) + z NUM * ( ( NUM / NUM ) + z NUM * ( ( NUM / NUM ) + z NUM * ( ( NUM / NUM ) + z NUM * ( ( NUM / NUM ) ) ) ) ) ) ) ; } int value Plus One Bits Hi = ( int ) ( Double . double To Raw Long Bits ( value Plus One ) > > NUM ) & NUM ; int value Plus One Exp = ( value Plus One Bits Hi > > NUM ) - MAX DOUBLE EXPONENT ; int x Index = ( ( value Plus One Bits Hi < < NUM ) > > > ( NUM - LOG BITS ) ) ; double z = ( value Plus One * two Pow Tab [ - value Plus One Exp - MIN DOUBLE EXPONENT ] ) * log X Inv Tab [ x Index ] - NUM ; z * = ( NUM - z * ( ( NUM / NUM ) - z * ( NUM / NUM ) ) ) ; return value Plus One Exp * LOG NUM + log X Log Tab [ x Index ] + ( z + ( value - ( value Plus One - NUM ) ) / value Plus One ) ; } else if ( value = = - NUM ) { return Double . NEGATIVE INFINITY ; } else { return Double . Na N ; } }",
    "label": 1
  },
  {
    "text_1": "parses the given bytes using read raw varint 32 ( ) and read raw varint 64 ( ) and checks that the result matches the given value .",
    "text_2": "private void assert Read Varint ( byte [ ] data , long value ) throws Exception { Coded Input Stream input = Coded Input Stream . new Instance ( data ) ; assert Equals ( ( int ) value , input . read Raw Varint NUM ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( data ) ; assert Equals ( value , input . read Raw Varint NUM ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( data ) ; assert Equals ( value , input . read Raw Varint NUM Slow Path ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( data ) ; assert True ( input . skip Field ( Wire Format . WIRETYPE VAR INT ) ) ; assert Data Consumed ( data , input ) ; for ( int block Size = NUM ; block Size < = NUM ; block Size * = NUM ) { input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( ( int ) value , input . read Raw Varint NUM ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( value , input . read Raw Varint NUM ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( value , input . read Raw Varint NUM Slow Path ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert True ( input . skip Field ( Wire Format . WIRETYPE VAR INT ) ) ; assert Data Consumed ( data , input ) ; } byte [ ] longer Data = new byte [ data . length + NUM ] ; System . arraycopy ( data , NUM , longer Data , NUM , data . length ) ; Input Stream raw Input = new Byte Array Input Stream ( longer Data ) ; assert Equals ( ( int ) value , Coded Input Stream . read Raw Varint NUM ( raw Input ) ) ; assert Equals ( NUM , raw Input . available ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "calculates the angle between two given lines . the provided entry objects mark the starting and end points of the lines .",
    "text_2": "public double calc Angle Between Lines ( Entry start NUM , Entry end NUM , Entry start NUM , Entry end NUM ) { double angle NUM = calc Angle With Ratios ( start NUM , end NUM ) ; double angle NUM = calc Angle With Ratios ( start NUM , end NUM ) ; return Math . abs ( angle NUM - angle NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "overrides org . xml . sax . helpers . defaulthandler characters ( char [ ] , int , int )",
    "text_2": "@ Override public void characters ( char [ ] ch , int start , int length ) throws SAX Exception { m String Builder . append ( ch , start , length ) ; }",
    "label": 1
  },
  {
    "text_1": "negate ( mathcontext ) for a negative bigdecimal",
    "text_2": "public void test Negate Math Context Negative ( ) { String a = STRING ; int a Scale = NUM ; int precision = NUM ; Rounding Mode rm = Rounding Mode . CEILING ; Math Context mc = new Math Context ( precision , rm ) ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal res = a Number . negate ( mc ) ; assert Equals ( STRING , c , res . to String ( ) ) ; assert Equals ( STRING , c Scale , res . scale ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "check that the number of arguments passed to this function is correct .",
    "text_2": "public void check Number Args ( int arg Num ) throws Wrong Number Args Exception { if ( arg Num < NUM ) report Wrong Number Args ( ) ; }",
    "label": 1
  },
  {
    "text_1": "c : the error ( ) and warning ( ) reporting system use error codes . but the error 2 ( ) and warning 2 ( ) reporting system uses message object types .",
    "text_2": "public void warning NUM ( final String filename , int ln , int col , Object msg , String source ) { warning ( filename , ln , col , msg . to String ( ) , source ) ; }",
    "label": 1
  },
  {
    "text_1": "returns this simplex enlarged by p offset . the result simplex is intersected with the by p offset enlarged bounding oct agon of this simplex",
    "text_2": "@ Override public Shape Tile Simplex enlarge ( double p offset ) { if ( p offset = = NUM ) return this ; Shape Tile Simplex offset simplex = offset ( p offset ) ; Shape Tile Octagon bounding oct = bounding octagon ( ) ; if ( bounding oct . is Na N ( ) ) return Shape Tile Simplex . EMPTY ; Shape Tile Octagon offset oct = bounding oct . offset ( p offset ) ; return offset simplex . intersection ( offset oct . to Simplex ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "determine if the current set of analysis inputs are valid . if not , provide an error message that describes the problem .",
    "text_2": "private String validate Inputs ( ) { if ( jar Radio . get Selection ( ) ) { File f = new File ( jar Path . get Text ( ) ) ; if ( ! f . exists ( ) ) { return STRING ; } if ( ! f . can Read ( ) ) { return STRING ; } } else { File f = new File ( dir Path . get Text ( ) ) ; if ( ! f . exists ( ) ) { return STRING ; } if ( ! f . can Read ( ) ) { return STRING ; } } return null ; }",
    "label": 1
  },
  {
    "text_1": "return true if the test name is \" suppress warnings \" .",
    "text_2": "private boolean is Suppress Warnings Test ( String base Name ) { return base Name . equals ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "are these two vectors the same ? they are is they both have the same x and y values .",
    "text_2": "public boolean equals ( Object o ) { if ( ! ( o instanceof Vector NUM f ) ) { return BOOL ; } if ( this = = o ) { return BOOL ; } Vector NUM f comp = ( Vector NUM f ) o ; if ( Float . compare ( x , comp . x ) ! = NUM ) { return BOOL ; } if ( Float . compare ( y , comp . y ) ! = NUM ) { return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "multiply two numbers of different length and different signs . the first is positive . the first is longer .",
    "text_2": "public void test Case NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , NUM , - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method has to be implemented and cannot throw any exception .",
    "text_2": "public void initialize ( ) throws Execution Exception { }",
    "label": 1
  },
  {
    "text_1": "copies the values nodes from the input entity to this object",
    "text_2": "public void copy Value Nodes To Me ( Entity from ) { for ( Value Node from Child : from . get Children ( Value Node . class ) ) { Value Node to Child = get Child ( from Child . get Name ( ) , Value Node . class ) ; to Child . set Value ( from Child . get Value ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "writes the tail of the map to the stream .",
    "text_2": "public void write Map End ( ) throws IO Exception { os . write ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "returns if a method is static",
    "text_2": "private static boolean is Static ( Method m ) { int mods = m . get Modifiers ( ) ; return ( mods & Modifier . STATIC ) ! = NUM ; }",
    "label": 1
  },
  {
    "text_1": "close the stream . once a stream has been closed , further read ( ) , ready ( ) , mark ( ) , or reset ( ) invocations will throw an ioexception . closing a previously - closed stream , however , has no effect .",
    "text_2": "public void close ( ) throws IO Exception { f Input Stream . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "copy a file from a source to a destination . if destination file already exists , it is not overwritten .",
    "text_2": "void copy File ( String source , String target ) ;",
    "label": 1
  },
  {
    "text_1": "adds the given listener to the service . if the service already contains the given listener it wont be added again .",
    "text_2": "private static void add Listeners For Real ( final Service service , final Set < Listener > existing Listeners , final Listener listener , final Executor executor ) { if ( ! existing Listeners . contains ( listener ) ) { existing Listeners . add ( listener ) ; service . add Listener ( listener , executor ) ; } }",
    "label": 1
  },
  {
    "text_1": "jdbc 4 . 2 helper methods .",
    "text_2": "static Object convert Java Time To Java Sql ( Object x ) { if ( x instanceof Local Date ) { return Date . value Of ( ( Local Date ) x ) ; } else if ( x instanceof Local Date Time ) { return Timestamp . value Of ( ( Local Date Time ) x ) ; } else if ( x instanceof Local Time ) { return Time . value Of ( ( Local Time ) x ) ; } return x ; }",
    "label": 1
  },
  {
    "text_1": "construct a vector by appending one vector to another vector .",
    "text_2": "public Array Real Vector ( Array Real Vector v1 , Array Real Vector v2 ) { data = new double [ v1 . data . length + v2 . data . length ] ; System . arraycopy ( v1 . data , NUM , data , NUM , v1 . data . length ) ; System . arraycopy ( v2 . data , NUM , data , v1 . data . length , v2 . data . length ) ; }",
    "label": 1
  },
  {
    "text_1": "determine how long it ' s been since chrome was first installed . note that this may not accurate for various reasons , but it shouldn ' t affect stats too much .",
    "text_2": "public static long install Age ( long current Timestamp , long install Timestamp , boolean send Install Event ) { if ( send Install Event ) { return INSTALL AGE IM MEDI ATE LY AFTER INSTAL LING ; } else { return Math . max ( NUM , ( current Timestamp - install Timestamp ) / MS PER DAY ) ; } }",
    "label": 1
  },
  {
    "text_1": "calculate total amount of virtual machine v swap saved in shared storage when local v swap option is enabled . this option enabled virtual machine v swap placement on host local storage . return value in ter abytes .",
    "text_2": "public double calculate Local Swap Total Capacity ( int host count , int host local swap size ) { double d = ( double ) ( host count * host local swap size ) / NUM ; d * = - NUM ; d = ( double ) Math . round ( d * NUM ) / NUM ; return d ; }",
    "label": 1
  },
  {
    "text_1": "test checks if the proxy provided by proxy selector will be used for connection to the server",
    "text_2": "public void test Using Proxy Selector ( ) throws Exception { Mock Server server = new Mock Server ( STRING ) ; Mock Server proxy = new Mock Server ( STRING ) ; URL url = new URL ( STRING + server . port ( ) ) ; Proxy Selector def PS = Proxy Selector . get Default ( ) ; Proxy Selector . set Default ( new Test Proxy Selector ( server . port ( ) , proxy . port ( ) ) ) ; try { Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Connect Timeout ( NUM ) ; connection . set Read Timeout ( NUM ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( NUM ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( NUM ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; assert True ( STRING , connection . using Proxy ( ) ) ; assert True ( STRING , proxy . accepted ) ; connection . disconnect ( ) ; assert True ( STRING , connection . using Proxy ( ) ) ; } finally { Proxy Selector . set Default ( def PS ) ; } }",
    "label": 1
  },
  {
    "text_1": "return whether or not the worklist is empty .",
    "text_2": "public boolean is Empty ( ) { return item List . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "return a table handler containing the thread indexes . indexes are computed from the threadid .",
    "text_2": "protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] path = Jvm Runtime Impl . get Library Path ( user Data ) ; final long time = System . current Time Millis ( ) ; final int len = path . length ; Snmp Oid indexes [ ] = new Snmp Oid [ len ] ; for ( int i = NUM ; i < len ; i + + ) { indexes [ i ] = new Snmp Oid ( i + NUM ) ; } return new Snmp Cached Data ( time , indexes , path ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a child node .",
    "text_2": "public final void add Child Node ( Row Regex Expr Node child Node ) { child Nodes . add ( child Node ) ; }",
    "label": 1
  },
  {
    "text_1": "check if we ' ve crossed a reasonable touch slop for the given child view . if the child cannot be dragged along the horizontal or vertical axis , motion along that axis will not count toward the slop check .",
    "text_2": "private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child = = null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal & & check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "add an address to this bucket .",
    "text_2": "public void add ( final long addr ) { addrs . add ( addr ) ; }",
    "label": 1
  },
  {
    "text_1": "converts a node representation subtype to a string . used for debugging .",
    "text_2": "public static String node Sub Type To String ( int sub Type ) { String val = STRING ; switch ( sub Type ) { case Node Representation . AND TYPE : val = STRING ; break ; case Node Representation . OR TYPE : val = STRING ; break ; case Node Representation . IMP LIES TYPE : val = STRING ; break ; case Node Representation . FORALL TYPE : val = STRING ; break ; case Node Representation . EXISTS TYPE : val = STRING ; break ; case Node Representation . SQ SUB TYPE : val = STRING ; break ; case Node Representation . OTHER TYPE : val = STRING ; break ; } return val ; }",
    "label": 1
  },
  {
    "text_1": "returns a new valid instance of the class save directory . it tries to use the given file . if that is not valid it ti res to use its parent file . if that is also not valid it will throw a filenotfoundexception .",
    "text_2": "@ Not Null public static Save Directory from ( File file ) throws File Not Found Exception { File current File = file ; Save Directory result = null ; if ( current File = = null ) { } else { result = create Valid Save Directory ( current File ) ; current File = current File . get Parent File ( ) ; if ( result ! = null ) { return result ; } else if ( current File = = null ) { } else { result = create Valid Save Directory ( current File ) ; current File = current File . get Parent File ( ) ; if ( result ! = null ) { return result ; } else { } } } throw new File Not Found Exception ( STRING + file ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs an ander son - dar ling test for the given column of data .",
    "text_2": "public General An der son Dar ling Test ( List < Double > data , Real Distribution dist ) { if ( dist = = null ) { throw new Null Pointer Exception ( ) ; } this . dist = dist ; Collections . sort ( data ) ; this . data = data ; run Test ( ) ; }",
    "label": 1
  },
  {
    "text_1": "helper function for the evaluation of the kernel ( k ' n ) using lambda pruning",
    "text_2": "protected double kernel Helper LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if ( n = = NUM ) { return get Return Value ( n ) ; } if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { ; return get Return Value ( n ) ; } if ( remaining Match Length < NUM * n ) { return get Return Value ( n ) ; } int adr = NUM ; if ( m use Recursion Cache ) { adr = m mult X * n + m mult Y * end Index S + m mult Z * end Index T + m mult ZZ * remaining Match Length ; if ( cach ek h NUM K [ adr % max Cache ] = = adr + NUM ) { return cach ek h NUM [ adr % max Cache ] ; } } int rml = NUM ; double result = NUM ; for ( int iS = ( end Index S - remaining Match Length ) ; iS < = end Index S ; iS + + ) { result * = m lambda ; result + = kernel Helper NUM LP ( n , s , iS , t , end Index T , rml + + ) ; } if ( m use Recursion Cache & & end Index S > = NUM & & end Index T > = NUM & & n > = NUM ) { cach ek h K [ adr % max Cache ] = adr + NUM ; cach ek h [ adr % max Cache ] = result ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "emit latest value for every given period of time . < img class = \" marble \" src = \" https : / / raw . githubusercontent . com / reactor / projectre actor . io / master / src / main / static / assets / img / marble / sample timespan . png \" alt = \" \" >",
    "text_2": "public final Flux < T > sample ( Duration timespan ) { return sample Millis ( timespan . to Millis ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "test de busqu eda de var ios usuarios para active directory",
    "text_2": "public void test Find Users Active Directory ( ) throws Exception { Ldap Manager mgr = get Ldap AD ( ) ; List ret = null ; And Filter filter = new And Filter ( ) ; filter . and ( new Like Filter ( mgr . get Users Returning Attribute ( Ldap User Attribute Constants . LDAP USER ATTRIBUTE GIVEN NAME ) , STRING ) ) ; try { Ldap Search Manager VO search Mgr VO = new Ldap Search Manager VO ( ) ; search Mgr VO . set Filter ( filter ) ; search Mgr VO . set Add User Classes ( BOOL ) ; ret = mgr . find Users ( search Mgr VO ) ; } catch ( Exception e ) { } assert Equals ( NUM , ret . size ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "modifies the specified calendar by \" rounding \" down to the specified unit",
    "text_2": "public static void round ( Calendar c , String unit ) { Integer uu = CALENDAR UNITS . get ( unit ) ; if ( null = = uu ) { throw new Illegal Argument Exception ( STRING + unit ) ; } int u = uu . int Value ( ) ; switch ( u ) { case Calendar . YEAR : c . clear ( Calendar . MONTH ) ; case Calendar . MONTH : c . clear ( Calendar . DAY OF MONTH ) ; c . clear ( Calendar . DAY OF WEEK ) ; c . clear ( Calendar . DAY OF WEEK IN MONTH ) ; c . clear ( Calendar . DAY OF YEAR ) ; c . clear ( Calendar . WEEK OF MONTH ) ; c . clear ( Calendar . WEEK OF YEAR ) ; case Calendar . DATE : c . clear ( Calendar . HOUR OF DAY ) ; c . clear ( Calendar . HOUR ) ; c . clear ( Calendar . AM PM ) ; case Calendar . HOUR OF DAY : c . clear ( Calendar . MINUTE ) ; case Calendar . MINUTE : c . clear ( Calendar . SECOND ) ; case Calendar . SECOND : c . clear ( Calendar . MILLISECOND ) ; break ; default : throw new Illegal State Exception ( STRING + u + STRING + unit ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a new web ster . the port is determined by the org . jini . rio . tools . web ster . port system property . if the org . jini . rio . tools . web ster . port system property does not exist , an anony no us port will be allocated .",
    "text_2": "public Web ster ( ) throws Bind Exception { this . port = Integer . get Integer ( WEB STER PORT , NUM ) ; initialize ( ) ; }",
    "label": 1
  },
  {
    "text_1": "opens a dialog window and asks the user for the name of this axis .",
    "text_2": "public void edit ( Object plot Canvas ) { String label = J Option Pane . show Input Dialog ( ( Plot Canvas ) plot Canvas , STRING , label ) ; if ( label ! = null ) { set Legend ( label ) ; } }",
    "label": 1
  },
  {
    "text_1": "compute weight matrix for a rgb color histogram",
    "text_2": "public static double [ ] [ ] compute Weight Matrix ( int bpp ) { final int dim = bpp * bpp * bpp ; final double [ ] [ ] m = new double [ dim ] [ dim ] ; final double max = NUM * ( bpp - NUM ) ; for ( int x = NUM ; x < dim ; x + + ) { final int rx = ( x / bpp ) / bpp ; final int gx = ( x / bpp ) % bpp ; final int bx = x % bpp ; for ( int y = x ; y < dim ; y + + ) { final int ry = ( y / bpp ) / bpp ; final int gy = ( y / bpp ) % bpp ; final int by = y % bpp ; final double dr = Math . abs ( rx - ry ) ; final double dg = Math . abs ( gx - gy ) ; final double db = Math . abs ( bx - by ) ; final double val = NUM - ( dr + dg + db ) / max ; m [ x ] [ y ] = m [ y ] [ x ] = val ; } } return m ; }",
    "label": 1
  },
  {
    "text_1": "select functionality test test select orderby ( ) . selects records from a table using order by",
    "text_2": "public void test Select Order By ( ) throws SQL Exception { String select Query = STRING + Database Creator . ORDERS TABLE + STRING ; Result Set result = statement . execute Query ( select Query ) ; Array List < Integer > values = new Array List < Integer > ( ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; int index = NUM ; while ( result . next ( ) ) { Integer on um = result . get Int ( STRING ) ; assert True ( STRING , values . contains ( on um ) ) ; assert Equals ( STRING , index , values . index Of ( on um ) ) ; index + + ; } result . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "notifies of the presence of the doctype line in the document .",
    "text_2": "public void doctype Decl ( String root Element , String public Id , String system Id , Augmentations augs ) throws XNI Exception { f In DTD = BOOL ; try { if ( f Lexical Handler ! = null ) { f Lexical Handler . start DTD ( root Element , public Id , system Id ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } if ( f Decl Handler ! = null ) { f Declared Attrs = new Symbol Hash ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a new client with the provided attributes to the remote address .",
    "text_2": "public Rpc Client peer With ( Peer Info server Info , Bootstrap bootstrap , Map < String , Object > attributes ) throws IO Exception { Inet Socket Address remote Address = new Inet Socket Address ( server Info . get Host Name ( ) , server Info . get Port ( ) ) ; return peer With ( remote Address , bootstrap , attributes ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the types that define a relation which contains the given po . explicit types are returned even if they don ' t actually contain the given po .",
    "text_2": "public static List < M Relation Type > retrieve Types ( final PO po , final int window Id ) { if ( po . get Key Columns ( ) . length ! = NUM ) { logger . severe ( po + STRING + po . get Key Columns ( ) . length + STRING ) ; PO Relation Exception . throw Wrong Key Column Count ( po ) ; } final String key Column = po . get Key Columns ( ) [ NUM ] ; final int col Id = M Column . get Column ID ( po . get Table Name ( ) , key Column ) ; final Prepared Statement pstmt = DB . prepare Statement ( SQL , po . get Trx Name ( ) ) ; Result Set rs = null ; try { pstmt . set Int ( NUM , po . get Table ID ( ) ) ; pstmt . set Int ( NUM , col Id ) ; rs = pstmt . execute Query ( ) ; final List < M Relation Type > result = eval Result Set ( po , window Id , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQL Exception e ) { logger . severe ( e . get Message ( ) ) ; throw new Adempiere Exception ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }",
    "label": 1
  },
  {
    "text_1": "the real guts of par sen etwork response . broken out for readability .",
    "text_2": "private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; Bitmap bitmap = null ; if ( m Max Width = = NUM & & m Max Height = = NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap ! = null & & ( temp Bitmap . get Width ( ) > desired Width | | temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap = = null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "dec hun ki fy the running query and monitor the sesame iterator .",
    "text_2": "private static I Closeable Iterator < I Binding Set > iterator ( final I Running Query running Query ) { final I Closeable Iterator < I Binding Set [ ] > it NUM = running Query . iterator ( ) ; final I Closeable Iterator < I Binding Set > it NUM = new Dec hun ker ator < I Binding Set > ( it NUM ) ; final I Closeable Iterator < I Binding Set > it NUM = new Running Query Closeable Iterator < I Binding Set > ( running Query , it NUM ) ; return it NUM ; }",
    "label": 1
  },
  {
    "text_1": "tell if this expression or it ' s subexpressions can traverse outside the current subtree .",
    "text_2": "public boolean can Traverse Outside Subtree ( ) { if ( null ! = m parts ) { int n = m parts . size ( ) ; for ( int i = NUM ; i < n ; i + + ) { AVT Part part = ( AVT Part ) m parts . element At ( i ) ; if ( part . can Traverse Outside Subtree ( ) ) return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "grant write permission to attributes .",
    "text_2": "public void grant Write Permission ( Collection attribute Names ) { Iterator it = attribute Names . iterator ( ) ; if ( it ! = null ) { while ( it . has Next ( ) ) { String temp = ( String ) it . next ( ) ; writ ables . add ( temp . to Lower Case ( ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "replace the value on the top of the stack with the given value .",
    "text_2": "private void replace Top ( Scope top Of Stack ) { stack . set ( stack . size ( ) - NUM , top Of Stack ) ; }",
    "label": 1
  },
  {
    "text_1": "initializes a picture by reading in a . png , . gif , or . jpg from a file .",
    "text_2": "public Picture ( File file ) { try { image = Image IO . read ( file ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING + file ) ; } if ( image = = null ) { throw new Runtime Exception ( STRING + file ) ; } width = image . get Width ( null ) ; height = image . get Height ( null ) ; filename = file . get Name ( ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize state with defaults .",
    "text_2": "protected void initialize State ( S current ) { Initialization Utils . initialize ( current ) ; if ( current . document Expiration Time Micros < = NUM ) { current . document Expiration Time Micros = Service Utils . compute Expiration Time ( Service Utils . DEFAULT DOC EXPIRATION TIME MICROS ) ; } }",
    "label": 1
  },
  {
    "text_1": "reports whether this http cookie has expired or not .",
    "text_2": "public boolean has Expired ( ) { if ( max Age = = NUM ) return BOOL ; if ( max Age = = MAX AGE UNSPECIFIED ) return BOOL ; long delta Second = ( System . current Time Millis ( ) - when Created ) / NUM ; if ( delta Second > max Age ) return BOOL ; else return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "load an object from the provided uri .",
    "text_2": "public Object load ( URI uri ) throws IO Exception { Input Stream Reader src = null ; try { src = new File Reader ( new File ( uri ) ) ; return xstream . from XML ( src ) ; } finally { if ( null ! = src ) { src . close ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "this method will close writer execution service and get the node holders and add them to node holder list",
    "text_2": "private void close Writer Execution Service ( Executor Service service ) throws Carbon Data Writer Exception { try { service . shutdown ( ) ; service . await Termination ( NUM , Time Unit . DAYS ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; throw new Carbon Data Writer Exception ( e . get Message ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "receive notification of character data inside an element .",
    "text_2": "public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( ! m should Process ) return ; XSLT Element Processor elem Processor = get Current Processor ( ) ; XSLT Element Def def = elem Processor . get Elem Def ( ) ; if ( def . get Type ( ) ! = XSLT Element Def . T PCDATA ) elem Processor = def . get Processor For ( null , STRING ) ; if ( null = = elem Processor ) { if ( ! XML Character Recognizer . is White Space ( ch , start , length ) ) error ( XSL Messages . create Message ( XSLT Error Resources . ER NON WHITESPACE NOT ALLOWED IN POSITION , null ) , null ) ; } else elem Processor . characters ( this , ch , start , length ) ; }",
    "label": 1
  },
  {
    "text_1": "writes a namespace qualified element or attribute name .",
    "text_2": "protected void write Qualified Name ( String ns Alias , String name ) throws IO Exception { if ( ns Alias ! = null & & ns Alias . length ( ) > NUM ) { writer . write ( ns Alias ) ; writer . write ( STRING ) ; } writer . write ( name ) ; }",
    "label": 1
  },
  {
    "text_1": "pop a base uri from the stack .",
    "text_2": "String pop Base Inden tifier ( ) { return ( String ) m base Identifiers . pop ( ) ; }",
    "label": 1
  },
  {
    "text_1": "cleanup the \" is complex type attribute \" info .",
    "text_2": "private synchronized void cleanup Is Complex Type Attribute ( ) { first Attribute = null ; remaining Attributes . clear ( ) ; is Complex Type Attribute = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "stores timestamped records , and sets status to succeeded if everything went as expected . this method is synchronized so that these two operations are executed atomically and do not distur b each other : 1 ) storet ime stam pand setstatus : stores timestamp records and sets status 2 ) set timestamp failed : reads status , checks existence of un stam ped records and sets status",
    "text_2": "private synchronized void store Timestamp And Set Status ( Timest am per . Timestamp Succeeded message , Timestamp Record timestamp Record ) throws Exception { try { persist Timestamp Record ( message , timestamp Record ) ; set Timestamp Succeeded ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; set Timestamp Failed Reg ard less Of Queue ( new Date Time ( ) ) ; throw e ; } }",
    "label": 1
  },
  {
    "text_1": "creates an embedded metas er vice instance , executing a jo lie interpreter in the local jvm .",
    "text_2": "public Embedded Meta Service ( ) throws IO Exception , Execution Exception { this ( System . getenv ( JO LI E HOME ENV ) ) ; }",
    "label": 1
  },
  {
    "text_1": "return given bytes as a base 64 encoded string .",
    "text_2": "protected String to Base NUM ( byte [ ] data ) { return Base NUM . encode To String ( data , Base NUM . DEFAULT ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the specified node to the list of selected nodes . the list of selected nodes is guaranteed to be sorted in the same direction that the nodes appear in the tree . we only allow nodes to be in the selected list that are peers in the tree ( we do not allow selects to span multiple depths in the tree . behavior : if no modifier key is depressed , the list of selected nodes will be set to contain just the node passed to this method . shift select : if shift is depressed , then we attempt to do a continuous range select . if there exists one or more nodes in the selected nodes list , we test if the node falls within the list . if it does not fall within , we connect the contiguous range of nodes from the specified node to the nearest selected node . if the node falls within the list , we do a continuous range selection to the last node that was selected , not the closest . ctrl select : if ctrl is depressed then we simply search for the insertion point of the specified node in the already sorted select list . if the node is already present , then we remove it and unselect the node . if it was not present , then we insert the node at the appropriate spot in the array and select it .",
    "text_2": "public boolean select Node ( D node Data , Signal Event event ) { if ( selected Nodes . is Empty ( ) ) { insert And Select Node ( node Data , NUM , BOOL ) ; return BOOL ; } if ( ! has Same Parent ( selected Nodes . get ( NUM ) , node Data ) ) { if ( ! this . multil evel Selection | | event . get Shift Key ( ) ) { return select Single Node ( node Data ) ; } } if ( event = = null | | event . get Command Key ( ) ) { ctrl Select ( node Data ) ; return BOOL ; } else { if ( event . get Shift Key ( ) ) { return shift Select ( node Data ) ; } } return select Single Node ( node Data ) ; }",
    "label": 1
  },
  {
    "text_1": "converts a line index to a y co - ordinate .",
    "text_2": "public int line To Y ( int line ) { Font Metrics fm = painter . get Font Metrics ( ) ; return ( line - first Line ) * fm . get Height ( ) - ( fm . get Leading ( ) + fm . get Max Descent ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "indicates to which data offset within the current chunk the file pointer currently points",
    "text_2": "protected synchronized int current chunk offset ( ) throws IO Exception { long fp = backing Random Access File . get File Pointer ( ) ; if ( fp < f Header . header Size ( ) ) { return - NUM ; } else { fp - = f Header . header Size ( ) ; if ( fp = = NUM ) { return NUM ; } else { return ( int ) ( ( fp % CHUNK ENC SIZE ) - CHUNK IV SIZE ) ; } } }",
    "label": 1
  },
  {
    "text_1": "construct a pattern parser .",
    "text_2": "private Pattern Parser ( ) throws Hyphenation Exception { token = new String Builder ( ) ; parser = create Parser ( ) ; parser . set Content Handler ( this ) ; parser . set Error Handler ( this ) ; hyphen Char = STRING ; }",
    "label": 1
  },
  {
    "text_1": "we ir dly java doesn ' t seem to have arrays . shuffle ( ) , this terri ble hack does that .",
    "text_2": "public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new Array List < Integer > ( input . length ) ; for ( int i = NUM ; i < input . length ; i + + ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SE EDED RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = NUM ; i < input . length ; i + + ) copy [ i ] = vals . get ( i ) ; return copy ; }",
    "label": 1
  },
  {
    "text_1": "checks that code block throw corresponding exception .",
    "text_2": "protected void assert Exception ( final Abstract Exception Case exception Case ) throws Throwable { assert Exception ( exception Case , null ) ; }",
    "label": 1
  },
  {
    "text_1": "reads a value of an annotation and makes the given visitor visit it .",
    "text_2": "private int read Annotation Value ( int v , final char [ ] buf , final String name , final Annotation Visitor av ) { int i ; if ( av = = null ) { switch ( b [ v ] & NUM ) { case STRING : return v + NUM ; case STRING : return read Annotation Values ( v + NUM , buf , BOOL , null ) ; case STRING : return read Annotation Values ( v + NUM , buf , BOOL , null ) ; default : return v + NUM ; } } switch ( b [ v + + ] & NUM ) { case STRING : case STRING : case STRING : case STRING : av . visit ( name , read Const ( read Unsigned Short ( v ) , buf ) ) ; v + = NUM ; break ; case STRING : av . visit ( name , new Byte ( ( byte ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ) ; v + = NUM ; break ; case STRING : av . visit ( name , read Int ( items [ read Unsigned Short ( v ) ] ) = = NUM ? Boolean . FALSE : Boolean . TRUE ) ; v + = NUM ; break ; case STRING : av . visit ( name , new Short ( ( short ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ) ; v + = NUM ; break ; case STRING : av . visit ( name , new Character ( ( char ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ) ; v + = NUM ; break ; case STRING : av . visit ( name , read UTF NUM ( v , buf ) ) ; v + = NUM ; break ; case STRING : av . visit Enum ( name , read UTF NUM ( v , buf ) , read UTF NUM ( v + NUM , buf ) ) ; v + = NUM ; break ; case STRING : av . visit ( name , Type . get Type ( read UTF NUM ( v , buf ) ) ) ; v + = NUM ; break ; case STRING : v = read Annotation Values ( v + NUM , buf , BOOL , av . visit Annotation ( name , read UTF NUM ( v , buf ) ) ) ; break ; case STRING : int size = read Unsigned Short ( v ) ; v + = NUM ; if ( size = = NUM ) { return read Annotation Values ( v - NUM , buf , BOOL , av . visit Array ( name ) ) ; } switch ( this . b [ v + + ] & NUM ) { case STRING : byte [ ] bv = new byte [ size ] ; for ( i = NUM ; i < size ; i + + ) { bv [ i ] = ( byte ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v + = NUM ; } av . visit ( name , bv ) ; - - v ; break ; case STRING : boolean [ ] z v = new boolean [ size ] ; for ( i = NUM ; i < size ; i + + ) { z v [ i ] = read Int ( items [ read Unsigned Short ( v ) ] ) ! = NUM ; v + = NUM ; } av . visit ( name , z v ) ; - - v ; break ; case STRING : short [ ] sv = new short [ size ] ; for ( i = NUM ; i < size ; i + + ) { sv [ i ] = ( short ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v + = NUM ; } av . visit ( name , sv ) ; - - v ; break ; case STRING : char [ ] cv = new char [ size ] ; for ( i = NUM ; i < size ; i + + ) { cv [ i ] = ( char ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v + = NUM ; } av . visit ( name , cv ) ; - - v ; break ; case STRING : int [ ] iv = new int [ size ] ; for ( i = NUM ; i < size ; i + + ) { iv [ i ] = read Int ( items [ read Unsigned Short ( v ) ] ) ; v + = NUM ; } av . visit ( name , iv ) ; - - v ; break ; case STRING : long [ ] lv = new long [ size ] ; for ( i = NUM ; i < size ; i + + ) { lv [ i ] = read Long ( items [ read Unsigned Short ( v ) ] ) ; v + = NUM ; } av . visit ( name , lv ) ; - - v ; break ; case STRING : float [ ] fv = new float [ size ] ; for ( i = NUM ; i < size ; i + + ) { fv [ i ] = Float . int Bits To Float ( read Int ( items [ read Unsigned Short ( v ) ] ) ) ; v + = NUM ; } av . visit ( name , fv ) ; - - v ; break ; case STRING : double [ ] dv = new double [ size ] ; for ( i = NUM ; i < size ; i + + ) { dv [ i ] = Double . long Bits To Double ( read Long ( items [ read Unsigned Short ( v ) ] ) ) ; v + = NUM ; } av . visit ( name , dv ) ; - - v ; break ; default : v = read Annotation Values ( v - NUM , buf , BOOL , av . visit Array ( name ) ) ; } } return v ; }",
    "label": 1
  },
  {
    "text_1": "returns the public name ( everything following the prefix ) of the given disk name .",
    "text_2": "String public Name From Disk Name ( String disk Name ) { if ( ! should Disk Name Be Visible ( disk Name ) ) { throw new Illegal Argument Exception ( STRING + disk Name ) ; } return disk Name . substring ( m File Prefix . length ( ) , disk Name . length ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "utility method with defined return value for 0 .",
    "text_2": "public static int scan ( long v ) { return NUM - Long . number Of Leading Zeros ( v ) ; }",
    "label": 1
  },
  {
    "text_1": "convert all elements into string , and connect each string together to a single string , following the same order of the seq . insert a delimiter at each connection point . add prefix and suffix to the final result .",
    "text_2": "default Char Seq join ( Char Sequence delimiter , Char Sequence prefix , Char Sequence suffix ) { String Builder string Builder = new String Builder ( prefix ) ; for Each ( null ) ; string Builder . append ( suffix ) ; return Char Seq . of ( string Builder . to String ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "cleans stale initiator references from export group instance",
    "text_2": "private static void clean Stale Initiator References ( Export Group export Group , Db Client db Client ) { String Set export Group Initiators = export Group . get Initiators ( ) ; if ( ! Collection Utils . is Empty ( export Group Initiators ) & & ! Collection Utils . is Empty ( export Group . get Export Masks ( ) ) ) { Set < String > all Mask Initiators = new Hash Set < > ( ) ; for ( String mask : export Group . get Export Masks ( ) ) { Export Mask mask Obj = db Client . query Object ( Export Mask . class , URI . create ( mask ) ) ; if ( mask Obj ! = null & & ! Collection Utils . is Empty ( mask Obj . get Initiators ( ) ) ) { all Mask Initiators . add All ( mask Obj . get Initiators ( ) ) ; } } Set < String > stale Initiators = Sets . difference ( export Group Initiators , all Mask Initiators ) ; if ( ! Collection Utils . is Empty ( stale Initiators ) ) { Collection < URI > stale Initiator URIS = Collections NUM . transform ( stale Initiators , Common Transformer Functions . F CT N STRING TO URI ) ; export Group . remove Initiators ( new Array List < > ( stale Initiator URIS ) ) ; log . info ( STRING , stale Initiator URIS , export Group . get Id ( ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "collect the active zone set , and its zones , members for a specified vs an id .",
    "text_2": "public Zoneset show Active Zoneset ( Integer vsan Id ) throws Network Device Controller Exception { List < Zoneset > zon esets = show Zoneset ( vsan Id , BOOL , null , BOOL , BOOL ) ; return zon esets . is Empty ( ) ? null : zon esets . get ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "add a force item to the simulation .",
    "text_2": "public void add Item ( Force Item item ) { items . add ( item ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a proxy lookup that adds the current project instance to the global selection returned by utilities . actions global context ( ) .",
    "text_2": "@ Override public Lookup create Global Context ( ) { if ( proxy Lookup = = null ) { logger . config ( STRING ) ; project Lookup = new Abstract Lookup ( content ) ; proxy Lookup = new Proxy Lookup ( global Context Lookup , project Lookup ) ; } return proxy Lookup ; }",
    "label": 1
  },
  {
    "text_1": "used to communicate a progress update between a plugin tool and the main whitebox user interface .",
    "text_2": "private void update Progress ( String progress Label , int progress ) { if ( my Host ! = null & & ( ( progress ! = previous Progress ) | | ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }",
    "label": 1
  },
  {
    "text_1": "the main method . we split live ranges for registers around pe is which have catch blocks . suppose we have a pe i s which uses a symbolic register r1 . we must ensure that after register allocation , r1 is not assigned to a scratch location in s , since this would mess up code in the catch block that uses r1 . so , instead , we introduce a new temporary r2 which holds the value of r1 . the live range for r2 spans only the instruction s . later , we will ensure that r2 is never spil led . todo : this could be implemented more efficiently .",
    "text_2": "@ Override public final void perform ( IR ir ) { java . util . Hash Map < Register , Register > new Map = new java . util . Hash Map < Register , Register > ( NUM ) ; for ( Enumeration < Basic Block > be = ir . get Basic Blocks ( ) ; be . has More Elements ( ) ; ) { Basic Block bb = be . next Element ( ) ; for ( Enumeration < Instruction > ie = bb . forward Instr Enumerator ( ) ; ie . has More Elements ( ) ; ) { Instruction s = ie . next Element ( ) ; ; new Map . clear ( ) ; if ( s . is PEI ( ) & & s . operator ( ) ! = IR PRO LOGUE ) { if ( bb . has Applicable Exceptional Out ( s ) | | ! Register Restrictions . SCR ATCH IN PEI ) { split All Live Ranges ( s , new Map , ir , BOOL ) ; } } switch ( s . get Opcode ( ) ) { case MIR LOW TABLESWITCH opcode : { Register Operand r Op = MIR Low Table Switch . get Index ( s ) ; Register Operand temp = find Or Create Temp ( r Op , new Map , ir ) ; insert Move Before ( temp , r Op . copy RO ( ) , s ) ; r Op . set Register ( temp . get Register ( ) ) ; } break ; } } } }",
    "label": 1
  },
  {
    "text_1": "convert to a string path , starting with \" m / \"",
    "text_2": "public static String format Path ( List < Child Number > path ) { return PATH JOINER . join ( Iterables . concat ( Collections . singleton ( STRING ) , path ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convenience method to convert a csv string list to a set . note that this will suppress duplicates .",
    "text_2": "public static Set < String > comma Delimited List To Set ( String str ) { Set < String > set = new Tree Set < > ( ) ; String [ ] tokens = comma Delimited List To String Array ( str ) ; set . add All ( Arrays . as List ( tokens ) ) ; return set ; }",
    "label": 1
  },
  {
    "text_1": "test if the queue matches a word character ( letter or digit ) .",
    "text_2": "public boolean matches Word ( ) { return ! is Empty ( ) & & Character . is Letter Or Digit ( queue . char At ( pos ) ) ; }",
    "label": 1
  },
  {
    "text_1": "capitalizes the first letter and lower - cases every consecutive letter",
    "text_2": "String capit alise ( final String s ) { if ( s . length ( ) = = NUM ) { return s ; } final String Buffer s1 = new String Buffer ( s ) ; if ( Character . is Lower Case ( s1 . char At ( NUM ) ) ) { s1 . set Char At ( NUM , Character . to Upper Case ( s1 . char At ( NUM ) ) ) ; } for ( int j = NUM ; j < s1 . length ( ) ; j + + ) { if ( Character . is Upper Case ( s1 . char At ( j ) ) ) { s1 . set Char At ( j , Character . to Lower Case ( s1 . char At ( j ) ) ) ; } } return s1 . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "exchange function when aren as enabled . see above for explanation .",
    "text_2": "private final Object arena Exchange ( Object item , boolean timed , long ns ) { Node [ ] a = arena ; Node p = participant . get ( ) ; for ( int i = p . index ; ; ) { int b , m , c ; long j ; Node q = ( Node ) U . get Object Volatile ( a , j = ( i < < AS HI FT ) + AB ASE ) ; if ( q ! = null & & U . compare And Swap Object ( a , j , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w ! = null ) U . unpark ( w ) ; return v ; } else if ( i < = ( m = ( b = bound ) & M MASK ) & & q = = null ) { p . item = item ; if ( U . compare And Swap Object ( a , j , null , p ) ) { long end = ( timed & & m = = NUM ) ? System . nano Time ( ) + ns : NUM ; Thread t = Thread . current Thread ( ) ; for ( int h = p . hash , spins = SPINS ; ; ) { Object v = p . match ; if ( v ! = null ) { U . put Ordered Object ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; } else if ( spins > NUM ) { h ^ = h < < NUM ; h ^ = h > > > NUM ; h ^ = h < < NUM ; if ( h = = NUM ) h = SPINS | ( int ) t . get Id ( ) ; else if ( h < NUM & & ( - - spins & ( ( SPINS > > > NUM ) - NUM ) ) = = NUM ) Thread . yield ( ) ; } else if ( U . get Object Volatile ( a , j ) ! = p ) spins = SPINS ; else if ( ! t . is Interrupted ( ) & & m = = NUM & & ( ! timed | | ( ns = end - System . nano Time ( ) ) > NUM ) ) { U . put Object ( t , B LOCKER , this ) ; p . parked = t ; if ( U . get Object Volatile ( a , j ) = = p ) U . park ( BOOL , ns ) ; p . parked = null ; U . put Object ( t , B LOCKER , null ) ; } else if ( U . get Object Volatile ( a , j ) = = p & & U . compare And Swap Object ( a , j , p , null ) ) { if ( m ! = NUM ) U . compare And Swap Int ( this , BOUND , b , b + SEQ - NUM ) ; p . item = null ; p . hash = h ; i = p . index > > > = NUM ; if ( Thread . interrupted ( ) ) return null ; if ( timed & & m = = NUM & & ns < = NUM ) return TIMED OUT ; break ; } } } else p . item = null ; } else { if ( p . bound ! = b ) { p . bound = b ; p . collides = NUM ; i = ( i ! = m | | m = = NUM ) ? m : m - NUM ; } else if ( ( c = p . collides ) < m | | m = = FULL | | ! U . compare And Swap Int ( this , BOUND , b , b + SEQ + NUM ) ) { p . collides = c + NUM ; i = ( i = = NUM ) ? m : i - NUM ; } else i = m + NUM ; p . index = i ; } } }",
    "label": 1
  },
  {
    "text_1": "shutdown the application . stops the listener ( which releases its tcp port ) .",
    "text_2": "public void shutdown ( ) throws Connection Manager Exception { s logger . info ( STRING ) ; connection Lock . lock ( ) ; try { close All Connections ( ) ; if ( listener ! = null ) { listener . stop ( ) ; listener = null ; } executor Service . shutdown ( ) ; } catch ( Exception e ) { throw new Connection Manager Exception ( STRING , e ) ; } finally { connection Lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "validates ipv 4 address using regex for the given ipaddress",
    "text_2": "private static Boolean is Valid IPV NUM ( final String ip Address ) { boolean status = BOOL ; if ( String Utils . is Not Empty ( ip Address ) ) { status = Inet Address Utils . is I Pv NUM Address ( ip Address ) ; } return status ; }",
    "label": 1
  },
  {
    "text_1": "check if this expression column has a valid cached value at the given row .",
    "text_2": "public boolean is Cache Valid ( int row ) { return m valid . get ( row ) ; }",
    "label": 1
  },
  {
    "text_1": "saves the instance identifier of this security server to file .",
    "text_2": "public static final void save Instance Identifier ( String conf Path , String instance Identifier ) throws Exception { Path file = Paths . get ( conf Path , INSTANCE IDENTIFIER FILE ) ; log . trace ( STRING , file ) ; Atomic Save . execute ( file . to String ( ) , STRING , instance Identifier . get Bytes ( Standard Charsets . UTF NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "check out if is extends from activity or fragment",
    "text_2": "private void check Is Correct Class ( ) { if ( check Is Sub Class ( ACT NAME ) ) { type = Element Type . ACT TIVITY ; } else if ( check Is Sub Class ( FRAG NAME ) | | check Is Sub Class ( V4 FRAG NAME ) ) { type = Element Type . FRAGMENT ; } else { throw new Illegal Argument Exception ( String . format ( STRING , element . get Qualified Name ( ) , ACT NAME , FRAG NAME , V4 FRAG NAME ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "add a tasks which does not fit in the named queues ( like caching or tv show episode scrap ing task )",
    "text_2": "public void add Unnamed Task ( T mm Task task ) { if ( unnamed Task Executor = = null | | unnamed Task Executor . is Shutdown ( ) ) { unnamed Task Executor = create Unnamed Task Executor ( ) ; } task . add Listener ( this ) ; task . set State ( Task State . QUEUED ) ; unnamed Task Executor . execute ( task ) ; }",
    "label": 1
  },
  {
    "text_1": "stop the most recent stopwatch and start this one . time is accumulated if the stopwatch is already registered .",
    "text_2": "public static void switch Timing ( String next Phase ) { stop Most Recent Timer ( ) ; start Timing ( next Phase ) ; }",
    "label": 1
  },
  {
    "text_1": "paints menu window ' s caption . can be overriden for popup menus and tear - off menus . default implementation does nothing",
    "text_2": "protected void paint Caption ( Graphics g , Rectangle rect ) { String s = get Target Label ( ) ; if ( s . equals ( STRING ) ) { return ; } g . set Font ( get Target Font ( ) ) ; Font Metrics fm = g . get Font Metrics ( ) ; String str = get Target Label ( ) ; int width = fm . string Width ( str ) ; int tex tx = rect . x + ( rect . width - width ) / NUM ; int tex ty = rect . y + CAPTION MARGIN TOP + fm . get Ascent ( ) ; int se py = rect . y + rect . height - CAPTION SEPARATOR HEIGHT / NUM ; g . set Color ( is Target Enabled ( ) ? get Foreground Color ( ) : get Disabled Color ( ) ) ; g . draw String ( s , tex tx , tex ty ) ; draw NUM D Rect ( g , rect . x , se py , rect . width , NUM , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "filters the seed list using the current fetch filters , preventing any non - valid seed from being accessed .",
    "text_2": "private void fetch Filter Seeds ( ) { if ( seed List = = null | | seed List . is Empty ( ) ) { return ; } for ( Iterator < URI > it = seed List . iterator ( ) ; it . has Next ( ) ; ) { URI seed = it . next ( ) ; for ( Fetch Filter filter : controller . get Fetch Filters ( ) ) { Fetch Status filter Reason = filter . check Filter ( seed ) ; if ( filter Reason ! = Fetch Status . VALID ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + seed + STRING + filter Reason ) ; } it . remove ( ) ; break ; } } } }",
    "label": 1
  },
  {
    "text_1": "clears the password by overwriting it .",
    "text_2": "public final void clear Password ( ) { Arrays . fill ( password , STRING ) ; password = null ; }",
    "label": 1
  },
  {
    "text_1": "starts or continues a read from the data source .",
    "text_2": "private int read From Data Source ( byte [ ] target , int offset , int length , int bytes Already Read , boolean allow End Of Input ) throws Interrupted Exception , IO Exception { if ( Thread . interrupted ( ) ) { throw new Interrupted Exception ( ) ; } int bytes Read = data Source . read ( target , offset + bytes Already Read , length - bytes Already Read ) ; if ( bytes Read = = C . RESULT END OF INPUT ) { if ( bytes Already Read = = NUM & & allow End Of Input ) { return C . RESULT END OF INPUT ; } throw new EOF Exception ( ) ; } return bytes Already Read + bytes Read ; }",
    "label": 1
  },
  {
    "text_1": "adds an element to the queue .",
    "text_2": "@ Override public boolean add ( E o ) { if ( null = = o ) { throw new Null Pointer Exception ( ) ; } if ( offer ( o ) ) { return BOOL ; } throw new Illegal State Exception ( ) ; }",
    "label": 1
  },
  {
    "text_1": "simulates rolling a dice with 100 sides .",
    "text_2": "public static int roll NUM D NUM 00 ( ) { return rand . next Int ( NUM ) + NUM ; }",
    "label": 1
  },
  {
    "text_1": "optimize our representation and our subqueries representations",
    "text_2": "@ Override public Query rewrite ( Index Reader reader ) throws IO Exception { if ( disjuncts . length = = NUM ) { return disjuncts [ NUM ] ; } boolean actually Rewritten = BOOL ; List < Query > rewritten Dis juncts = new Array List < > ( ) ; for ( Query sub : disjuncts ) { Query rewritten Sub = sub . rewrite ( reader ) ; actually Rewritten | = rewritten Sub ! = sub ; rewritten Dis juncts . add ( rewritten Sub ) ; } if ( actually Rewritten ) { return new Disjunction Max Query ( rewritten Dis juncts , tie Breaker Multiplier ) ; } return super . rewrite ( reader ) ; }",
    "label": 1
  },
  {
    "text_1": "construct a vector from part of a array .",
    "text_2": "public Array Real Vector ( double [ ] d , int pos , int size ) throws Math Illegal Argument Exception , Null Argument Exception { if ( d = = null ) { throw new Null Argument Exception ( ) ; } if ( d . length < pos + size ) { throw new Math Illegal Argument Exception ( Localized Core Formats . NUMBER TOO LARGE , pos + size , d . length ) ; } data = new double [ size ] ; System . arraycopy ( d , pos , data , NUM , size ) ; }",
    "label": 1
  },
  {
    "text_1": "remove all white spaces follow d by whitespaces",
    "text_2": "public static String suppress White Space ( String str ) { int len = str . length ( ) ; String Builder sb = new String Builder ( len ) ; char c ; char buffer = NUM ; for ( int i = NUM ; i < len ; i + + ) { c = str . char At ( i ) ; if ( c = = STRING | | c = = STRING ) buffer = STRING ; else if ( is White Space ( c ) ) { if ( buffer = = NUM ) buffer = c ; } else { if ( buffer ! = NUM ) { sb . append ( buffer ) ; buffer = NUM ; } sb . append ( c ) ; } } if ( buffer ! = NUM ) sb . append ( buffer ) ; return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "used to communicate a progress update between a plugin tool and the main whitebox user interface .",
    "text_2": "private void update Progress ( String progress Label , int progress ) { if ( my Host ! = null & & ( ( progress ! = previous Progress ) | | ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }",
    "label": 1
  },
  {
    "text_1": "loads a cost matrix in the old format from a reader . adapted from code once sitting in instances . java",
    "text_2": "public void read Old Format ( Reader reader ) throws Exception { Stream Tokenizer tokenizer ; int current Token ; double first Index , second Index , weight ; tokenizer = new Stream Tokenizer ( reader ) ; initialize ( ) ; tokenizer . comment Char ( STRING ) ; tokenizer . eol Is Significant ( BOOL ) ; while ( Stream Tokenizer . TT EOF ! = ( current Token = tokenizer . next Token ( ) ) ) { if ( current Token = = Stream Tokenizer . TT EOL ) { continue ; } if ( current Token ! = Stream Tokenizer . TT NUMBER ) { throw new Exception ( STRING + STRING ) ; } first Index = tokenizer . nval ; if ( ! Utils . eq ( ( int ) first Index , first Index ) ) { throw new Exception ( STRING + STRING ) ; } if ( ( int ) first Index > = size ( ) ) { throw new Exception ( STRING ) ; } if ( Stream Tokenizer . TT EOF = = ( current Token = tokenizer . next Token ( ) ) ) { throw new Exception ( STRING ) ; } if ( current Token = = Stream Tokenizer . TT EOL ) { throw new Exception ( STRING ) ; } if ( current Token ! = Stream Tokenizer . TT NUMBER ) { throw new Exception ( STRING + STRING ) ; } second Index = tokenizer . nval ; if ( ! Utils . eq ( ( int ) second Index , second Index ) ) { throw new Exception ( STRING + STRING ) ; } if ( ( int ) second Index > = size ( ) ) { throw new Exception ( STRING ) ; } if ( ( int ) second Index = = ( int ) first Index ) { throw new Exception ( STRING ) ; } if ( Stream Tokenizer . TT EOF = = ( current Token = tokenizer . next Token ( ) ) ) { throw new Exception ( STRING ) ; } if ( current Token = = Stream Tokenizer . TT EOL ) { throw new Exception ( STRING ) ; } if ( current Token ! = Stream Tokenizer . TT NUMBER ) { throw new Exception ( STRING + STRING ) ; } weight = tokenizer . nval ; if ( ! Utils . gr ( weight , NUM ) ) { throw new Exception ( STRING ) ; } set Cell ( ( int ) first Index , ( int ) second Index , new Double ( weight ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "the address above which program text can run .",
    "text_2": "public long start code ( ) { return Long . parse Long ( fields [ NUM ] ) ; }",
    "label": 1
  },
  {
    "text_1": "clear the list of attribute specifications",
    "text_2": "public void clear Attribute Specs ( ) { if ( m attribute Specs = = null ) { m attribute Specs = new Array List < Attribute Spec > ( ) ; } m attribute Specs . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a data object to be associated with a newly created shape .",
    "text_2": "public Object create Shape Data ( Shape shape ) { return null ; }",
    "label": 1
  },
  {
    "text_1": "check that the result set row count matches .",
    "text_2": "protected void assert Result Row Count ( int expected , Result Set rs ) throws SQL Exception { int i = NUM ; while ( rs . next ( ) ) { i + + ; } assert Equals ( expected , i ) ; }",
    "label": 1
  },
  {
    "text_1": "checks whether the given server version string is a mysql enterprise edition",
    "text_2": "public static boolean is Enterprise Edition ( String server Version ) { return server Version . contains ( STRING ) | | server Version . contains ( STRING ) | | server Version . contains ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the criteria from the passed criteria object .",
    "text_2": "public void add Criteria ( Criteria other Criteria ) { if ( other Criteria instanceof Advanced Criteria | | other Criteria instanceof Criterion ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } Map other Map = other Criteria . get Values ( ) ; Set other Keys = other Map . key Set ( ) ; for ( Iterator i = other Keys . iterator ( ) ; i . has Next ( ) ; ) { String field = ( String ) i . next ( ) ; Object value = other Map . get ( field ) ; JSO Helper . set Attribute ( js Obj , field , value ) ; } }",
    "label": 1
  },
  {
    "text_1": "initializes cs rs . spring profiles can be configured with a program arguments - - spring . profiles . active = your - active - profile",
    "text_2": "@ Post Construct public void init Application ( ) throws IO Exception { if ( env . get Active Profiles ( ) . length = = NUM ) { log . warn ( STRING ) ; } else { log . info ( STRING , Arrays . to String ( env . get Active Profiles ( ) ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "introduced in dom level 2 . removes an attribute by local name and namespace uri . if the removed attribute has a default value it is immediately replaced . the replacing attribute has the same namespace uri and local name , as well as the original prefix .",
    "text_2": "@ Override public void remove Attribute NS ( String namespace URI , String local Name ) { if ( owner Document . error Checking & & is Read Only ( ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . NO MODIFICATION ALLOWED ERR , msg ) ; } if ( needs Sync Data ( ) ) { synchronize Data ( ) ; } if ( attributes = = null ) { return ; } attributes . safe Remove Named Item NS ( namespace URI , local Name ) ; }",
    "label": 1
  },
  {
    "text_1": "search the provided pattern and get the c standard date / time formatting rules and convert them to the java equivalent .",
    "text_2": "protected String convert Date Format ( String pattern ) { boolean inside = BOOL ; boolean mark = BOOL ; boolean modified Command = BOOL ; String Builder buf = new String Builder ( ) ; for ( int i = NUM ; i < pattern . length ( ) ; i + + ) { char c = pattern . char At ( i ) ; if ( c = = STRING & & ! mark ) { mark = BOOL ; } else { if ( mark ) { if ( modified Command ) { modified Command = BOOL ; mark = BOOL ; } else { inside = translate Command ( buf , pattern , i , inside ) ; if ( c = = STRING | | c = = STRING ) { modified Command = BOOL ; } else { mark = BOOL ; } } } else { if ( ! inside & & c ! = STRING ) { buf . append ( STRING ) ; inside = BOOL ; } buf . append ( c ) ; } } } if ( buf . length ( ) > NUM ) { char last Char = buf . char At ( buf . length ( ) - NUM ) ; if ( last Char ! = STRING & & inside ) { buf . append ( STRING ) ; } } return buf . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "saves ' the bitmap ' into folder ' the folder ' with the name ' the imagename '",
    "text_2": "public String put Image ( String the Folder , String the Image Name , Bitmap the Bitmap ) { if ( the Folder = = null | | the Image Name = = null | | the Bitmap = = null ) return null ; this . DEFAULT APP IMAGE DATA DIRECTORY = the Folder ; String m Full Path = setup Full Path ( the Image Name ) ; if ( ! m Full Path . equals ( STRING ) ) { last Image Path = m Full Path ; save Bitmap ( m Full Path , the Bitmap ) ; } return m Full Path ; }",
    "label": 1
  },
  {
    "text_1": "calculates the two endpoints of the line segment connecting two given non - overlapping rectangles . ( should give back null for overlapping rectangles but doesn ' t always . . . )",
    "text_2": "private Point Pair calculate Edge ( Component comp NUM , Component comp NUM ) { Rectangle r NUM = comp NUM . get Bounds ( ) ; Rectangle r NUM = comp NUM . get Bounds ( ) ; Point c NUM = new Point ( ( int ) ( r NUM . x + r NUM . width / NUM ) , ( int ) ( r NUM . y + r NUM . height / NUM ) ) ; Point c NUM = new Point ( ( int ) ( r NUM . x + r NUM . width / NUM ) , ( int ) ( r NUM . y + r NUM . height / NUM ) ) ; double angle = Math . atan NUM ( c NUM . y - c NUM . y , c NUM . x - c NUM . x ) ; angle + = Math . PI / NUM ; Point d = new Point ( ( int ) ( offset * Math . cos ( angle ) ) , ( int ) ( offset * Math . sin ( angle ) ) ) ; c NUM . translate ( d . x , d . y ) ; c NUM . translate ( d . x , d . y ) ; Point p NUM = get Boundary Intersection ( comp NUM , c NUM , c NUM ) ; Point p NUM = get Boundary Intersection ( comp NUM , c NUM , c NUM ) ; if ( ( p NUM = = null ) | | ( p NUM = = null ) ) { c NUM = new Point ( ( int ) ( r NUM . x + r NUM . width / NUM ) , ( int ) ( r NUM . y + r NUM . height / NUM ) ) ; c NUM = new Point ( ( int ) ( r NUM . x + r NUM . width / NUM ) , ( int ) ( r NUM . y + r NUM . height / NUM ) ) ; p NUM = get Boundary Intersection ( comp NUM , c NUM , c NUM ) ; p NUM = get Boundary Intersection ( comp NUM , c NUM , c NUM ) ; } if ( ( p NUM = = null ) | | ( p NUM = = null ) ) { return null ; } return new Point Pair ( p NUM , p NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "compute the posterior distribution using optimized parameter values and the testing instance .",
    "text_2": "private double [ ] evaluate Probability ( double [ ] data ) { double [ ] prob = new double [ m Num Classes ] , v = new double [ m Num Classes ] ; for ( int j = NUM ; j < m Num Classes - NUM ; j + + ) { for ( int k = NUM ; k < = m Num Predictors ; k + + ) { v [ j ] + = m Par [ k ] [ j ] * data [ k ] ; } } v [ m Num Classes - NUM ] = NUM ; for ( int m = NUM ; m < m Num Classes ; m + + ) { double sum = NUM ; for ( int n = NUM ; n < m Num Classes - NUM ; n + + ) { sum + = Math . exp ( v [ n ] - v [ m ] ) ; } prob [ m ] = NUM / ( sum + Math . exp ( - v [ m ] ) ) ; } return prob ; }",
    "label": 1
  },
  {
    "text_1": "test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized . the task timeout is non - zero , so long - running tasks will be cancelled . this test st res ses the logic in lock ( ) that is responsible for backing out a lock requests when a task is cancelled either while awaiting its locks or while running .",
    "text_2": "public void test single Resource Locking serialized waits For high Concurrency task Timeout ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int n tasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . N TASKS , STRING + n tasks ) ; properties . set Property ( Test Options . N RESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . TASK TIMEOUT , STRING ) ; properties . set Property ( Test Options . PRE DECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , NUM , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , NUM , Integer . parse Int ( result . get ( STRING ) ) ) ; final int n cancel = Integer . parse Int ( result . get ( STRING ) ) ; assert True ( STRING , n cancel > NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "indicates if this stream is ready to be read .",
    "text_2": "public boolean ready ( ) throws IO Exception { if ( input = = null ) throw new IO Exception ( STRING ) ; if ( index = = input . length ( ) ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "whether the passed in option is currently set .",
    "text_2": "public boolean is Set ( final OPTION option ) { return options = = null ? BOOL : options . contains ( option ) ; }",
    "label": 1
  },
  {
    "text_1": "check if given path is a file and if it exists",
    "text_2": "public static boolean is File Exists ( final String path ) { if ( Text Utils . is Empty ( path ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } final File file To Check = new File ( path ) ; return file To Check . exists ( ) & & ! file To Check . is Directory ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks the current variations parameters associated with the active group as well as the chrome preference to determine if the service is enabled .",
    "text_2": "public static boolean is Enabled ( ) { if ( s Enabled = = null ) { s Enabled = detect Enabled ( ) ; } return s Enabled . boolean Value ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns highest node . this node might not be in range , so most usages need to check bounds .",
    "text_2": "private Concurrent Skip List Map . Node < K , V > hi Node ( ) { if ( hi = = null ) return m . find Last ( ) ; else if ( hi Inclusive ) return m . find Near ( hi , LT | EQ ) ; else return m . find Near ( hi , LT ) ; }",
    "label": 1
  },
  {
    "text_1": "execute the valuation effective date",
    "text_2": "protected String do It ( ) throws Exception { setup ( ) ; for ( M Warehouse warehouse : ware houses ) for ( M Cost Type cost Type : cost Types ) for ( M Cost Element cost Element : cost Elements ) for ( int product Id : products ) generate Inventory Value ( product Id , cost Type . get M Cost Type ID ( ) , cost Element . get M Cost Element ID ( ) , warehouse . get M Warehouse ID ( ) ) ; pstmt . execute Batch ( ) ; commit Ex ( ) ; DB . close ( pstmt ) ; DB . execute Update ( STRING + DB . TO DATE ( p Date Value ) + STRING , get AD P Instance ID ( ) , get Trx Name ( ) ) ; return STRING + count ; }",
    "label": 1
  },
  {
    "text_1": "tries to occupy the onclick enab ler .",
    "text_2": "public static boolean occup y ( int wait Ms ) { if ( occupied Until ! = null & & occupied Until . after ( new Date ( ) ) ) { return BOOL ; } occupied Until = Date Utils . add Milliseconds ( new Date ( ) , wait Ms ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "adds an undo point to the undo history , if the undo support is enabled",
    "text_2": "@ Override public void add Undo Point ( ) { File temp File ; Object Output Stream oos ; if ( ! is Undo Enabled ( ) ) { return ; } if ( get Instances ( ) ! = null ) { try { temp File = File . create Temp File ( STRING , null ) ; temp File . delete On Exit ( ) ; oos = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( temp File ) ) ) ; oos . write Object ( get Instances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m Undo List . add ( temp File ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "check the size of the array and increase if needed",
    "text_2": "private void check Size ( final int i ) { if ( i > = max size ) { final int old size = max size ; max size + = increment size ; if ( max size < = i ) { max size = i + increment size + NUM ; } final int [ ] temp = items ; items = new int [ max size ] ; System . arraycopy ( temp , NUM , items , NUM , old size ) ; increment size = increment Size ( increment size ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a string representation of this http state .",
    "text_2": "@ Override public synchronized String to String ( ) { final String Buffer sb Result = new String Buffer ( ) ; sb Result . append ( STRING ) ; sb Result . append ( get Credentials String Representation ( proxy Cred ) ) ; sb Result . append ( STRING ) ; sb Result . append ( get Credentials String Representation ( cred Map ) ) ; sb Result . append ( STRING ) ; sb Result . append ( get Cookies String Representation ( cookies ) ) ; sb Result . append ( STRING ) ; final String str Result = sb Result . to String ( ) ; return str Result ; }",
    "label": 1
  },
  {
    "text_1": "undo the last undoable action .",
    "text_2": "public void undo ( ) { if ( ! undo Stack . is Empty ( ) ) { Undoable Action last Event = undo Stack . pop ( ) ; last Event . undo ( ) ; redo Stack . push ( last Event ) ; } }",
    "label": 1
  },
  {
    "text_1": "closes ' closeable ' , ignoring any checked exceptions . does nothing if ' closeable ' is null .",
    "text_2": "public static void close Quietly ( Auto Closeable closeable ) { if ( closeable ! = null ) { try { closeable . close ( ) ; } catch ( Runtime Exception re thrown ) { throw re thrown ; } catch ( Exception ignored ) { } } }",
    "label": 1
  },
  {
    "text_1": "return the type of normalization used for this regression",
    "text_2": "private static Normalization determine Normalization ( Element model ) { Normalization norm Method = Normalization . NONE ; String norm Name = model . get Attribute ( STRING ) ; if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . SIMPLE MAX ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . SOFT MAX ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . LOG IT ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . PRO BIT ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . C LOG LOG ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . EXP ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . LOG LOG ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . CA UCH IT ; } return norm Method ; }",
    "label": 1
  },
  {
    "text_1": "transforms a cidr formatted mask into a regular network mask",
    "text_2": "public static String cidr Mask To Net Mask ( String cidr Mask ) { if ( cidr Mask = = null ) { return null ; } int cidr Mask Value = NUM ; try { cidr Mask Value = Integer . parse Int ( cidr Mask ) ; } catch ( Number Format Exception e ) { return null ; } int cidr Mask Full = NUM < < ( NUM - cidr Mask Value ) ; int cidr Mask Bits NUM = cidr Mask Full > > NUM & NUM ; int cidr Mask Bits NUM = cidr Mask Full > > NUM & NUM ; int cidr Mask Bits NUM = cidr Mask Full > > NUM & NUM ; int cidr Mask Bits NUM = cidr Mask Full > > NUM & NUM ; String Buffer net Mask Buf = new String Buffer ( ) ; net Mask Buf . append ( cidr Mask Bits NUM ) ; net Mask Buf . append ( STRING ) ; net Mask Buf . append ( cidr Mask Bits NUM ) ; net Mask Buf . append ( STRING ) ; net Mask Buf . append ( cidr Mask Bits NUM ) ; net Mask Buf . append ( STRING ) ; net Mask Buf . append ( cidr Mask Bits NUM ) ; return net Mask Buf . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "this is part of start ( ) process . busy ton eur itype must not empty . empty means do not play . return false to indicate play tone failed and should be stop ( ) immediately otherwise , it will stop ( ) after a tone completed .",
    "text_2": "public boolean start Bu sy tone ( final String bu sy tone Uri Type ) { if ( bu sy tone Uri Type . is Empty ( ) ) { return BOOL ; } try { Log . d ( TAG , STRING + bu sy tone Uri Type ) ; if ( m Bu sy tone ! = null ) { if ( m Bu sy tone . is Playing ( ) ) { Log . d ( TAG , STRING ) ; return BOOL ; } else { stop Bu sy tone ( ) ; } } Uri bu sy tone Uri ; Map data = new Hash Map < String , Object > ( ) ; data . put ( STRING , STRING ) ; if ( bu sy tone Uri Type . equals ( STRING ) ) { m Bu sy tone = new my Tone Generator ( my Tone Generator . BUSY ) ; m Bu sy tone . start Play ( data ) ; return BOOL ; } else { bu sy tone Uri = get Bu sy tone Uri ( bu sy tone Uri Type ) ; if ( bu sy tone Uri = = null ) { Log . d ( TAG , STRING ) ; return BOOL ; } } m Bu sy tone = new my Media Player ( ) ; data . put ( STRING , bu sy tone Uri ) ; data . put ( STRING , BOOL ) ; data . put ( STRING , Audio Manager . STREAM VOICE CALL ) ; set Media Player Events ( ( Media Player ) m Bu sy tone , STRING ) ; m Bu sy tone . start Play ( data ) ; return BOOL ; } catch ( Exception e ) { Log . d ( TAG , STRING ) ; Log . d ( TAG , e . get Message ( ) ) ; return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "the time separator is defined in the unicode cldr and cannot be supposed to be \" : \" . see http : / / unicode . org / cldr / trac / browser / trunk / common / main we pass the correct \" skeleton \" depending on 12 or 24 hours view and then extract the separator as the character which is just after the hour marker in the returned pattern .",
    "text_2": "private void update Header Separator ( ) { final String best Date Time Pattern = Date Format Utils . get Best Date Time Pattern ( m Current Locale , ( m Is NUM Hour View ) ? STRING : STRING ) ; final String separator Text ; final char [ ] hour Formats = { STRING , STRING , STRING , STRING } ; int h Index = last Index Of Any ( best Date Time Pattern , hour Formats ) ; if ( h Index = = - NUM ) { separator Text = STRING ; } else { separator Text = Character . to String ( best Date Time Pattern . char At ( h Index + NUM ) ) ; } m Separator View . set Text ( separator Text ) ; }",
    "label": 1
  },
  {
    "text_1": "valueof ( long val ) : convert long . max value to a biginteger .",
    "text_2": "public void test Value Of Long Max ( ) { long long Val = Long . MAX VALUE ; Big Integer a Number = Big Integer . value Of ( long Val ) ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "extracts port spac ings from the xml element .",
    "text_2": "@ Override public void execution Unit Imported ( final Execution Unit process , final Element element ) { Node List children = element . get Child Nodes ( ) ; children = element . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i + + ) { Node child = children . item ( i ) ; if ( child instanceof Element ) { Element background Element = ( Element ) child ; if ( XML TAG BACKGROUND . equals ( background Element . get Tag Name ( ) ) ) { String x Str = background Element . get Attribute ( XML ATTRIBUTE X POSITION ) ; String y Str = background Element . get Attribute ( XML ATTRIBUTE Y POSITION ) ; String w Str = background Element . get Attribute ( XML ATTRIBUTE WIDTH ) ; String h Str = background Element . get Attribute ( XML ATTRIBUTE HEIGHT ) ; String img Loc Str = background Element . get Attribute ( XML ATTRIBUTE LOCATION ) ; try { int x Loc = Integer . parse Int ( x Str ) ; int y Loc = Integer . parse Int ( y Str ) ; int w Loc = Integer . parse Int ( w Str ) ; int h Loc = Integer . parse Int ( h Str ) ; Process Background Image bg Img = new Process Background Image ( x Loc , y Loc , w Loc , h Loc , img Loc Str , process ) ; set Background Image ( bg Img ) ; } catch ( Null Pointer Exception | Illegal Argument Exception e ) { } } } } }",
    "label": 1
  },
  {
    "text_1": "creates a new instance of the context .",
    "text_2": "Date Time Parse Context ( Date Time Formatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new Parsed ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "check if any package in the list is installed",
    "text_2": "private boolean is Any Package From List Installed ( List < String > packages ) { boolean result = BOOL ; Package Manager pm = m Context . get Package Manager ( ) ; for ( String package Name : packages ) { try { pm . get Package Info ( package Name , NUM ) ; Q Log . e ( package Name + STRING ) ; result = BOOL ; } catch ( Package Manager . Name Not Found Exception e ) { continue ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "read words from the given reader and count their occurrences .",
    "text_2": "public void train ( Reader a Reader ) throws IO Exception { Buffered Reader in = new Buffered Reader ( a Reader ) ; String line = in . read Line ( ) ; while ( line ! = null ) { Matcher m = WORD PATTERN . matcher ( line . to Lower Case ( ) ) ; while ( m . find ( ) ) { String word = m . group ( ) ; Atomic Integer count = n Words . get ( word ) ; if ( count = = null ) { count = new Atomic Integer ( NUM ) ; n Words . put ( word , count ) ; } count . increment And Get ( ) ; } line = in . read Line ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "sets the state of the various controls based on the progress info object sent from the downloader service .",
    "text_2": "@ Override public void on Download Progress ( Download Progress Info progress ) { m Average Speed . set Text ( get String ( R . string . kil ob ytes per second , Helpers . get Speed String ( progress . m Current Speed ) ) ) ; m Time Remaining . set Text ( get String ( R . string . time remaining , Helpers . get Time Remaining ( progress . m Time Remaining ) ) ) ; progress . m Overall Total = progress . m Overall Total ; m PB . set Max ( ( int ) ( progress . m Overall Total > > NUM ) ) ; m PB . set Progress ( ( int ) ( progress . m Overall Progress > > NUM ) ) ; m Progress Percent . set Text ( Long . to String ( progress . m Overall Progress * NUM / progress . m Overall Total ) + STRING ) ; m Progress Fraction . set Text ( Helpers . get Download Progress String ( progress . m Overall Progress , progress . m Overall Total ) ) ; }",
    "label": 1
  },
  {
    "text_1": "a static method that uses the natural log to obtain log to base 10 . this is required for the linear auto calibrate but will also be used by a derived class giving a log transformed axis .",
    "text_2": "static public double log NUM ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the recent items from the props file .",
    "text_2": "protected void read Props ( ) { int count ; Properties props ; int i ; String item Str ; T item ; m Ignore Changes = BOOL ; props = load Props ( ) ; count = Integer . parse Int ( props . get Property ( expand ( get Count Key ( ) ) , STRING ) ) ; m Recent Items . clear ( ) ; for ( i = count - NUM ; i > = NUM ; i - - ) { item Str = props . get Property ( get Item Prefix ( ) + i , STRING ) ; if ( item Str . length ( ) > NUM ) { item = from String ( item Str ) ; if ( check ( item ) ) add Recent Item ( item ) ; } } m Ignore Changes = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "returns the shortest suffix of input that is matched , or null if no match exists .",
    "text_2": "public String shortest Match ( String input ) { Trie Node node = root ; for ( int i = input . length ( ) - NUM ; i > = NUM ; i - - ) { node = node . get Child ( input . char At ( i ) ) ; if ( node = = null ) return null ; if ( node . is Terminal ( ) ) return input . substring ( i ) ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "removes an entire channel from our memory of users .",
    "text_2": "private final void remove Channel ( String channel ) { channel = channel . to Lower Case ( ) ; synchronized ( channels ) { channels . remove ( channel ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns true if the underlying resource has changed .",
    "text_2": "public boolean log Modified ( Logger log ) { if ( is Modified ( ) ) { log . info ( class Name + STRING ) ; return BOOL ; } else return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "builds a value source from a given string and a given source type",
    "text_2": "private static Value Source build Source Tree ( Index Schema schema , String expression , int source Type ) { int expression Type = get Source Type ( expression ) ; if ( source Type ! = FIELD TYPE & & expression Type ! = FIELD TYPE & & expression Type ! = FILTER TYPE & & expression Type ! = source Type ) { return null ; } switch ( expression Type ) { case NUMBER TYPE : return build Numeric Source ( schema , expression ) ; case DATE TYPE : return build Date Source ( schema , expression ) ; case STRING TYPE : return build String Source ( schema , expression ) ; case FIELD TYPE : return build Field Source ( schema , expression , source Type ) ; case FILTER TYPE : return build Filter Source ( schema , expression . substring ( expression . index Of ( STRING ) + NUM , expression . last Index Of ( STRING ) ) , source Type ) ; default : throw new Solr Exception ( Error Code . BAD REQUEST , expression + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "delete volume mirror and the destination volume .",
    "text_2": "public Driver Task delete Volume Mirror ( Volume Mirror mirror ) { LOG . info ( STRING , mirror ) ; Dell SC Driver Task task = new Dell SC Driver Task ( STRING ) ; try { Storage Center API api = connection Manager . get Connection ( mirror . get Storage System Id ( ) ) ; Sc Copy Mirror Migrate cmm = api . get Mirror ( mirror . get Native Id ( ) ) ; api . delete Mirror ( cmm . instance Id ) ; api . delete Volume ( cmm . destination Volume . instance Id ) ; task . set Status ( Task Status . READY ) ; } catch ( Storage Center API Exception | Dell SC Driver Exception dex ) { String error = String . format ( STRING , mirror . get Native Id ( ) , dex ) ; LOG . error ( error ) ; task . set Failed ( error ) ; } return task ; }",
    "label": 1
  },
  {
    "text_1": "adds a single ban with the current time .",
    "text_2": "public synchronized void add Ban ( long duration , String reason , String id ) { add Line ( new Ban Message ( System . current Time Millis ( ) , duration , reason , id ) ) ; }",
    "label": 1
  },
  {
    "text_1": "used to uniquely identify the session",
    "text_2": "@ Override public UUID session Id ( ) { if ( session Id = = null ) session Id = UUID . random UUID ( ) ; return session Id ; }",
    "label": 1
  },
  {
    "text_1": "add a contact uri to the list of contacts .",
    "text_2": "public Registration Builder add Contact ( URI contact ) { contacts . add ( contact ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "flatten an object ' s value into an xmlserializer . the value can later be read back with read this valu exml ( ) . currently supported value types are : null , string , integer , long , float , double boolean , map , list .",
    "text_2": "public static final void write Value Xml ( Object v , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { String type Str ; if ( v = = null ) { out . start Tag ( null , STRING ) ; if ( name ! = null ) { out . attribute ( null , STRING , name ) ; } out . end Tag ( null , STRING ) ; return ; } else if ( v instanceof String ) { out . start Tag ( null , STRING ) ; if ( name ! = null ) { out . attribute ( null , STRING , name ) ; } out . text ( v . to String ( ) ) ; out . end Tag ( null , STRING ) ; return ; } else if ( v instanceof Integer ) { type Str = STRING ; } else if ( v instanceof Long ) { type Str = STRING ; } else if ( v instanceof Float ) { type Str = STRING ; } else if ( v instanceof Double ) { type Str = STRING ; } else if ( v instanceof Boolean ) { type Str = STRING ; } else if ( v instanceof byte [ ] ) { write Byte Array Xml ( ( byte [ ] ) v , name , out ) ; return ; } else if ( v instanceof int [ ] ) { write Int Array Xml ( ( int [ ] ) v , name , out ) ; return ; } else if ( v instanceof Map ) { write Map Xml ( ( Map ) v , name , out ) ; return ; } else if ( v instanceof List ) { write List Xml ( ( List ) v , name , out ) ; return ; } else if ( v instanceof Set ) { write Set Xml ( ( Set ) v , name , out ) ; return ; } else if ( v instanceof Char Sequence ) { out . start Tag ( null , STRING ) ; if ( name ! = null ) { out . attribute ( null , STRING , name ) ; } out . text ( v . to String ( ) ) ; out . end Tag ( null , STRING ) ; return ; } else { throw new Runtime Exception ( STRING + v ) ; } out . start Tag ( null , type Str ) ; if ( name ! = null ) { out . attribute ( null , STRING , name ) ; } out . attribute ( null , STRING , v . to String ( ) ) ; out . end Tag ( null , type Str ) ; }",
    "label": 1
  },
  {
    "text_1": "check if two values are equal , and if not throw an exception .",
    "text_2": "protected void assert Equals ( Integer expected , Integer actual ) { if ( expected = = null | | actual = = null ) { if ( expected ! = actual ) { assert Equals ( STRING + expected , STRING + actual ) ; } } else { assert Equals ( expected . int Value ( ) , actual . int Value ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "restart a service on remote node",
    "text_2": "public void remote Restart Coordinator ( String node Id , String type ) throws Local Repository Exception { final String prefix = String . format ( STRING , type , node Id ) ; log . debug ( prefix ) ; final String [ ] cmd = { SYST OOL CMD , SYST OOL REMOTE SYST OOL , node Id , SYST OOL RESTART COORDIN ATOR , type } ; final Exec . Result result = Exec . sudo ( SYST OOL TIMEOUT , cmd ) ; check Failure ( result , prefix ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a listener to the set of listeners that are sent update events through the life of an animation . this method is called on all listeners for every frame of the animation , after the values for the animation have been calculated .",
    "text_2": "public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners = = null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "register to start receiving callbacks for bluetooth events .",
    "text_2": "void register Callback ( Bluetooth Callback callback ) { synchronized ( m Callbacks ) { m Callbacks . add ( callback ) ; } }",
    "label": 1
  },
  {
    "text_1": "create xml element with utf 8 encoded xml document .",
    "text_2": "public Xml Element ( byte [ ] encoded Document ) { if ( encoded Document = = null ) throw new Illegal Argument Exception ( STRING ) ; this . encoded = encoded Document . clone ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a member to the group",
    "text_2": "public void add Member ( String player Name ) { open Inv ites . remove ( player Name ) ; members And Last Seen . put ( player Name , Long . value Of ( System . current Time Millis ( ) ) ) ; if ( leader = = null ) { leader = player Name ; } send Group Change Event ( ) ; }",
    "label": 1
  },
  {
    "text_1": "once used observer add to observer controller . if observer notify will be removed .",
    "text_2": "public void attach ( Action Observer observer ) { observer . make One Time Use ( ) ; lock . lock ( ) ; try { once Used Observers . add ( observer ) ; } finally { lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "any outstanding context from the exception provided will be added to this exception . the context in the exception provided will be cleared .",
    "text_2": "private void ass imil ate Context ( Nesting Exception nesting Exception ) { Enumeration < Exception Context > enum Ex ep tions = nesting Exception . get Exception Contexts ( ) ; if ( enum Ex ep tions . has More Elements ( ) ) { while ( enum Ex ep tions . has More Elements ( ) ) { add Exception Context ( enum Ex ep tions . next Element ( ) ) ; } nesting Exception . clear Contexts ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates an empty extended properties object .",
    "text_2": "public Configuration ( ) { super ( ) ; }",
    "label": 1
  },
  {
    "text_1": "return the objectname for the system member mbean representing the specified distributed member or null if the member is not found .",
    "text_2": "public Object Name manage System Member ( Distributed Member distributed Member ) throws Admin Exception , Malformed Object Name Exception { try { System Member member = lookup System Member ( distributed Member ) ; if ( member = = null ) return null ; System Member Jmx Impl jmx = ( System Member Jmx Impl ) member ; Object Name oname = new Object Name ( jmx . get M Bean Name ( ) ) ; return oname ; } catch ( Admin Exception e ) { logger . warn ( e . get Message ( ) , e ) ; throw e ; } catch ( Runtime Exception e ) { logger . warn ( e . get Message ( ) , e ) ; throw e ; } catch ( Virtual Machine Error err ) { System Failure . initiate Failure ( err ) ; throw err ; } catch ( Error e ) { System Failure . check Failure ( ) ; logger . error ( e . get Message ( ) , e ) ; throw e ; } }",
    "label": 1
  },
  {
    "text_1": "the fields of the named entity to order the resultset by ; optionally add a \" asc \" for ascending or \" desc \" for descending note : each successive call to any of the orderby ( . . . ) methods will replace the currently set orderby fields for the query .",
    "text_2": "public Entity Query order By ( String . . . fields ) { this . order By = Arrays . as List ( fields ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "attempts to configure each interface contained in the failed interfaces list , removing it from the list if configuration succeeds . the null value is used to indicate the default network interface .",
    "text_2": "private void retry Failed Interfaces ( ) { for ( Iterator i = failed Interfaces . iterator ( ) ; i . has Next ( ) ; ) { Network Interface nic = ( Network Interface ) i . next ( ) ; try { if ( nic ! = null ) { socket . set Network Interface ( nic ) ; } socket . join Group ( request Addr ) ; i . remove ( ) ; Level l = multicast Interfaces Specified ? Level . INFO : Level . FINE ; if ( logger . is Loggable ( l ) ) { if ( nic ! = null ) { logger . log ( l , STRING , new Object [ ] { nic } ) ; } else { logger . log ( l , STRING ) ; } } } catch ( IO Exception e ) { } } }",
    "label": 1
  },
  {
    "text_1": "split string to chunks by size .",
    "text_2": "String [ ] split ( final String string To Split ) { if ( String Utils . is Not Blank ( string To Split ) ) { int str Lenght = string To Split . length ( ) ; int split Num = str Lenght / chunk Size ; if ( str Lenght % chunk Size > NUM ) { split Num + = NUM ; } String [ ] result = new String [ split Num ] ; for ( int i = NUM ; i < split Num ; i + + ) { int start Pos = i * chunk Size ; int end Pos = start Pos + chunk Size ; if ( end Pos > str Lenght ) { end Pos = str Lenght ; } result [ i ] = string To Split . substring ( start Pos , end Pos ) ; } return result ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "split a gts into multiple gts by cutting in ' quiet zones ' , i . e . intervals of ' quiet period ' or more during which there were no measurements . if ' gts ' has no values or if ' label ' is already part of the labels of ' gts ' , then the resulting list of gts will only contain a clone of ' gts ' .",
    "text_2": "public static List < Geo Time Serie > times plit ( Geo Time Serie gts , long qui et period , int min values , String labelname ) { List < Geo Time Serie > series = new Array List < Geo Time Serie > ( ) ; if ( NUM = = gts . values | | gts . has Label ( labelname ) ) { series . add ( gts . clone ( ) ) ; return series ; } sort ( gts , BOOL ) ; long last tick = gts . ticks [ NUM ] ; int idx = NUM ; int g t sid = NUM ; Geo Time Serie serie = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM ) ; serie . set Name ( gts . get Name ( ) ) ; Map < String , String > labels = new Hash Map < String , String > ( ) ; labels . put All ( gts . get Labels ( ) ) ; labels . put ( labelname , Integer . to String ( g t sid ) ) ; serie . set Labels ( labels ) ; while ( idx < gts . values ) { if ( gts . ticks [ idx ] - last tick > = qui et period ) { if ( serie . values > NUM & & serie . values > = min values ) { series . add ( serie ) ; } serie = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM ) ; serie . set Name ( gts . get Name ( ) ) ; labels = new Hash Map < String , String > ( ) ; labels . put All ( gts . get Labels ( ) ) ; g t sid + + ; labels . put ( labelname , Integer . to String ( g t sid ) ) ; serie . set Labels ( labels ) ; } Object value = GTS Helper . value At Index ( gts , idx ) ; GTS Helper . set Value ( serie , gts . ticks [ idx ] , null ! = gts . locations ? gts . locations [ idx ] : Geo Time Serie . NO LOCATION , null ! = gts . elevations ? gts . elevations [ idx ] : Geo Time Serie . NO ELEVATION , value , BOOL ) ; last tick = gts . ticks [ idx ] ; idx + + ; } if ( serie . values > NUM & & serie . values > = min values ) { series . add ( serie ) ; } return series ; }",
    "label": 1
  },
  {
    "text_1": "returns true if two possibly - null objects are equal .",
    "text_2": "public static boolean equal ( Object a , Object b ) { return a = = b | | ( a ! = null & & a . equals ( b ) ) ; }",
    "label": 1
  },
  {
    "text_1": "runs the test case .",
    "text_2": "public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String bad String ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { bad String = child . substring Data ( NUM , NUM ) ; } catch ( DOM Exception ex ) { success = ( ex . code = = DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }",
    "label": 1
  },
  {
    "text_1": "return a workflow . method for un tag volumes .",
    "text_2": "private Workflow . Method untag Volumes Method ( URI system URI , List < URI > volume UR Is ) { return new Workflow . Method ( STRING , system URI , volume UR Is ) ; }",
    "label": 1
  },
  {
    "text_1": "set tag name and desc field border color based on chosen color .",
    "text_2": "protected void create Dynamic Style For Components ( final Text Field tag Name , final Text Area tag Desc , final String ta reg t Tag Color ) { tag Name . remove Style Name ( SPUI Definitions . TAG NAME ) ; tag Desc . remove Style Name ( SPUI Definitions . TAG DESC ) ; get Target Dynamic Styles ( ta reg t Tag Color ) ; tag Name . add Style Name ( TAG NAME DYNAMIC STYLE ) ; tag Desc . add Style Name ( TAG DESC DYNAMIC STYLE ) ; }",
    "label": 1
  },
  {
    "text_1": "create a dml or py dml script object based on a string .",
    "text_2": "private static Script script From String ( String script String , Script Type script Type ) { return new Script ( script String , script Type ) ; }",
    "label": 1
  },
  {
    "text_1": "this method does nothing .",
    "text_2": "@ Override public void end Prefix Mapping ( String str ) throws SAX Exception { }",
    "label": 1
  },
  {
    "text_1": "computes the result for one input string value .",
    "text_2": "protected double compute ( String value ) { if ( value ! = null ) { try { return Double . parse Double ( value ) ; } catch ( Number Format Exception e ) { if ( POSITIVE INFINITY STRING . equals ( value ) ) { return Double . POSITIVE INFINITY ; } else if ( NEGATIVE INFINITY STRING . equals ( value ) ) { return Double . NEGATIVE INFINITY ; } return Double . Na N ; } } return Double . Na N ; }",
    "label": 1
  },
  {
    "text_1": "used to communicate a progress update between a plugin tool and the main whitebox user interface .",
    "text_2": "private void update Progress ( String progress Label , int progress ) { if ( my Host ! = null & & ( ( progress ! = previous Progress ) | | ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }",
    "label": 1
  },
  {
    "text_1": "put an integer into the given buffer at the given offset as a 3 - byte integer .",
    "text_2": "public static void put NUM Byte Int ( Byte Buffer buffer , int val ) { put NUM Byte Int ( buffer , val , buffer . order ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "prints out a field summary",
    "text_2": "public String to String ( ) { Array List fields = new Array List ( NUM ) ; fields . add ( codebase ) ; fields . add ( policy ) ; fields . add ( classpath ) ; fields . add ( impl Class Name ) ; fields . add ( ( ( server Config Args = = null ) ? null : Arrays . as List ( server Config Args ) ) ) ; fields . add ( life Cycle ) ; fields . add ( service Preparer ) ; return fields . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "tests that if the input does not have z ordinates , neither does the output .",
    "text_2": "public void test Compute Z Na N ( ) { Geometry linear Geom = read ( STRING ) ; Length Indexed Line indexed Line = new Length Indexed Line ( linear Geom ) ; double proj Index = indexed Line . project ( new Coordinate ( NUM , NUM ) ) ; Coordinate proj Pt = indexed Line . extract Point ( proj Index ) ; assert True ( Double . is Na N ( proj Pt . z ) ) ; }",
    "label": 1
  },
  {
    "text_1": "invoked when an action occurs",
    "text_2": "@ Override public void action Performed ( Action Event e ) { Object o ; o = e . get Source ( ) ; if ( o = = m Menu File Open ) { load File ( ) ; } else if ( o = = m Menu File Save ) { save File ( ) ; } else if ( o = = m Menu File Save As ) { save File As ( ) ; } else if ( o = = m Menu File Close ) { close File ( ) ; } else if ( o = = m Menu File Close All ) { close All Files ( ) ; } else if ( o = = m Menu File Properties ) { show Properties ( ) ; } else if ( o = = m Menu File Exit ) { close ( ) ; } else if ( o = = m Menu Edit Undo ) { undo ( ) ; } else if ( o = = m Menu Edit Copy ) { copy Content ( ) ; } else if ( o = = m Menu Edit Search ) { search ( ) ; } else if ( o = = m Menu Edit Clear Search ) { clear Search ( ) ; } else if ( o = = m Menu Edit Delete Attribute ) { delete Attribute ( BOOL ) ; } else if ( o = = m Menu Edit Delete Attributes ) { delete Attribute ( BOOL ) ; } else if ( o = = m Menu Edit Rename Attribute ) { rename Attribute ( ) ; } else if ( o = = m Menu Edit Attribute As Class ) { attribute As Class ( ) ; } else if ( o = = m Menu Edit Delete Instance ) { delete Instance ( BOOL ) ; } else if ( o = = m Menu Edit Delete Instances ) { delete Instance ( BOOL ) ; } else if ( o = = m Menu Edit Sort Instances ) { sort Instances ( ) ; } else if ( o = = m Menu View Attributes ) { show Attributes ( ) ; } else if ( o = = m Menu View Values ) { show Values ( ) ; } else if ( o = = m Menu View Optimal Col Widths ) { set Optimal Col Widths ( ) ; } update Menu ( ) ; }",
    "label": 1
  },
  {
    "text_1": "modify export in access zone",
    "text_2": "public void modify Export ( String id , String zone Name , Isilon Export exp ) throws Isilon Exception { String uri With Zone Name = get URI With Zone Name ( id , zone Name ) ; modify ( base Url . resolve ( URI NFS EXP ORTS ) , uri With Zone Name , STRING , exp ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new xpath 2 filter container with the filter type \" intersect \" .",
    "text_2": "public static X Path NUM Filter Container new Instance Intersect ( Document doc , String xpath NUM filter ) { return new X Path NUM Filter Container ( doc , xpath NUM filter , X Path NUM Filter Container . ATT FILTER VALUE INTERSECT ) ; }",
    "label": 1
  },
  {
    "text_1": "tells discord to delete the specified invite from the server . after deleting , this invite will no longer work for anyone .",
    "text_2": "public static void delete ( String code , JDA j da ) { Invite invite = resolve ( code ) ; if ( invite = = null ) throw new Illegal Argument Exception ( STRING + STRING + code ) ; delete ( invite , j da ) ; }",
    "label": 1
  },
  {
    "text_1": "writes a single character .",
    "text_2": "public void write ( int c ) throws IO Exception { internal Out . write ( c ) ; }",
    "label": 1
  },
  {
    "text_1": "unregister all jmx mbeans",
    "text_2": "private void unregister M Beans ( ) { List < Object Name > unregistered = new Array List < Object Name > ( ) ; for ( Object Name name : mbeans ) { try { m bean server . unregister M Bean ( name ) ; unregistered . add ( name ) ; } catch ( JM Exception e ) { } } mbeans . remove All ( unregistered ) ; }",
    "label": 1
  },
  {
    "text_1": "add a reference to this statement .",
    "text_2": "public Expanded Statement Builder reference ( String property , Object value ) { check Can Change ( ) ; extra Info . add ( new Reference Info ( property , value ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "tests sha messagedigest provider",
    "text_2": "public void test SHA Provider ( ) { Message Digest md = null ; try { md = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { fail ( STRING + e ) ; } byte [ ] bytes = new byte [ ] { NUM , NUM , NUM , NUM , NUM } ; try { md . update ( bytes , - NUM , NUM ) ; fail ( STRING ) ; } catch ( Index Out Of Bounds Exception e ) { } try { md . update ( bytes , NUM , - NUM ) ; fail ( STRING ) ; } catch ( Index Out Of Bounds Exception e ) { } try { md = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { fail ( STRING + e ) ; } try { md . digest ( bytes , NUM , - NUM ) ; fail ( STRING ) ; } catch ( Digest Exception e ) { } try { md . digest ( bytes , - NUM , NUM ) ; fail ( STRING ) ; } catch ( Digest Exception e ) { } try { md = Message Digest . get Instance ( STRING ) ; fail ( STRING ) ; } catch ( No Such Algorithm Exception e ) { } }",
    "label": 1
  },
  {
    "text_1": "compute the angle between the first and second point .",
    "text_2": "public static double angle ( Tuple NUM d a , Tuple NUM d b ) { double dx = b . x - a . x ; double dy = b . y - a . y ; double angle = NUM ; if ( dx = = NUM ) { if ( dy = = NUM ) angle = NUM ; else if ( dy > NUM ) angle = Math . PI / NUM ; else angle = ( Math . PI * NUM ) / NUM ; } else if ( dy = = NUM ) { if ( dx > NUM ) angle = NUM ; else angle = Math . PI ; } else { if ( dx < NUM ) angle = Math . atan ( dy / dx ) + Math . PI ; else if ( dy < NUM ) angle = Math . atan ( dy / dx ) + ( NUM * Math . PI ) ; else angle = Math . atan ( dy / dx ) ; } return angle ; }",
    "label": 1
  },
  {
    "text_1": "build and validate cert path from end certificate . note : the certpath return seems only include intermediate ca unless there is none in which case the end cert is returned .",
    "text_2": "private Cert Path build Cert Path ( X509 Certificate end Cert ) throws Certificate Path Building Exception { Cert Path Builder cp b = null ; try { cp b = Cert Path Builder . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } PKIX Builder Parameters params = Create PKIX Builder Parameters ( end Cert ) ; Cert Path Builder Result cp b Result ; try { cp b Result = cp b . build ( params ) ; } catch ( Cert Path Builder Exception e ) { throw new Certificate Path Building Exception ( e . get Message ( ) , e . get Cause ( ) ) ; } catch ( Invalid Algorithm Parameter Exception e ) { throw new Certificate Path Building Exception ( e . get Message ( ) , e ) ; } Cert Path cp = cp b Result . get Cert Path ( ) ; return cp ; }",
    "label": 1
  },
  {
    "text_1": "updates the ui state for the pee ked to expanded transition ( and vice versa ) , according to a completion | percentage | .",
    "text_2": "private void update Panel For Expansion ( float percentage ) { update Promo Visibility ( NUM ) ; float base Base Y = Math Utils . interpolate ( NUM , get Base Page Target Y ( ) , percentage ) ; m Base Page Y = base Base Y ; float brightness = Math Utils . interpolate ( BASE PAGE BRIGHTNESS STATE PEEKED , BASE PAGE BRIGHTNESS STATE EXPANDED , percentage ) ; m Base Page Brightness = brightness ; float search Bar Height = Math . round ( Math Utils . interpolate ( m Search Bar Height Peeking , get Search Bar Height Expanded ( ) , percentage ) ) ; m Search Bar Height = search Bar Height ; m Search Bar Text Opacity = NUM ; m Is Search Bar Border Visible = BOOL ; m Search Bar Border Y = search Bar Height - SEARCH BAR BORDER HEIGHT DP + NUM ; m Search Icon Opacity = SEARCH ICON OPACITY STATE EXPANDED ; m Arrow Icon Opacity = ARROW ICON OPACITY STATE EXPANDED ; m Arrow Icon Rotation = Math . round ( Math Utils . interpolate ( ARROW ICON ROTATION STATE PEEKED , ARROW ICON ROTATION STATE EXPANDED , percentage ) ) ; m Close Icon Opacity = CLOSE ICON OPACITY STATE EXPANDED ; float peeked Height = get Panel Height From State ( Panel State . PEEKED ) ; float threshold = PROGRESS BAR VISIBILITY THRESHOLD DP / m Px To Dp ; float diff = Math . min ( m Height - peeked Height , threshold ) ; float progress Bar Opacity = Math Utils . interpolate ( NUM , NUM , diff / threshold ) ; m Progress Bar Opacity = progress Bar Opacity ; m Progress Bar Y = search Bar Height - PROGRESS BAR HEIGHT DP + NUM ; update Search Bar Shadow ( ) ; }",
    "label": 1
  },
  {
    "text_1": "performs the specified action on the menu item specified by the screen coordinate position .",
    "text_2": "private boolean menu Item Action ( int screen X , int screen Y , int action ) { List View list View = m App Menu . get Popup ( ) . get List View ( ) ; Array List < View > item Views = new Array List < View > ( ) ; for ( int i = NUM ; i < list View . get Child Count ( ) ; + + i ) { boolean has Image Buttons = BOOL ; if ( list View . get Child At ( i ) instanceof Linear Layout ) { Linear Layout layout = ( Linear Layout ) list View . get Child At ( i ) ; for ( int j = NUM ; j < layout . get Child Count ( ) ; + + j ) { item Views . add ( layout . get Child At ( j ) ) ; if ( layout . get Child At ( j ) instanceof Image Button ) has Image Buttons = BOOL ; } } if ( ! has Image Buttons ) item Views . add ( list View . get Child At ( i ) ) ; } boolean did Perform Click = BOOL ; for ( int i = NUM ; i < item Views . size ( ) ; + + i ) { View item View = item Views . get ( i ) ; boolean should Perform = item View . is Enabled ( ) & & item View . is Shown ( ) & & get Screen Visible Rect ( item View ) . contains ( screen X , screen Y ) ; switch ( action ) { case ITEM ACTION HIGHLIGHT : item View . set Pressed ( should Perform ) ; break ; case ITEM ACTION PERFORM : if ( should Perform ) { item View . perform Click ( ) ; did Perform Click = BOOL ; } break ; case ITEM ACTION CLEAR HIGHLIGHT ALL : item View . set Pressed ( BOOL ) ; break ; default : assert BOOL ; break ; } } return did Perform Click ; }",
    "label": 1
  },
  {
    "text_1": "flush each of the unsynchronized buffers onto their backing synchronized buffer .",
    "text_2": "public void flush ( ) { synchronized ( list ) { int n = NUM ; long m = NUM ; for ( T b : list ) { if ( halt ) throw new Runtime Exception ( first Cause . get ( ) ) ; final int size = b . size ( ) ; final long counter = b . flush ( ) ; m + = counter ; if ( DEBUG ) log . debug ( STRING + size + STRING + counter ) ; } if ( INFO ) log . info ( STRING + n + STRING + m + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "the following private methods are all procedures for use by the tokenize method .",
    "text_2": "private static boolean is All Underscores ( ) { int i = NUM ; boolean result = BOOL ; while ( result & & ( i < token . length ( ) ) ) { if ( token . char At ( i ) ! = STRING ) { result = BOOL ; } ; i = i + NUM ; } ; return result ; }",
    "label": 1
  },
  {
    "text_1": "get previous cumulative amount ( approved , approval pending and draft entries ) based on workorder activity id . this will search list of mb detail and then get c mul ative amount .",
    "text_2": "@ Override public double prev Cumulative Quantity ( final Long wo Activity Id , Long mb Header Id ) { if ( mb Header Id = = null ) mb Header Id = - NUM ; final Object [ ] params = new Object [ ] { mb Header Id , mb Header Id , Works Constants . CANCELLED STATUS , wo Activity Id } ; final Double p Quant = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( p Quant = = null ) return NUM ; else return p Quant . double Value ( ) ; }",
    "label": 1
  },
  {
    "text_1": "extract metadata for encryption object",
    "text_2": "public void read Encryption Object ( final Pdf Object enc yption Obj , final Pdf File Reader pdf File Reader ) throws Pdf Security Exception { strings Encoded = BOOL ; is Meta Data Enc yp ted = BOOL ; Stm F Obj = null ; Str F Obj = null ; is AES = BOOL ; if ( ! is Initialised ) { is Initialised = BOOL ; Set Security . init ( ) ; } if ( Set Security . use Bouncy Castle ) { decryption Methods = new Bouncy Castle Decryption ( ) ; } else { decryption Methods = new JCA Decryption ( ) ; } final int v = enc yption Obj . get Int ( Pdf Dictionary . V ) ; final Pdf Array Iterator filters = enc yption Obj . get Mixed Array ( Pdf Dictionary . Filter ) ; int first Value = Pdf Dictionary . Standard ; if ( filters ! = null & & filters . has More Tokens ( ) ) { first Value = filters . get Next Value As Constant ( BOOL ) ; } if ( v = = NUM ) { throw new Pdf Security Exception ( STRING ) ; } else if ( ( v > NUM ) & & ( first Value ! = Pdf Dictionary . Standard ) ) { throw new Pdf Security Exception ( STRING ) ; } final int new Length = enc yption Obj . get Int ( Pdf Dictionary . Length ) > > NUM ; if ( new Length ! = - NUM ) { this . key Length = new Length ; } rev = enc yption Obj . get Int ( Pdf Dictionary . R ) ; P = enc yption Obj . get Int ( Pdf Dictionary . P ) ; O = enc yption Obj . get Text Stream Value As Byte ( Pdf Dictionary . O ) ; U = enc yption Obj . get Text Stream Value As Byte ( Pdf Dictionary . U ) ; OE = enc yption Obj . get Text Stream Value As Byte ( Pdf Dictionary . OE ) ; UE = enc yption Obj . get Text Stream Value As Byte ( Pdf Dictionary . UE ) ; Perms = enc yption Obj . get Text Stream Value As Byte ( Pdf Dictionary . Perms ) ; if ( v > = NUM ) { is AES = BOOL ; String C F key ; final Pdf Object CF = enc yption Obj . get Dictionary ( Pdf Dictionary . CF ) ; if ( v = = NUM ) { is Meta Data Enc yp ted = enc yption Obj . get Boolean ( Pdf Dictionary . Encrypt Metadata ) ; } is AES Identity = BOOL ; String key = enc yption Obj . get Name ( Pdf Dictionary . Str F ) ; if ( key ! = null ) { is AES Identity = key . equals ( STRING ) ; strings Encoded = BOOL ; final Pdf Key Pairs Iterator key Pairs = CF . get Key Pairs Iterator ( ) ; while ( key Pairs . has More Pairs ( ) ) { C F key = key Pairs . get Next Key As String ( ) ; if ( C F key . equals ( key ) ) { Str F Obj = Pdf Object Factory . get PDF Object Object From Ref Or Direct ( new Encryption Object ( enc yption Obj . get Object Ref As String ( ) ) , pdf File Reader , key Pairs . get Next Value As Bytes ( ) , Pdf Dictionary . CF ) ; } key Pairs . next Pair ( ) ; } } key = enc yption Obj . get Name ( Pdf Dictionary . Stm F ) ; if ( key ! = null ) { is AES Identity = key . equals ( STRING ) ; final Pdf Key Pairs Iterator key Pairs = CF . get Key Pairs Iterator ( ) ; while ( key Pairs . has More Pairs ( ) ) { C F key = key Pairs . get Next Key As String ( ) ; if ( C F key . equals ( key ) ) { Stm F Obj = Pdf Object Factory . get PDF Object Object From Ref Or Direct ( new Encryption Object ( enc yption Obj . get Object Ref As String ( ) ) , pdf File Reader , key Pairs . get Next Value As Bytes ( ) , Pdf Dictionary . CF ) ; } key Pairs . next Pair ( ) ; } } } is Encrypted = BOOL ; is File Viewable = BOOL ; Log Writer . write Log ( STRING ) ; if ( first Value = = Pdf Dictionary . Standard ) { try { verify Access ( ) ; } catch ( final Pdf Security Exception e ) { Log Writer . write Log ( STRING + e ) ; } } else if ( certificate ! = null ) { is File Viewable = BOOL ; is Password Supplied = BOOL ; extraction Is Allowed = BOOL ; password Status = PD F flags . VALID OWNER PASSWORD ; } if ( rev = = NUM ) { Perms = v5 Decrypt ( Perms , encryption Key ) ; is Meta Data Enc yp ted = Perms [ NUM ] = = STRING ; P = ( Perms [ NUM ] & NUM ) | ( ( Perms [ NUM ] & NUM ) < < NUM ) | ( ( Perms [ NUM ] & NUM ) < < NUM ) | ( ( Perms [ NUM ] & NUM ) < < NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "construct a new attribute",
    "text_2": "public Attr ( String name , @ Nullable Format format ) { this . name = name ; if ( format ! = null ) { formats = Collections . singleton List ( format ) ; } }",
    "label": 1
  },
  {
    "text_1": "test read and write empty cluster policy object",
    "text_2": "public void test Write Read Empty ( ) throws Exception { Byte Array Output Stream out = new Byte Array Output Stream ( NUM ) ; Object Output Stream os = new Object Output Stream ( out ) ; os . write Object ( empty ) ; Object Input Stream is = new Object Input Stream ( new Byte Array Input Stream ( out . to Byte Array ( ) ) ) ; Cluster Policy copy = ( Cluster Policy ) is . read Object ( ) ; is . close ( ) ; os . close ( ) ; assert True ( helper . are Equals ( empty , copy ) ) ; }",
    "label": 1
  },
  {
    "text_1": "handles the special message to launch an activity .",
    "text_2": "private void handle Launch Message Event ( Message Event message Event ) { Data Map data Map = Data Map . from Byte Array ( message Event . get Data ( ) ) ; boolean rel aunch If Running = data Map . get Boolean ( KEY START ACTIVITY RE LAUNCH , BOOL ) ; Data Map bundle Data = data Map . get Data Map ( KEY START ACTIVITY BUNDLE ) ; String activity Name = data Map . get String ( KEY START ACTIVITY NAME ) ; Bundle bundle = null ; if ( bundle Data ! = null ) { bundle = bundle Data . to Bundle ( ) ; } if ( activity Name = = null ) { for ( Wear Consumer consumer : m Wear Consumers ) { consumer . on Wearable Application Launch Request Received ( bundle , rel aunch If Running ) ; } } else { try { if ( ! Text Utils . is Empty ( activity Name ) ) { Class < ? > target Activity = Class . for Name ( activity Name ) ; Intent intent = new Intent ( m Context , target Activity ) ; intent . set Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; if ( bundle ! = null ) { intent . put Extras ( bundle ) ; } if ( ! m App Foreground | | rel aunch If Running ) { m Context . start Activity ( intent ) ; } } else { Log . e ( TAG , STRING ) ; } } catch ( Class Not Found Exception e ) { Log . e ( TAG , STRING , e ) ; } } }",
    "label": 1
  },
  {
    "text_1": "shows the peek promo . this includes inf lating the view and setting it to its initial state . this also means a new cc : : layer will be created and added to the tree .",
    "text_2": "void show ( ) { if ( m Is Visible ) return ; m Is Visible = BOOL ; m Height Px = Math . round ( m Default Height Px ) ; invalidate ( ) ; }",
    "label": 1
  },
  {
    "text_1": "test filling empty values of run index from secondary namespace",
    "text_2": "public void test Empty Run Index ( ) { String rs = STRING ; Settings s = new Settings ( STRING ) ; s . set Secondary Namespace ( STRING ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; Settings . set Run Index ( NUM ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; Settings . set Run Index ( NUM ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; Settings . set Run Index ( NUM ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "return true if there are exclusions rules defined .",
    "text_2": "public boolean has Exclusion ( ) { return ! m Excluded Classes . is Empty ( ) | | ! m Excluded Tests . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "logs a message to the configured info logger .",
    "text_2": "public static void info ( final String message ) { info Logger . accept ( message ) ; }",
    "label": 1
  },
  {
    "text_1": "the mouse has been double - clicked in the tree , perform appropriate behaviour .",
    "text_2": "private void handle Double Click ( Double Click Event e ) { I Selection selection = e . get Selection ( ) ; if ( selection instanceof I Structured Selection ) { I Structured Selection structured = ( I Structured Selection ) selection ; if ( structured . size ( ) = = NUM ) { Object first = structured . get First Element ( ) ; if ( first instanceof ISVN Remote File ) { open Action . selection Changed ( null , selection ) ; open Action . run ( null ) ; } else { tree Viewer . set Expanded State ( first , ! tree Viewer . get Expanded State ( first ) ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "removes all addresses from this user",
    "text_2": "public void remove All Addresses ( ) { addresses . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "it adds a new metric chart panel to the tabbed pane set .",
    "text_2": "private void create Metric Chart Panel ( int metric , Dataset Generator dataset Generator , List < GC Stats Chart Panel > list ) { Changing Category Dataset With TT G dataset = dataset Generator . new Category Dataset With TT G ( metric , BOOL ) ; GC Stats Chart Panel panel = new Metric Chart Panel ( CHART PREFIX + Dataset Generator . get Metric Name ( metric ) , Dataset Generator . get Unit Name ( metric ) , dataset , locker ) ; list . add ( panel ) ; }",
    "label": 1
  },
  {
    "text_1": "get tokens by secur id retriever which handles multi - leg ged secur id grant",
    "text_2": "public OIDC Tokens acquire Tokens By Secu r ID ( String username , String pas scode , Secu r ID Retriever secu r Id Retriever , Token Spec token Spec ) throws OIDC Client Exception , OIDC Server Exception , Token Validation Exception , SSL Connection Exception { Validate . not Empty ( username , STRING ) ; Validate . not Empty ( pas scode , STRING ) ; Validate . not Null ( secu r Id Retriever , STRING ) ; Validate . not Null ( token Spec , STRING ) ; Http Response http Response = OIDC Client Utils . handle Secu r ID Multi Leg ged Grant ( username , pas scode , secu r Id Retriever , token Spec , get Token Endpoint URI ( ) , this . client Id , this . holder Of Key Config , this . key Store ) ; return OIDC Client Utils . parse Token Response ( http Response , this . provider Public Key , this . issuer , this . client Id , this . clock Tolerance In Seconds ) ; }",
    "label": 1
  },
  {
    "text_1": "match if audit log description contains expected keyword , stream out the audit log if matched , otherwise ignore this one piece of audit log . since the streaming format for the first audit log is slightly different from all the rest of audit logs , this method uses a boolean to block audit log being streamed until the first audit log is streamed by a thread .",
    "text_2": "private boolean match And write One Audit Log ( Buffered Writer writer , Audit Log audit log , String keyword ) throws Marshalling Ex ce tion { try { Audit Log Utils . reset Desc ( audit log , res b ) ; if ( Audit Log Utils . is Keyword Contained ( audit log , keyword ) ) { if ( count . get And Increment ( ) > NUM ) { while ( ! first Written . get ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { logger . warn ( STRING ) ; } } writer . write ( STRING + mapper . write Value As String ( audit log ) ) ; } else { writer . write ( mapper . write Value As String ( audit log ) ) ; first Written . set ( BOOL ) ; } return BOOL ; } logger . debug ( STRING , audit log . get Description ( ) , keyword ) ; return BOOL ; } catch ( Json Generation Exception e ) { throw new Marshalling Ex ce tion ( STRING , e ) ; } catch ( Json Mapping Exception e ) { throw new Marshalling Ex ce tion ( STRING , e ) ; } catch ( IO Exception e ) { throw new Marshalling Ex ce tion ( STRING , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "reads the next token from standard input , parses it as a byte , and returns the byte .",
    "text_2": "public static byte read Byte ( ) { return scanner . next Byte ( ) ; }",
    "label": 1
  },
  {
    "text_1": "count the number of duplicate stack frames , starting from the end of the stack .",
    "text_2": "private static int count Duplicates ( Stack Trace Element [ ] current Stack , Stack Trace Element [ ] parent Stack ) { int duplicates = NUM ; int parent Index = parent Stack . length ; for ( int i = current Stack . length ; - - i > = NUM & & - - parent Index > = NUM ; ) { Stack Trace Element parent Frame = parent Stack [ parent Index ] ; if ( parent Frame . equals ( current Stack [ i ] ) ) { duplicates + + ; } else { break ; } } return duplicates ; }",
    "label": 1
  },
  {
    "text_1": "synopsis [ ] outer arraylist = lines inner arraylist = tokens",
    "text_2": "public static Array List < Array List < String > > file Tokenizer ( String fin ) { File file = new File ( fin ) ; Buffered Reader br ; File Reader fr ; Array List < String > lines = new Array List < String > ( ) ; try { fr = new File Reader ( file ) ; br = new Buffered Reader ( fr ) ; String line ; try { while ( ( line = br . read Line ( ) ) ! = null ) { if ( line . length ( ) > NUM ) { lines . add ( line ) ; } } } catch ( IO Exception ex ) { } } catch ( File Not Found Exception ex ) { } Array List < Array List < String > > tokenized list = new Array List < Array List < String > > ( ) ; for ( String s : lines ) { Array List < String > tokens = new Array List < String > ( ) ; String Tokenizer st = new String Tokenizer ( s , STRING ) ; while ( st . has More Tokens ( ) ) { tokens . add ( st . next Token ( ) ) ; } tokenized list . add ( tokens ) ; } return tokenized list ; }",
    "label": 1
  },
  {
    "text_1": "shuts down the handler .",
    "text_2": "void shutdown ( ) { try { ssl Engine . close Inbound ( ) ; } catch ( SSL Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) + STRING + ses + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "construct an xpath object . ( needs review - sc ) this method initializes an xpath parser / compiler and compiles the expression .",
    "text_2": "public X Path ( String expr String , Source Locator locator , Prefix Resolver prefix Resolver , int type ) throws javax . xml . transform . Transformer Exception { this ( expr String , locator , prefix Resolver , type , null ) ; }",
    "label": 1
  },
  {
    "text_1": "writes the value of the property to the given object . it uses reflection and looks for a method starting with \" set \" followed by the capitalized property name and with one parameter with the same type as the property .",
    "text_2": "public void write To Object ( Object object ) { try { Method method = Bean Utils . get Write Method ( object . get Class ( ) , get Name ( ) , get Type ( ) ) ; if ( method ! = null ) { method . invoke ( object , new Object [ ] { get Value ( ) } ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "flip bit ( int n ) outside a positive number",
    "text_2": "public void test Flip Bit Positive Outside NUM ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "zk restore this tokenizer , giving it a new input string to parse . in this manner you can re - use a tokenizer with the same settings on multiple input lines .",
    "text_2": "public Str Tokenizer reset ( String input ) { reset ( ) ; if ( input ! = null ) { this . chars = input . to Char Array ( ) ; } else { this . chars = null ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "tokenizer contains < name > ' / ' < name >",
    "text_2": "private boolean node Exists ( String Tokenizer path ) throws Backing Store Exception { String token = path . next Token ( ) ; if ( token . equals ( STRING ) ) throw new Illegal Argument Exception ( STRING ) ; synchronized ( lock ) { Abstract Preferences child = kid Cache . get ( token ) ; if ( child = = null ) child = get Child ( token ) ; if ( child = = null ) return BOOL ; if ( ! path . has More Tokens ( ) ) return BOOL ; path . next Token ( ) ; if ( ! path . has More Tokens ( ) ) throw new Illegal Argument Exception ( STRING ) ; return child . node Exists ( path ) ; } }",
    "label": 1
  },
  {
    "text_1": "handle default tenant request sent with a wrong binding",
    "text_2": "@ Request Mapping ( value = STRING ) public void sso Default Tenant Binding Error ( Locale locale , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + locale . to String ( ) + STRING ) ; send Error ( locale , response , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "determines the number of consecutive characters that are encodable using binary compaction .",
    "text_2": "private static int determine Consecutive Binary Count ( Char Sequence msg , byte [ ] bytes , int startpos ) throws Writer Exception { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char At ( idx ) ; int numeric Count = NUM ; while ( numeric Count < NUM & & is Digit ( ch ) ) { numeric Count + + ; int i = idx + numeric Count ; if ( i > = len ) { break ; } ch = msg . char At ( i ) ; } if ( numeric Count > = NUM ) { return idx - startpos ; } int text Count = NUM ; while ( text Count < NUM & & is Text ( ch ) ) { text Count + + ; int i = idx + text Count ; if ( i > = len ) { break ; } ch = msg . char At ( i ) ; } if ( text Count > = NUM ) { return idx - startpos ; } ch = msg . char At ( idx ) ; if ( bytes [ idx ] = = NUM & & ch ! = STRING ) { throw new Writer Exception ( STRING + ch + STRING + ( int ) ch + STRING ) ; } idx + + ; } return idx - startpos ; }",
    "label": 1
  },
  {
    "text_1": "checks database metadata to see if a column exists in a table . this method is sensitive to the case of both the provided table name and column name .",
    "text_2": "public boolean column Exists Case Sensitive ( Database Meta Data db Meta Data , String table Name , String column Name ) throws SQL Exception { Result Set rs Tables = db Meta Data . get Columns ( null , null , table Name , column Name ) ; try { return rs Tables . next ( ) ; } finally { close JDBC Result Set ( rs Tables ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates new form find dialog",
    "text_2": "public Replace Dialog ( J Text Component text , Find Replace Actions finder Actions ) { super ( Action Utils . get Frame For ( text ) , BOOL ) ; init Components ( ) ; register Key Action ( this ) ; text Component = text ; finder = finder Actions ; text Component . add Caret Listener ( this ) ; set Location Relative To ( text . get Root Pane ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "clears the cache . deletes all cached files from disk .",
    "text_2": "@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files ! = null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "trim a given string to max string length if it is over max string length .",
    "text_2": "public String trim To Size ( String str , int max String Length ) { if ( str = = null ) return null ; if ( str . length ( ) > max String Length ) { String Builder sb = new String Builder ( str ) ; sb . set Length ( max String Length ) ; str = sb . to String ( ) ; } return str ; }",
    "label": 1
  },
  {
    "text_1": "invoked when a mouse button has been pressed on a component .",
    "text_2": "@ Override public void mouse Pressed ( Mouse Event e ) { events . clear ( ) ; if ( map Drag Operation From Modifiers ( e ) ! = Dn D Constants . ACTION NONE ) { try { motion Threshold = Drag Source . get Drag Threshold ( ) ; } catch ( Exception exc ) { motion Threshold = NUM ; } append Event ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "generate the mac based on hmac algorithm",
    "text_2": "public static byte [ ] generate Mac ( byte [ ] byte Cipher Text , Secret Key integrity Key ) throws No Such Algorithm Exception , Invalid Key Exception { Mac sha NUM HMAC = Mac . get Instance ( HMAC ALGORITHM ) ; sha NUM HMAC . init ( integrity Key ) ; return sha NUM HMAC . do Final ( byte Cipher Text ) ; }",
    "label": 1
  },
  {
    "text_1": "write the data in the buffer .",
    "text_2": "public final void write ( final byte [ ] data ) { byte Buffer . put ( data ) ; }",
    "label": 1
  },
  {
    "text_1": "multiply two numbers of 4 bytes length .",
    "text_2": "public void test Int by Int NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "reads in the given number of attributes from the given stream .",
    "text_2": "protected boolean read Attributes ( Data Input Stream d , int attributes count , attribute info [ ] ai ) throws IO Exception { attribute info a = null ; int i ; int j ; long len ; String s ; for ( i = NUM ; i < attributes count ; i + + ) { j = d . read Unsigned Short ( ) ; len = d . read Int ( ) & NUM ; s = ( ( CONSTANT Utf NUM info ) ( constant pool [ j ] ) ) . convert ( ) ; if ( s . compare To ( attribute info . Source File ) = = NUM ) { Source File attribute sa = new Source File attribute ( ) ; sa . sourcefile index = d . read Unsigned Short ( ) ; a = ( attribute info ) sa ; } else if ( s . compare To ( attribute info . Constant Value ) = = NUM ) { Constant Value attribute ca = new Constant Value attribute ( ) ; ca . constan t value index = d . read Unsigned Short ( ) ; a = ( attribute info ) ca ; } else if ( s . compare To ( attribute info . Code ) = = NUM ) { Code attribute ca = new Code attribute ( ) ; ca . max stack = d . read Unsigned Short ( ) ; ca . max locals = d . read Unsigned Short ( ) ; ca . code length = d . read Int ( ) & NUM ; ca . code = new byte [ ( int ) ca . code length ] ; d . read ( ca . code ) ; ca . exception table length = d . read Unsigned Short ( ) ; ca . exception table = new exception table entry [ ca . exception table length ] ; int k ; exception table entry e ; for ( k = NUM ; k < ca . exception table length ; k + + ) { e = new exception table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . end pc = d . read Unsigned Short ( ) ; e . handler pc = d . read Unsigned Short ( ) ; e . catch type = d . read Unsigned Short ( ) ; ca . exception table [ k ] = e ; } ca . attributes count = d . read Unsigned Short ( ) ; ca . attributes = new attribute info [ ca . attributes count ] ; read Attributes ( d , ca . attributes count , ca . attributes ) ; a = ( attribute info ) ca ; } else if ( s . compare To ( attribute info . Exceptions ) = = NUM ) { Exception attribute ea = new Exception attribute ( ) ; ea . number of exceptions = d . read Unsigned Short ( ) ; if ( ea . number of exceptions > NUM ) { int k ; ea . exception index table = new int [ ea . number of exceptions ] ; for ( k = NUM ; k < ea . number of exceptions ; k + + ) ea . exception index table [ k ] = d . read Unsigned Short ( ) ; } a = ( attribute info ) ea ; } else if ( s . compare To ( attribute info . Line Number Table ) = = NUM ) { Line Number Table attribute la = new Line Number Table attribute ( ) ; la . line number table length = d . read Unsigned Short ( ) ; int k ; line number table entry e ; la . line number table = new line number table entry [ la . line number table length ] ; for ( k = NUM ; k < la . line number table length ; k + + ) { e = new line number table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . line number = d . read Unsigned Short ( ) ; la . line number table [ k ] = e ; } a = ( attribute info ) la ; } else if ( s . compare To ( attribute info . Local Variable Table ) = = NUM ) { Local Variable Table attribute la = new Local Variable Table attribute ( ) ; la . local variable table length = d . read Unsigned Short ( ) ; int k ; local variable table entry e ; la . local variable table = new local variable table entry [ la . local variable table length ] ; for ( k = NUM ; k < la . local variable table length ; k + + ) { e = new local variable table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . length = d . read Unsigned Short ( ) ; e . name index = d . read Unsigned Short ( ) ; e . descriptor index = d . read Unsigned Short ( ) ; e . index = d . read Unsigned Short ( ) ; la . local variable table [ k ] = e ; } a = ( attribute info ) la ; } else if ( s . compare To ( attribute info . Local Variable Type Table ) = = NUM ) { Local Variable Type Table attribute la = new Local Variable Type Table attribute ( ) ; la . local variable type table length = d . read Unsigned Short ( ) ; int k ; local variable type table entry e ; la . local variable type table = new local variable type table entry [ la . local variable type table length ] ; for ( k = NUM ; k < la . local variable type table length ; k + + ) { e = new local variable type table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . length = d . read Unsigned Short ( ) ; e . name index = d . read Unsigned Short ( ) ; e . signature index = d . read Unsigned Short ( ) ; e . index = d . read Unsigned Short ( ) ; la . local variable type table [ k ] = e ; } a = ( attribute info ) la ; } else if ( s . compare To ( attribute info . Synthetic ) = = NUM ) { Synthetic attribute ia = new Synthetic attribute ( ) ; a = ( attribute info ) ia ; } else if ( s . compare To ( attribute info . Signature ) = = NUM ) { Signature attribute ia = new Signature attribute ( ) ; ia . signature index = d . read Unsigned Short ( ) ; a = ( attribute info ) ia ; } else if ( s . compare To ( attribute info . Deprecated ) = = NUM ) { Deprecated attribute da = new Deprecated attribute ( ) ; a = ( attribute info ) da ; } else if ( s . compare To ( attribute info . Enclosing Method ) = = NUM ) { Enclosing Method attribute ea = new Enclosing Method attribute ( ) ; ea . class index = d . read Unsigned Short ( ) ; ea . method index = d . read Unsigned Short ( ) ; a = ( attribute info ) ea ; } else if ( s . compare To ( attribute info . Inner Classes ) = = NUM ) { Inner Classes attribute ia = new Inner Classes attribute ( ) ; ia . inner classes length = d . read Unsigned Short ( ) ; ia . inner classes = new inner class entry [ ia . inner classes length ] ; for ( int k = NUM ; k < ia . inner classes length ; k + + ) { inner class entry e = new inner class entry ( ) ; e . inner class index = d . read Unsigned Short ( ) ; e . outer class index = d . read Unsigned Short ( ) ; e . name index = d . read Unsigned Short ( ) ; e . access flags = d . read Unsigned Short ( ) ; ia . inner classes [ k ] = e ; } a = ( attribute info ) ia ; } else if ( s . compare To ( attribute info . Runtime Visible Annotations ) = = NUM ) { Runtime Visible Annotations attribute ra = new Runtime Visible Annotations attribute ( ) ; ra . number of annotations = d . read Unsigned Short ( ) ; ra . annotations = new annotation [ ra . number of annotations ] ; for ( int k = NUM ; k < ra . number of annotations ; k + + ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; ra . annotations [ k ] = annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Runtime Invisible Annotations ) = = NUM ) { Runtime Invisible Annotations attribute ra = new Runtime Invisible Annotations attribute ( ) ; ra . number of annotations = d . read Unsigned Short ( ) ; ra . annotations = new annotation [ ra . number of annotations ] ; for ( int k = NUM ; k < ra . number of annotations ; k + + ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; ra . annotations [ k ] = annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Runtime Visible Parameter Annotations ) = = NUM ) { Runtime Visible Parameter Annotations attribute ra = new Runtime Visible Parameter Annotations attribute ( ) ; ra . num parameters = d . read Unsigned Byte ( ) ; ra . parameter annotations = new parameter annotation [ ra . num parameters ] ; for ( int x = NUM ; x < ra . num parameters ; x + + ) { parameter annotation p Annot = new parameter annotation ( ) ; p Annot . num annotations = d . read Unsigned Short ( ) ; p Annot . annotations = new annotation [ p Annot . num annotations ] ; for ( int k = NUM ; k < p Annot . num annotations ; k + + ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; p Annot . annotations [ k ] = annot ; } ra . parameter annotations [ x ] = p Annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Runtime Invisible Parameter Annotations ) = = NUM ) { Runtime Invisible Parameter Annotations attribute ra = new Runtime Invisible Parameter Annotations attribute ( ) ; ra . num parameters = d . read Unsigned Byte ( ) ; ra . parameter annotations = new parameter annotation [ ra . num parameters ] ; for ( int x = NUM ; x < ra . num parameters ; x + + ) { parameter annotation p Annot = new parameter annotation ( ) ; p Annot . num annotations = d . read Unsigned Short ( ) ; p Annot . annotations = new annotation [ p Annot . num annotations ] ; for ( int k = NUM ; k < p Annot . num annotations ; k + + ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; p Annot . annotations [ k ] = annot ; } ra . parameter annotations [ x ] = p Annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Annotation Default ) = = NUM ) { Annotation Default attribute da = new Annotation Default attribute ( ) ; element value [ ] result = read Element Values ( NUM , d , BOOL , NUM ) ; da . default value = result [ NUM ] ; a = ( attribute info ) da ; } else if ( s . equals ( attribute info . Bootstrap Methods ) ) { Bootstrap Methods attribute bs ma = new Bootstrap Methods attribute ( ) ; int count = d . read Unsigned Short ( ) ; bs ma . method handles = new short [ count ] ; bs ma . arg indices = new short [ count ] [ ] ; for ( int num = NUM ; num < count ; num + + ) { short index = ( short ) d . read Unsigned Short ( ) ; bs ma . method handles [ num ] = index ; int arg Count = d . read Unsigned Short ( ) ; bs ma . arg indices [ num ] = new short [ arg Count ] ; for ( int num Arg = NUM ; num Arg < arg Count ; num Arg + + ) { short index Arg = ( short ) d . read Unsigned Short ( ) ; bs ma . arg indices [ num ] [ num Arg ] = index Arg ; } } assert bootstrap methods attribute = = null : STRING ; a = bootstrap methods attribute = bs ma ; } else { Generic attribute ga = new Generic attribute ( ) ; if ( len > NUM ) { ga . info = new byte [ ( int ) len ] ; d . read ( ga . info ) ; } a = ( attribute info ) ga ; } a . attribute name = j ; a . attribute length = len ; ai [ i ] = a ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "compareto ( biginteger a ) . compare two numbers of different signs . the first is negative .",
    "text_2": "public void test Compare To Diff Signs NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method will form one single byte [ ] for all the high card dims . first it will add all the indexes of variable length byte [ ] and then the actual value",
    "text_2": "public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null = = byte Buffer Arr | | byte Buffer Arr . length = = NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short offset Len = ( short ) ( no Of Col * NUM ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index + + ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len + = no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index + + ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "null - safe check if the actor has a stage . useful especially for dialogs .",
    "text_2": "public static boolean is Shown ( final Actor actor ) { return actor ! = null & & actor . get Stage ( ) ! = null ; }",
    "label": 1
  },
  {
    "text_1": "fires a property change of a boolean property with the given name . if the old value and the new value are not null and equal the event will not be fired .",
    "text_2": "public void fire Indexed Property Change ( String property Name , int index , boolean old Value , boolean new Value ) { if ( old Value ! = new Value ) { fire Indexed Property Change ( property Name , index , Boolean . value Of ( old Value ) , Boolean . value Of ( new Value ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a new file from the data uri string",
    "text_2": "public static File from Data URI ( String data URI , String file Name ) { return File . create If Supported ( from Data URI ( data URI ) , file Name ) ; }",
    "label": 1
  },
  {
    "text_1": "this method is called when an exception occurs while invoking this method .",
    "text_2": "public final Runtime Exception process Do Method Invoke Exception ( Exception e , Object object , Object [ ] argument Array ) { if ( e instanceof Runtime Exception ) return ( Runtime Exception ) e ; return Meta Class Helper . create Exception Text ( STRING , this , object , argument Array , e , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "return the coordinates of a vector that is the corner of a box ( upper right or lower left ) , assuming a rectangular coordinate system . note , this does not apply for points on a sphere or ellipse ( although it could be used as an approximation ) .",
    "text_2": "public static double [ ] vector Box Corner ( double [ ] center , double [ ] result , double distance , boolean upper Right ) { if ( result = = null | | result . length ! = center . length ) { result = new double [ center . length ] ; } if ( upper Right = = BOOL ) { distance = - distance ; } distance = SIN PI DIV NUM * distance ; for ( int i = NUM ; i < center . length ; i + + ) { result [ i ] = center [ i ] + distance ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "populates the list of available data stores that can be connected to .",
    "text_2": "private void populate Available Data Stores ( ) { Data Access Factory fac ; logger . debug ( STRING ) ; Iterator < Data Store Factory Spi > iterator = Data Store Finder . get Available Data Stores ( ) ; while ( iterator . has Next ( ) ) { fac = ( Data Access Factory ) iterator . next ( ) ; logger . debug ( STRING + fac . get Display Name ( ) ) ; available Data Store List . add ( fac . get Display Name ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "zoom action to be overwritten by concrete classes",
    "text_2": "public void zoom ( ) { if ( get Selected Row Key ( ) ! = null & & get Selected Row Key ( ) > NUM ) { M Query zoom Query = new M Query ( ) ; String column = get Key Column ( ) ; if ( column . index Of ( STRING ) > NUM ) column = column . substring ( column . index Of ( STRING ) + NUM ) ; zoom Query . add Restriction ( column , M Query . EQUAL , get Selected Row Key ( ) ) ; zoom Query . set Record Count ( NUM ) ; zoom Query . set Table Name ( column . substring ( NUM , column . length ( ) - NUM ) ) ; A Env . zoom ( NUM , zoom Query ) ; } }",
    "label": 1
  },
  {
    "text_1": "an implementation of mgf - tp - 1 from p 13 63 . 1 section 8 . 4 . 1 . 1 .",
    "text_2": "private Integer Polynomial MGF ( byte [ ] seed , int N , int min Calls R , boolean hash Seed ) { Digest hash Alg = params . hash Alg ; int hash Len = hash Alg . get Digest Size ( ) ; byte [ ] buf = new byte [ min Calls R * hash Len ] ; byte [ ] Z = hash Seed ? calc Hash ( hash Alg , seed ) : seed ; int counter = NUM ; while ( counter < min Calls R ) { hash Alg . update ( Z , NUM , Z . length ) ; put Int ( hash Alg , counter ) ; byte [ ] hash = calc Hash ( hash Alg ) ; System . arraycopy ( hash , NUM , buf , counter * hash Len , hash Len ) ; counter + + ; } Integer Polynomial i = new Integer Polynomial ( N ) ; while ( BOOL ) { int cur = NUM ; for ( int index = NUM ; index ! = buf . length ; index + + ) { int O = ( int ) buf [ index ] & NUM ; if ( O > = NUM ) { continue ; } for ( int ter Idx = NUM ; ter Idx < NUM ; ter Idx + + ) { int rem NUM = O % NUM ; i . coeffs [ cur ] = rem NUM - NUM ; cur + + ; if ( cur = = N ) { return i ; } O = ( O - rem NUM ) / NUM ; } i . coeffs [ cur ] = O - NUM ; cur + + ; if ( cur = = N ) { return i ; } } if ( cur > = N ) { return i ; } hash Alg . update ( Z , NUM , Z . length ) ; put Int ( hash Alg , counter ) ; byte [ ] hash = calc Hash ( hash Alg ) ; buf = hash ; counter + + ; } }",
    "label": 1
  },
  {
    "text_1": "saves the scan to the filesystem .",
    "text_2": "private void save ( ) { try { File Utils . write ( new File ( jar Name + STRING ) , text ) ; } catch ( IO Exception e ) { J Option Pane . show Message Dialog ( null , e . get Message ( ) , STRING , J Option Pane . ERROR MESSAGE ) ; } }",
    "label": 1
  },
  {
    "text_1": "determines the height of this view",
    "text_2": "private int measure Short ( int measure Spec ) { int result = NUM ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode = = Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode = = Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "allocate a number of blocks and mark them as used .",
    "text_2": "public synchronized long allocate ( int length ) { int blocks = get Block Count ( length ) ; Block Range x = null ; for ( Block Range b : free Space ) { if ( b . blocks > = blocks ) { x = b ; break ; } } long pos = get Pos ( x . start ) ; if ( x . blocks = = blocks ) { free Space . remove ( x ) ; } else { x . start + = blocks ; x . blocks - = blocks ; } return pos ; }",
    "label": 1
  },
  {
    "text_1": "build certificate build a certificate from a base 64 formatted , pkcs 7 encoding of the certificate",
    "text_2": "public Certificate build Certificate ( String cert String ) throws Invalid Certificate { try { String base NUM Cert = format Certificate ( cert String ) ; Input Stream in Bytes = new Byte Array Input Stream ( base NUM Cert . get Bytes ( ) ) ; Certificate Factory cf = Certificate Factory . get Instance ( STRING ) ; assert in Bytes . available ( ) > NUM ; Certificate certificate = cf . generate Certificate ( in Bytes ) ; in Bytes . close ( ) ; return certificate ; } catch ( Exception e ) { log . debug ( STRING + e + STRING ) ; throw Fault Util . Invalid Certificate ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "fetches the buffered context context associated with the dst . surface and validates the context using the given parameters . most rendering operations will call this method first in order to set the necessary state before issuing rendering commands . note : must be called while the render queue lock is held . it ' s assumed that the type of surfaces has been checked by the renderer",
    "text_2": "public static void validate Context ( Accel Surface src Data , Accel Surface dst Data , Region clip , Composite comp , Affine Transform xform , Paint paint , Sun Graphics NUM D sg NUM d , int flags ) { Buffered Context context = dst Data . get Context ( ) ; context . validate ( src Data , dst Data , clip , comp , xform , paint , sg NUM d , flags ) ; }",
    "label": 1
  },
  {
    "text_1": "create an event that contains the message .",
    "text_2": "private Midi Event create Scheduled Event ( byte [ ] msg , int offset , int count , long timestamp ) { Midi Event event ; if ( count > POOL EVENT SIZE ) { event = new Midi Event ( msg , offset , count , timestamp ) ; } else { event = ( Midi Event ) remove Event from Pool ( ) ; if ( event = = null ) { event = new Midi Event ( POOL EVENT SIZE ) ; } System . arraycopy ( msg , offset , event . data , NUM , count ) ; event . count = count ; event . set Timestamp ( timestamp ) ; } return event ; }",
    "label": 1
  },
  {
    "text_1": "send a debug log message",
    "text_2": "public static void d ( String tag , String msg , Object . . . args ) { if ( s Level > LEVEL DEBUG ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }",
    "label": 1
  },
  {
    "text_1": "method to execute process",
    "text_2": "public static void execute Command ( Process Builder p ) throws IO Exception { Process proc = p . start ( ) ; try ( Buffered Reader std Input = new Buffered Reader ( new Input Stream Reader ( proc . get Input Stream ( ) ) ) ; Buffered Reader std Error = new Buffered Reader ( new Input Stream Reader ( proc . get Error Stream ( ) ) ) ) { logger . info ( STRING ) ; String s ; while ( ( s = std Input . read Line ( ) ) ! = null ) { logger . info ( s ) ; } logger . info ( STRING ) ; while ( ( s = std Error . read Line ( ) ) ! = null ) { logger . info ( s ) ; } } }",
    "label": 1
  },
  {
    "text_1": "create a polygon representing an equ i - distant area , at a meters offset with a meters interval .",
    "text_2": "protected OM Geometry create MGRS Rectangle ( MGRS Point mgrs Base Point , double vo ffset , double h offset , double interval , Ellipsoid ellipsoid ) { double [ ] llpoints = new double [ NUM ] ; double easting = mgrs Base Point . easting + h offset ; double northing = mgrs Base Point . northing + vo ffset ; int zone number = mgrs Base Point . zone number ; char zone letter = mgrs Base Point . zone letter ; Lat Lon Point llp NUM = new Lat Lon Point . Double ( ) ; llp NUM = MGRS Point . MGR Sto LL ( ellipsoid , northing , easting , zone number , zone letter , llp NUM ) ; llpoints [ NUM ] = llp NUM . get Y ( ) ; llpoints [ NUM ] = llp NUM . get X ( ) ; llpoints [ NUM ] = llp NUM . get Y ( ) ; llpoints [ NUM ] = llp NUM . get X ( ) ; MGRS Point . MGR Sto LL ( ellipsoid , northing , easting + interval , zone number , zone letter , llp NUM ) ; llpoints [ NUM ] = llp NUM . get Y ( ) ; llpoints [ NUM ] = llp NUM . get X ( ) ; MGRS Point . MGR Sto LL ( ellipsoid , northing + interval , easting + interval , zone number , zone letter , llp NUM ) ; llpoints [ NUM ] = llp NUM . get Y ( ) ; llpoints [ NUM ] = llp NUM . get X ( ) ; MGRS Point . MGR Sto LL ( ellipsoid , northing + interval , easting , zone number , zone letter , llp NUM ) ; llpoints [ NUM ] = llp NUM . get Y ( ) ; llpoints [ NUM ] = llp NUM . get X ( ) ; MGRS Point mgrs = new MGRS Point ( northing , easting , zone number , zone letter ) ; mgrs . resolve ( mgrs Base Point . get Accuracy ( ) ) ; String mgrs String = mgrs . get MGRS ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + mgrs String + STRING + mgrs . get Accuracy ( ) ) ; Polygon Geometry poly = new Polygon Geometry . LL ( llpoints , OM Graphic . DECIMAL DEGREES , ( interval < = NUM ? OM Graphic . LINETYPE STRAIGHT : OM Graphic . LINETYPE GRE AT CIRCLE ) ) ; poly . put Attribute ( OM Graphic . APP OBJECT , mgrs String ) ; return poly ; }",
    "label": 1
  },
  {
    "text_1": "puts a the given map of variables into the engine .",
    "text_2": "public static void put Java Variables Into Engine ( final Script Engine engine , final Map < String , Object > variables ) { final Bindings bindings = new Simple Bindings ( ) ; for ( String key : variables . key Set ( ) ) { bindings . put ( key , variables . get ( key ) ) ; } engine . set Bindings ( bindings , Script Context . ENGINE SCOPE ) ; }",
    "label": 1
  },
  {
    "text_1": "asserts that a string is non - null and non - empty . if it is not , an assertionfailederror is thrown with the given message .",
    "text_2": "private static void assert Not Empty ( String message , String string ) { assert Not Null ( message , string ) ; assert False ( message , string . equals ( STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "destroys the provided bucket",
    "text_2": "public void destroy Bucket ( Auto Mix Bucket bucket ) { Shared Preferences prefs = get Prefs ( ) ; Shared Preferences . Editor editor = prefs . edit ( ) ; Set < String > set = new Tree Set < > ( prefs . get String Set ( PREF BUCKETS IDS , new Tree Set < String > ( ) ) ) ; set . remove ( bucket . get Session Id ( ) ) ; editor . put String Set ( PREF BUCKETS IDS , set ) ; editor . apply ( ) ; m Buckets . remove ( bucket ) ; }",
    "label": 1
  },
  {
    "text_1": "use the current distribution but scale the samples close to the user specified one",
    "text_2": "public void scale To Samples ( int usr Samples ) { double ratio ; ratio = ( double ) usr Samples / count ; count = NUM ; for ( int i = NUM ; i < = limits . length ; + + i ) { results [ i ] = ( int ) Math . round ( results [ i ] * ratio ) ; count + = results [ i ] ; } }",
    "label": 1
  },
  {
    "text_1": "determines if the bug has already been reported enough . if it has , this returns false . otherwise ( if the bug should be reported ) this returns true .",
    "text_2": "private boolean should Inform ( Local Client Info info ) { long now = System . current Time Millis ( ) ; if ( now < next Allowed Time ) return BOOL ; Long allowed = BUG TIMES . get ( info . get Parsed Bug ( ) ) ; return allowed = = null | | now > = allowed . long Value ( ) ; }",
    "label": 1
  },
  {
    "text_1": "instantiate all these classes .",
    "text_2": "public static < T > List < T > instantiate All ( String [ ] classes , Class Loader class Loader ) { List < T > clazzes = new Array List < T > ( ) ; for ( String clazz : classes ) { if ( String Utils . has Length ( clazz ) ) { try { clazzes . add ( Class Utils . < T > instantiate ( clazz , class Loader ) ) ; } catch ( Exception e ) { throw new Cassandra Migration Exception ( STRING + clazz , e ) ; } } } return clazzes ; }",
    "label": 1
  },
  {
    "text_1": "reads 2 bytes from stream and interprets them as uint 16 .",
    "text_2": "public static int read UINT NUM ( Input Stream stream ) throws IO Exception { int result = stream . read ( ) ; result | = stream . read ( ) < < NUM ; return result ; }",
    "label": 1
  },
  {
    "text_1": "returns an array containing all of the elements in this deque , in proper sequence ( from first to last element ) . the returned array will be \" safe \" in that no references to it are maintained by this deque . ( in other words , this method must allocate a new array ) . the caller is thus free to modify the returned array . this method acts as bridge between array - based and collection - based apis .",
    "text_2": "@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p ! = null ; p = p . next ) a [ k + + ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "replaces characters using the given conversion method .",
    "text_2": "public static String replace Characters ( final Conversion Method conversion Method , final String input , final int from Character , final int to Character , final String wrap ) { String converted Text = input ; for ( int i = from Character ; i < = to Character ; i + + ) { final String character To Replace = new String ( Character . to Chars ( i ) ) ; if ( wrap ! = null ) { converted Text = converted Text . replace ( character To Replace , wrap + convert Text ( conversion Method , character To Replace ) + wrap ) ; } else { converted Text = converted Text . replace ( character To Replace , convert Text ( conversion Method , character To Replace ) ) ; } } return converted Text ; }",
    "label": 1
  },
  {
    "text_1": "writes a portion of a string .",
    "text_2": "public void write ( String str , int off , int len ) throws IO Exception { if ( output Stream = = null ) throw new IO Exception ( STRING ) ; final int off plus len = off + len ; for ( int i = off ; i < off plus len ; ) { char c = str . char At ( i + + ) ; if ( c < NUM ) { bytes [ index ] = ( byte ) c ; if ( + + index > = bytes . length ) { flush Buffer ( ) ; } } else { write ( c ) ; } } }",
    "label": 1
  },
  {
    "text_1": "swipe a view by moving distance",
    "text_2": "@ Target Api ( Build . VERSION CODES . HONEYCOMB ) protected void swipe View ( View child , float delta X , float delta Y ) { if ( is Fixed View ( child ) ) { delta X = delta X / NUM ; } float delta X Abs = Math . abs ( delta X ) ; float fraction Covered = delta X Abs / ( float ) child . get Width ( ) ; child . set Translation X ( delta X ) ; child . set Alpha ( NUM - fraction Covered ) ; if ( delta X > NUM ) child . set Rotation Y ( - NUM * fraction Covered ) ; else child . set Rotation Y ( NUM * fraction Covered ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the next line from the reader .",
    "text_2": "public String read Line ( ) throws IO Exception { return keep Carriage Returns ? read Until Newline ( ) : reader . read Line ( ) ; }",
    "label": 1
  },
  {
    "text_1": "update positions of mov enodes using the supplied translator . the map of node positions is changed in place . move nodes without a position are not added .",
    "text_2": "public static void translate Pos ( Collection < Graph Node > move Nodes , Map < Graph Node , Point NUM D > positions , Translat er into Region ) { for ( Graph Node node : move Nodes ) { Point NUM D location = translate Node ( node , positions , into Region ) ; if ( null = = location ) { continue ; } positions . put ( node , location ) ; } }",
    "label": 1
  },
  {
    "text_1": "input is child name , not full path",
    "text_2": "public void add Child ( String child ) { if ( child = = null ) { return ; } String child Path = path . ends With ( STRING ) ? path + child : path + STRING + child ; children . add ( new Zk Node ( child Path ) ) ; }",
    "label": 1
  },
  {
    "text_1": "removes a line highlight .",
    "text_2": "public void remove Line Highlight ( Object tag ) { if ( tag instanceof Line Highlight Info ) { line Highlights . remove ( tag ) ; repaint Line ( ( Line Highlight Info ) tag ) ; } }",
    "label": 1
  },
  {
    "text_1": "estimates bounds on the distance to a region",
    "text_2": "public double [ ] estimate L NUM Distance Squared ( Datum query Datum ) { Real Vector vector = query Datum . metrics ( ) ; double [ ] estimates = new double [ NUM ] ; for ( int i = NUM ; i < k ; i + + ) { double delta Lo = vector . get Entry ( i ) - this . boundaries [ i ] [ NUM ] ; double delta Hi = this . boundaries [ i ] [ NUM ] - vector . get Entry ( i ) ; double sq Delta Lo = delta Lo * delta Lo ; double sq Delta Hi = delta Hi * delta Hi ; if ( delta Lo < NUM | | delta Hi < NUM ) { if ( sq Delta Hi < sq Delta Lo ) { estimates [ NUM ] + = sq Delta Hi ; estimates [ NUM ] + = sq Delta Lo ; } else { estimates [ NUM ] + = sq Delta Lo ; estimates [ NUM ] + = sq Delta Hi ; } } else { estimates [ NUM ] + = Math . max ( sq Delta Hi , sq Delta Lo ) ; } } return estimates ; }",
    "label": 1
  },
  {
    "text_1": "makes the given visitor visit the annotations of this instruction .",
    "text_2": "protected final void accept Annotations ( final Method Visitor mv ) { int n = visible Type Annotations = = null ? NUM : visible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; + + i ) { Type Annotation Node an = visible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } n = invisible Type Annotations = = null ? NUM : invisible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; + + i ) { Type Annotation Node an = invisible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns true if the given ifd is a valid ifd .",
    "text_2": "public static boolean is Valid Ifd ( int ifd Id ) { return ifd Id = = Ifd Id . TYPE IFD NUM | | ifd Id = = Ifd Id . TYPE IFD NUM | | ifd Id = = Ifd Id . TYPE IFD EXIF | | ifd Id = = Ifd Id . TYPE IFD INTER OPER ABILITY | | ifd Id = = Ifd Id . TYPE IFD GPS ; }",
    "label": 1
  },
  {
    "text_1": "enlarges the simplex by removing the edge line with index p no . the result simplex may be unbounded .",
    "text_2": "public Shape Tile Simplex remove border line ( int p no ) { if ( p no < NUM | | p no > = lines size ( ) ) { return this ; } Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . remove ( p no ) ; return new Shape Tile Simplex ( new arr ) ; }",
    "label": 1
  },
  {
    "text_1": "flushes all the streams for this response .",
    "text_2": "public void flush ( ) throws IO Exception { if ( print Writer ! = null ) { print Writer . flush ( ) ; } if ( gzip Output Stream ! = null ) { gzip Output Stream . flush ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "replaces the characters in the string by a proper regular expression",
    "text_2": "private static String replace Stars ( String init ) { String Builder builder = new String Builder ( ) ; char [ ] chars = init . to Char Array ( ) ; for ( int i = NUM ; i < chars . length ; i + + ) { if ( chars [ i ] = = STRING & & i = = NUM & & chars . length > NUM & & chars [ i + NUM ] = = STRING ) { builder . append ( STRING ) ; i + + ; } else if ( chars [ i ] = = STRING & & i < ( chars . length - NUM ) & & i > NUM & & chars [ i + NUM ] = = STRING & & chars [ i - NUM ] = = STRING ) { builder . delete Char At ( builder . length ( ) - NUM ) ; builder . append ( STRING ) ; } else if ( chars [ i ] = = STRING & & i = = ( chars . length - NUM ) & & i > NUM & & chars [ i - NUM ] = = STRING ) { builder . delete Char At ( builder . length ( ) - NUM ) ; builder . append ( STRING ) ; } else if ( chars [ i ] = = STRING ) { builder . append ( STRING ) ; } else { builder . append ( chars [ i ] ) ; } } return builder . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "does the underlying po ( ! ) object have a pdf attachment",
    "text_2": "public boolean is Pdf Attachment ( ) { if ( get PO ( ) = = null ) return BOOL ; return m po . is Pdf Attachment ( ) ; }",
    "label": 1
  },
  {
    "text_1": "update the volume object to migrate the old consistency groups field into the new consistency group list field .",
    "text_2": "private void migrate Block Volumes ( ) { log . info ( STRING ) ; Db Client db Client = get Db Client ( ) ; List < URI > volume UR Is = db Client . query By Type ( Volume . class , BOOL ) ; Iterator < Volume > volumes = db Client . query Iterative Objects ( Volume . class , volume UR Is , BOOL ) ; List < Block Object > block Objects = new Array List < Block Object > ( ) ; while ( volumes . has Next ( ) ) { block Objects . add ( volumes . next ( ) ) ; } migrate Block Objects ( block Objects ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize . create the httpclient store , tcp client store",
    "text_2": "public void initialize ( ) { if ( is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . create And Get Actor System ( ) ; http Client Store . init ( ) ; tcp Ssh Ping Resource Store . init ( ) ; Parallel Task Manager . get Instance ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING ) ; } else { logger . debug ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "send a log message if logging is enabled .",
    "text_2": "public static void log ( Throwable error , String message , Object . . . args ) { if ( logging Enabled ) { Log . d ( TAG , args . length = = NUM ? message : String . format ( message , args ) , error ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates empty packet which will be filled in parser .",
    "text_2": "Grid Memcached Message ( ) { }",
    "label": 1
  },
  {
    "text_1": "removes an abstrac toption from the container",
    "text_2": "public synchronized void remove ( Abstract Option option ) { if ( options . contains ( option ) ) { int position = index Of ( option ) ; List < Abstract Option > old Options = new Array List < Abstract Option > ( options ) ; options . remove ( option ) ; List < Abstract Option > new Options = get Options ( ) ; option . set Collection ( null ) ; fire Indexed Property Change ( PROP OPTIONS , position , old Options , new Options ) ; } }",
    "label": 1
  },
  {
    "text_1": "instantiates a new movie scrap er metadata panel .",
    "text_2": "public Movie Scraper Metadata Panel ( Movie Scraper Metadata Config config ) { this . config = config ; init Components ( ) ; }",
    "label": 1
  },
  {
    "text_1": "eventually sets to the given value .",
    "text_2": "public final void lazy Set ( int new Value ) { unsafe . put Ordered Int ( this , value Offset , new Value ) ; }",
    "label": 1
  },
  {
    "text_1": "flatten a list into an xmlserializer . the list can later be read back with read this list xml ( ) .",
    "text_2": "public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val = = null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name ! = null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = NUM ; while ( i < n ) { write Value Xml ( val . get ( i ) , null , out ) ; i + + ; } out . end Tag ( null , STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "checks on a message map , if we ' ve seen this message before . the message map is serialized on disk every time we write to it . its initialized from disk when we start the update manager .",
    "text_2": "private boolean have Shown Message Before ( Update Message msg ) { if ( ! msg . is Shown Once ( ) ) return BOOL ; load Seen Messages ( ) ; if ( seen Messages = = null | | seen Messages . size ( ) = = NUM | | ! seen Messages . contains ( msg ) ) { if ( seen Messages = = null ) seen Messages = new Hash Set < > ( ) ; seen Messages . add ( msg ) ; save Seen Messages ( ) ; return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "set reg to the next matching element , or null if none",
    "text_2": "@ Override protected void step ( ) { while ( iter . has Next ( ) ) { reg = ( Svc Reg ) iter . next ( ) ; if ( reg . lease Expiration > now ) return ; } reg = null ; }",
    "label": 1
  },
  {
    "text_1": "sorts the instances based on an attribute . for numeric attributes , instances are sorted in ascending order . for nominal attributes , instances are sorted based on the attribute label ordering specified in the header . instances with missing values for the attribute are placed at the end of the dataset .",
    "text_2": "public void sort ( int att Index ) { double [ ] vals = new double [ num Instances ( ) ] ; Instance [ ] backup = new Instance [ vals . length ] ; for ( int i = NUM ; i < vals . length ; i + + ) { Instance inst = instance ( i ) ; backup [ i ] = inst ; double val = inst . value ( att Index ) ; if ( Utils . is Missing Value ( val ) ) { vals [ i ] = Double . MAX VALUE ; } else { vals [ i ] = val ; } } int [ ] sort Order = Utils . sort With No Missing Values ( vals ) ; for ( int i = NUM ; i < vals . length ; i + + ) { m Instances . set ( i , backup [ sort Order [ i ] ] ) ; } }",
    "label": 1
  },
  {
    "text_1": "this method checks if no overhead rates have been entered for the overhead .",
    "text_2": "private List < Validation Error > check For No Rates Present ( ) { if ( overhead Rates ! = null & & overhead Rates . is Empty ( ) ) return Arrays . as List ( new Validation Error ( STRING , STRING ) ) ; else return null ; }",
    "label": 1
  },
  {
    "text_1": "deletes the alerting definition .",
    "text_2": "public void delete Alerting Definition ( Alerting Definition aler ting Definition ) throws IO Exception { String id = aler ting Definition . get Id ( ) ; Alerting Definition local = existing Alerting Definitions . remove ( id ) ; if ( local ! = null ) { Files . delete If Exists ( path Resolver . get Alerting Definition File Path ( local ) ) ; event Publisher . publish Event ( new Abstract Alerting Definition Event . Alerting Definition Deleted Event ( this , local ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "fired when action got executed .",
    "text_2": "public void action Performed ( Action Event e ) { if ( ! check Modified ( ) ) return ; if ( m Script . get Filename ( ) = = null ) return ; try { m Script . start ( m Args ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; J Option Pane . show Message Dialog ( File Scripting Panel . this , STRING + ex , STRING , J Option Pane . ERROR MESSAGE ) ; } }",
    "label": 1
  },
  {
    "text_1": "add many statements at the same time , remove many statements at the same time . ordering by resource has to be done inside this method . the passed added / removed sets are disjun ct , no statement can be in both",
    "text_2": "@ Override public final synchronized void add Remove Statements ( Collection < Statement > added , Collection < Statement > removed ) throws IO Exception { Map Of List Maps < Resource , String , Statement > rs Added = new Map Of List Maps < Resource , String , Statement > ( ) ; Map Of List Maps < Resource , String , Statement > rs Removed = new Map Of List Maps < Resource , String , Statement > ( ) ; Hash Set < Resource > resources = new Hash Set < Resource > ( ) ; for ( Statement s : added ) { rs Added . add ( s . get Subject ( ) , Search Fields . get Context ID ( s . get Context ( ) ) , s ) ; resources . add ( s . get Subject ( ) ) ; } for ( Statement s : removed ) { rs Removed . add ( s . get Subject ( ) , Search Fields . get Context ID ( s . get Context ( ) ) , s ) ; resources . add ( s . get Subject ( ) ) ; } logger . debug ( STRING + removed . size ( ) + STRING + added . size ( ) + STRING ) ; Bulk Updater updater = new Bulk Update ( ) ; for ( Resource resource : resources ) { Map < String , List < Statement > > stmts To Remove = rs Removed . get ( resource ) ; Map < String , List < Statement > > stmts To Add = rs Added . get ( resource ) ; Set < String > contexts To Update = new Hash Set < String > ( stmts To Add . key Set ( ) ) ; contexts To Update . add All ( stmts To Remove . key Set ( ) ) ; Map < String , Search Document > docs By Context = new Hash Map < String , Search Document > ( ) ; String resource Id = Search Fields . get Resource ID ( resource ) ; Iterable < ? extends Search Document > documents = get Documents ( resource Id ) ; for ( Search Document doc : documents ) { docs By Context . put ( doc . get Context ( ) , doc ) ; } for ( String context Id : contexts To Update ) { String id = Search Fields . form Id String ( resource Id , context Id ) ; Search Document document = docs By Context . get ( context Id ) ; if ( document = = null ) { document = new Document ( id , resource Id , context Id ) ; List < Statement > list = stmts To Add . get ( context Id ) ; if ( list ! = null ) { for ( Statement s : list ) { add Property ( s , document ) ; } } updater . add ( document ) ; if ( stmts To Remove . contains Key ( context Id ) ) logger . info ( STRING , resource , context Id ) ; } else { Map < String , Set < String > > removed Of Resource = null ; { List < Statement > removed Statements = stmts To Remove . get ( context Id ) ; if ( removed Statements ! = null & & ! removed Statements . is Empty ( ) ) { removed Of Resource = new Hash Map < String , Set < String > > ( ) ; for ( Statement r : removed Statements ) { String val = Search Fields . get Literal Property Value As String ( r ) ; if ( val ! = null ) { String field = Search Fields . get Property Field ( r . get Predicate ( ) ) ; Set < String > removed Values = removed Of Resource . get ( field ) ; if ( removed Values = = null ) { removed Values = new Hash Set < String > ( ) ; removed Of Resource . put ( field , removed Values ) ; } removed Values . add ( val ) ; } } } } Search Document new Document = new Document ( id , resource Id , context Id ) ; boolean mutated = copy Document ( new Document , document , removed Of Resource ) ; { List < Statement > added To Resource = stmts To Add . get ( context Id ) ; String val ; if ( added To Resource ! = null & & ! added To Resource . is Empty ( ) ) { Property Cache property Cache = new Property Cache ( new Document ) ; for ( Statement s : added To Resource ) { val = Search Fields . get Literal Property Value As String ( s ) ; if ( val ! = null ) { String field = Search Fields . get Property Field ( s . get Predicate ( ) ) ; if ( ! property Cache . has Property ( field , val ) ) { add Property ( s , new Document ) ; mutated = BOOL ; } } } } } int nr Properties = count Property Values ( new Document ) ; if ( nr Properties > NUM ) { if ( mutated ) { updater . update ( new Document ) ; } } else { updater . delete ( document ) ; } } } } updater . end ( ) ; }",
    "label": 1
  },
  {
    "text_1": "removes wheel changing listener",
    "text_2": "public void remove Changing Listener ( On Wheel Changed Listener listener ) { changing Listeners . remove ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a new identityhashmap with the same mappings and size as this one .",
    "text_2": "@ Override public Object clone ( ) { try { Identity Hash Map < K , V > clone Hash Map = ( Identity Hash Map < K , V > ) super . clone ( ) ; clone Hash Map . element Data = new Element Array ( element Data . length ) ; System . arraycopy ( element Data , NUM , clone Hash Map . element Data , NUM , element Data . length ) ; return clone Hash Map ; } catch ( Clone Not Supported Exception e ) { throw new Assertion Error ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a child element with the given namespace suppor tive name and appends it to the element child node list .",
    "text_2": "public static Element add Child Element NS Element ( Element element , String child Element Name , Document document , String name Space Url ) { Element new Element = document . create Element NS ( name Space Url , child Element Name ) ; element . append Child ( new Element ) ; return element ; }",
    "label": 1
  },
  {
    "text_1": "signals a waiting put . called only from take / poll .",
    "text_2": "private void signal Not Full ( ) { final Reentrant Lock put Lock = this . put Lock ; put Lock . lock ( ) ; try { not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "normalize the attribute value of a non cdata attributes collapsing sequences of space characters ( x20 )",
    "text_2": "private boolean normalize Attr Value ( XML Attributes attributes , int index ) { boolean leading Space = BOOL ; boolean space Start = BOOL ; boolean reading Non Space = BOOL ; int count = NUM ; int e aten = NUM ; String attr Value = attributes . get Value ( index ) ; char [ ] att Value = new char [ attr Value . length ( ) ] ; f Buffer . set Length ( NUM ) ; attr Value . get Chars ( NUM , attr Value . length ( ) , att Value , NUM ) ; for ( int i = NUM ; i < att Value . length ; i + + ) { if ( att Value [ i ] = = STRING ) { if ( reading Non Space ) { space Start = BOOL ; reading Non Space = BOOL ; } if ( space Start & & ! leading Space ) { space Start = BOOL ; f Buffer . append ( att Value [ i ] ) ; count + + ; } else { if ( leading Space | | ! space Start ) { e aten + + ; } } } else { reading Non Space = BOOL ; space Start = BOOL ; leading Space = BOOL ; f Buffer . append ( att Value [ i ] ) ; count + + ; } } if ( count > NUM & & f Buffer . char At ( count - NUM ) = = STRING ) { f Buffer . set Length ( count - NUM ) ; } String new Value = f Buffer . to String ( ) ; attributes . set Value ( index , new Value ) ; return ! attr Value . equals ( new Value ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the contents of a file into a string using the default encoding for the vm . the file is always closed .",
    "text_2": "public static String read File To String ( File file ) throws IO Exception { return read File To String ( file , Charset . default Charset ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "parses all the sessions expiration for the given user .",
    "text_2": "private void parse Session Expiration Time Info ( Element sess ) { String sid = null ; Long exp Time = null ; String temp = sess . get Attribute ( STRING ) ; if ( temp ! = null ) { sid = temp ; } temp = sess . get Attribute ( STRING ) ; if ( temp ! = null ) { exp Time = new Long ( temp ) ; } session Response . add Session For Given UUID ( sid , exp Time ) ; }",
    "label": 1
  },
  {
    "text_1": "draws a x axis marker .",
    "text_2": "private void draw X Axis Marker ( Canvas canvas , double value , Number Format number Format , int spacing ) { String marker = chart By Distance ? number Format . format ( value ) : String Utils . format Elapsed Time ( ( long ) value ) ; Rect rect = get Rect ( x Axis Marker Paint , marker ) ; canvas . draw Text ( marker , get X ( value ) , top Border + effective Height + spacing + rect . height ( ) , x Axis Marker Paint ) ; }",
    "label": 1
  },
  {
    "text_1": "added another ec minfo to the effects for a location .",
    "text_2": "public void add ECM ( ECM Info info ) { ecm Effects . add ( info ) ; }",
    "label": 1
  },
  {
    "text_1": "generates a string representation of a java date object . the string is formatted according to the specification for xml property list dates .",
    "text_2": "private static synchronized String make Date String ( Date date ) { return sdf Default . format ( date ) ; }",
    "label": 1
  },
  {
    "text_1": "get the next gaussian value .",
    "text_2": "public double next Gaussian ( ) { return random . next Gaussian ( ) ; }",
    "label": 1
  },
  {
    "text_1": "it returns the offset separating multipart file headers from the file ' s data .",
    "text_2": "private int strip Multipart Headers ( byte [ ] b , int offset ) { int i = NUM ; for ( i = offset ; i < b . length ; i + + ) { if ( b [ i ] = = STRING & & b [ + + i ] = = STRING & & b [ + + i ] = = STRING & & b [ + + i ] = = STRING ) break ; } return i + NUM ; }",
    "label": 1
  },
  {
    "text_1": "forms a string by repeating the character the given number of times .",
    "text_2": "public static String repeat Character ( char c , int repetitions ) { String Builder s = new String Builder ( repetitions ) ; for ( int i = NUM ; i < repetitions ; i + + ) { s . append ( c ) ; } return s . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "overrides drop behaviour to set the cell style if the target is not a valid drop target and the cells are of the same type ( eg . both vertices or both edges ) .",
    "text_2": "public Object [ ] import Cells ( Object [ ] cells , double dx , double dy , Object target , Point location ) { if ( target = = null & & cells . length = = NUM & & location ! = null ) { target = get Cell At ( location . x , location . y ) ; if ( target instanceof mx I Cell & & cells [ NUM ] instanceof mx I Cell ) { mx I Cell target Cell = ( mx I Cell ) target ; mx I Cell drop Cell = ( mx I Cell ) cells [ NUM ] ; if ( target Cell . is Vertex ( ) = = drop Cell . is Vertex ( ) | | target Cell . is Edge ( ) = = drop Cell . is Edge ( ) ) { mx I Graph Model model = graph . get Model ( ) ; model . set Style ( target , model . get Style ( cells [ NUM ] ) ) ; graph . set Selection Cell ( target ) ; return null ; } } } return super . import Cells ( cells , dx , dy , target , location ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the number of bytes of the document .",
    "text_2": "protected int size ( ) { return document . length ( ) ; }",
    "label": 1
  },
  {
    "text_1": "the natural log of the probability density function of the distribution",
    "text_2": "public double log Pdf ( double x ) { return Math . log ( pdf ( x ) ) ; }",
    "label": 1
  },
  {
    "text_1": "load the service file .",
    "text_2": "public static void load ( Class < ? > parent ) { load ( parent , Class Loader . get System Class Loader ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "get the optional boolean value associated with an index . it returns false if there is no value at that index , or if the value is not boolean . true or the string \" true \" .",
    "text_2": "public boolean opt Boolean ( int index ) { return opt Boolean ( index , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "re - measure the loading views height , and adjust internal padding as necessary",
    "text_2": "protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }",
    "label": 1
  },
  {
    "text_1": "helper method for dumping error logs from docker to file",
    "text_2": "public void dump Log ( String container Id , File log File ) throws Docker Exception , Interrupted Exception { Log Stream error Stream = null ; File Channel file Channel = null ; File Output Stream file Output Stream = null ; try { if ( log File . exists ( ) ) { log File . delete ( ) ; } log File . create New File ( ) ; file Output Stream = new File Output Stream ( log File ) ; file Channel = file Output Stream . get Channel ( ) ; error Stream = docker Client . logs ( container Id , Logs Param . stderr ( ) ) ; while ( error Stream . has Next ( ) ) { Log Message message = error Stream . next ( ) ; Byte Buffer buffer = message . content ( ) ; file Channel . write ( buffer ) ; } } catch ( File Not Found Exception e ) { throw new Docker Exception ( STRING + log File + STRING ) ; } catch ( IO Exception e ) { throw new Docker Exception ( e ) ; } finally { if ( error Stream ! = null ) { error Stream . close ( ) ; } if ( file Channel ! = null ) { try { file Channel . close ( ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } } if ( file Output Stream ! = null ) { try { file Output Stream . close ( ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "test negative number of radix 24",
    "text_2": "public void test Radix NUM Neg ( ) { String value = STRING ; int radix = NUM ; Big Integer a Number = new Big Integer ( value , radix ) ; String result = a Number . to String ( radix ) ; assert True ( result . equals ( value ) ) ; }",
    "label": 1
  },
  {
    "text_1": "store a class with his methods",
    "text_2": "private Map < Key , Array > store ( Class clazz ) { Method [ ] methods = clazz . get Methods ( ) ; Map < Key , Array > methods Map = new Concurrent Hash Map < Key , Array > ( ) ; for ( int i = NUM ; i < methods . length ; i + + ) { store Method ( methods [ i ] , methods Map ) ; } map . put ( clazz , methods Map ) ; return methods Map ; }",
    "label": 1
  },
  {
    "text_1": "get the current position .",
    "text_2": "public int position ( ) { return buff . position ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the iteration has more elements .",
    "text_2": "public boolean has Next ( ) { return index < desc . length ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a byte [ ] containing the remainder of ' in ' .",
    "text_2": "public static byte [ ] read Fully No Close ( Input Stream in ) throws IO Exception { Byte Array Output Stream bytes = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM ] ; int count ; while ( ( count = in . read ( buffer ) ) ! = - NUM ) { bytes . write ( buffer , NUM , count ) ; } return bytes . to Byte Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a table of dates and the number of observations of those dates",
    "text_2": "@ Override public Table summary ( ) { Table table = Table . create ( STRING + name ( ) ) ; Category Column measure = Category Column . create ( STRING ) ; Category Column value = Category Column . create ( STRING ) ; table . add Column ( measure ) ; table . add Column ( value ) ; measure . add ( STRING ) ; value . add ( String . value Of ( size ( ) ) ) ; measure . add ( STRING ) ; value . add ( String . value Of ( count Missing ( ) ) ) ; measure . add ( STRING ) ; value . add ( String . value Of ( min ( ) ) ) ; measure . add ( STRING ) ; value . add ( String . value Of ( max ( ) ) ) ; return table ; }",
    "label": 1
  },
  {
    "text_1": "creates a new abstract point renderer object with default shape and color .",
    "text_2": "public Abstract Point Renderer ( ) { shape = new Rectangle NUM D . Double ( - NUM , - NUM , NUM , NUM ) ; color = new Single Color ( Color . BLACK ) ; value Visible = BOOL ; value Column = NUM ; value Location = Location . CENTER ; value Alignment X = NUM ; value Alignment Y = NUM ; value Rotation = NUM ; value Distance = NUM ; value Color = new Single Color ( Color . BLACK ) ; value Font = Font . decode ( null ) ; error Visible = BOOL ; error Column Top = NUM ; error Column Bottom = NUM ; error Color = new Single Color ( Color . BLACK ) ; error Shape = new Line NUM D . Double ( - NUM , NUM , NUM , NUM ) ; error Stroke = new Basic Stroke ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs a new class from an array of bytes containing a class definition in class file format .",
    "text_2": "protected final Class < ? > define Class ( String class Name , byte [ ] class Rep , int offset , int length ) throws Class Format Error { return define Class ( class Name , class Rep , offset , length , null ) ; }",
    "label": 1
  },
  {
    "text_1": "after rotating , the matrix needs to be translated . this function finds the area of image which was previously centered and adjusts translations so that is again the center , post - rotation .",
    "text_2": "private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates topology refresh thread .",
    "text_2": "private Topology Updater Thread ( ) { super ( id + STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "increases the process size if necessary for the given operator .",
    "text_2": "boolean ensure Process Size Fits ( final Execution Unit process , final Rectangle NUM D rect ) { Dimension process Size = model . get Process Size ( process ) ; if ( process Size = = null ) { return BOOL ; } if ( rect = = null ) { return BOOL ; } boolean needs Resize = BOOL ; double process Width = process Size . get Width ( ) * ( NUM / model . get Zoom Factor ( ) ) ; double process Height = process Size . get Height ( ) * ( NUM / model . get Zoom Factor ( ) ) ; double width = process Width ; double height = process Height ; if ( process Size ! = null ) { if ( process Width < rect . get Max X ( ) + Process Drawer . GRID X OFFSET ) { double diff = rect . get Max X ( ) + Process Drawer . GRID X OFFSET - process Width ; if ( diff > Process Drawer . GRID X OFFSET ) { width + = diff ; } else { width + = Process Drawer . GRID X OFFSET ; } needs Resize = BOOL ; } if ( process Height < rect . get Max Y ( ) + Process Drawer . GRID Y OFFSET ) { double diff = rect . get Max Y ( ) + Process Drawer . GRID Y OFFSET - process Height ; if ( diff > Process Drawer . GRID Y OFFSET ) { height + = diff ; } else { height + = Process Drawer . GRID Y OFFSET ; } needs Resize = BOOL ; } if ( needs Resize ) { model . set Process Width ( process , width ) ; model . set Process Height ( process , height ) ; balance ( ) ; model . fire Process Size Changed ( ) ; return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "describe either rain or snow , depending on the time , temperature and temperature modifiers .",
    "text_2": "private Pair < String , Boolean > describe Rain ( Calendar calendar , int temperature Mod ) { int month = calendar . get ( Calendar . MONTH ) ; month = NUM * Math . abs ( month - NUM ) ; int hour = calendar . get ( Calendar . HOUR OF DAY ) ; hour = Math . abs ( ( hour + NUM ) % NUM - NUM ) / NUM ; int temp = temperature . get Value ( ) - hour - month + ( temperature Mod * NUM ) ; LOGGER . debug ( STRING + temp + STRING + temperature Mod ) ; if ( temp < = - NUM ) { return new Pair < String , Boolean > ( STRING , Boolean . FALSE ) ; } return new Pair < String , Boolean > ( STRING , temp > = - NUM & & th under . get Description ( NUM ) ! = null ) ; }",
    "label": 1
  },
  {
    "text_1": "construct a vector by appending one vector to another vector .",
    "text_2": "public Array Real Vector ( Array Real Vector v1 , Real Vector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . get Dimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , NUM , data , NUM , l1 ) ; for ( int i = NUM ; i < l2 ; + + i ) { data [ l1 + i ] = v2 . get Entry ( i ) ; } }",
    "label": 1
  },
  {
    "text_1": "removes the element at the specified position in this list . shifts any subsequent elements to the left ( subtracts one from their indices ) .",
    "text_2": "public Object remove ( int index ) { Range Check ( index ) ; mod Count + + ; Object old Value = element Data [ index ] ; int num Moved = size - index - NUM ; if ( num Moved > NUM ) System . arraycopy ( element Data , index + NUM , element Data , index , num Moved ) ; element Data [ - - size ] = null ; return old Value ; }",
    "label": 1
  },
  {
    "text_1": "decodes a string where each char of the string represents an ascii ' 0 ' or ' 1 ' .",
    "text_2": "public byte [ ] to Byte Array ( String ascii ) { if ( ascii = = null ) { return EMPTY BYTE ARRAY ; } return from Ascii ( ascii . to Char Array ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "uninstall extension by its unique row type .",
    "text_2": "private void uninstall ( String row Type ) { if ( extensions By Row type . contains Key ( row Type ) ) { extensions By Row type . remove ( row Type ) ; File f = get Extension File ( row Type ) ; if ( f . exists ( ) ) { File Utils . delete Quietly ( f ) ; } else { log . warn ( STRING + row Type ) ; } } else { log . warn ( STRING + row Type ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a list of nodes from variable analysis results .",
    "text_2": "protected List < Node > create Discrete Variable List ( Discrete Variable Analysis variable Analysis ) { List < Node > nodes = new Array List < > ( variable Analysis . get Num Of Cols ( ) ) ; Discrete Var Info [ ] variables = variable Analysis . get Discrete Var Infos ( ) ; for ( Discrete Var Info variable : variables ) { if ( variable ! = null ) { nodes . add ( new Discrete Variable ( variable . get Name ( ) , variable . get Categories ( ) ) ) ; } } return nodes ; }",
    "label": 1
  },
  {
    "text_1": "creates a new logwriter and adds it to the config properties . the config can then be used to connect to distributed system , thus providing early access to the logwriter before connecting . this call does not connect to the distributed system . it simply creates and returns the logwriter that will eventually be used by the distributed system that connects using config .",
    "text_2": "public static Log Writer create Log Writer ( final Properties properties ) { Properties non Default = properties ; if ( non Default = = null ) { non Default = new Properties ( ) ; } Distributed Test Utils . add Hydra Properties ( non Default ) ; Distribution Config dc = new Distribution Config Impl ( non Default ) ; Log Writer logger = Log Writer Factory . create Log Writer Logger ( BOOL , BOOL , dc , BOOL ) ; non Default . put ( Distribution Config . LOG WRITER NAME , logger ) ; return logger ; }",
    "label": 1
  },
  {
    "text_1": "omits quotes of all kinds if they exist in the string",
    "text_2": "static String omit Quotes If Exist ( String str ) { if ( str = = null ) { return null ; } if ( ( ( str . char At ( NUM ) = = STRING ) | | ( str . char At ( NUM ) = = STRING ) ) & & ( str . length ( ) > = NUM ) ) { str = str . substring ( NUM , str . length ( ) - NUM ) ; } return str ; }",
    "label": 1
  },
  {
    "text_1": "construct an xpath object . ( needs review - sc ) this method initializes an xpath parser / compiler and compiles the expression .",
    "text_2": "public X Path ( String expr String , Source Locator locator , Prefix Resolver prefix Resolver , int type ) throws javax . xml . transform . Transformer Exception { this ( expr String , locator , prefix Resolver , type , null ) ; }",
    "label": 1
  },
  {
    "text_1": "refresh the element . this enables / disables any + or - buttons if the clamp is reached , as well as call the callback if required .",
    "text_2": "public void refresh ( ) { label . set Text ( String . value Of ( Math Helper . round ( val , NUM ) ) ) ; if ( val = = min ) minus . set Enabled ( BOOL ) ; else minus . set Enabled ( BOOL ) ; if ( val = = max ) plus . set Enabled ( BOOL ) ; else plus . set Enabled ( BOOL ) ; if ( cb ! = null ) cb . callback ( val ) ; plus . repaint ( ) ; minus . repaint ( ) ; if ( progress ! = null ) { progress . set Value ( val / max ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a new type script translator .",
    "text_2": "public Java NUM Type Script Translator ( Trans pilation Handler log Handler , J Sweet Context context , JC Compilation Unit compilation Unit , boolean preserve Source Line Numbers ) { super ( log Handler , context , compilation Unit , new Java NUM Type Script Adapter ( context ) , preserve Source Line Numbers ) ; }",
    "label": 1
  },
  {
    "text_1": "remove all elements from the list .",
    "text_2": "public void clear ( ) { m Strings . clear ( ) ; notify Data Set Changed ( ) ; }",
    "label": 1
  },
  {
    "text_1": "remove from listeners list",
    "text_2": "public void remove Listener ( Tracking Listener listener ) { listeners . remove ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "expands the digit string of an ordinal number .",
    "text_2": "public static void expand Ordinal ( String raw Number String , Word Relation word Relation ) { String number String = Utilities . delete Char ( raw Number String , STRING ) ; expand Number ( number String , word Relation ) ; Item last Item = word Relation . get Tail ( ) ; if ( last Item ! = null ) { Feature Set feature Set = last Item . get Features ( ) ; String last Number = feature Set . get String ( STRING ) ; String ordinal = find Match In Array ( last Number , digit NUM num , ord NUM num ) ; if ( ordinal = = null ) { ordinal = find Match In Array ( last Number , digit NUM teen , ord NUM teen ) ; } if ( ordinal = = null ) { ordinal = find Match In Array ( last Number , digit NUM enty , ord NUM enty ) ; } if ( last Number . equals ( STRING ) ) { ordinal = STRING ; } else if ( last Number . equals ( STRING ) ) { ordinal = STRING ; } else if ( last Number . equals ( STRING ) ) { ordinal = STRING ; } if ( ordinal ! = null ) { word Relation . set Last Word ( ordinal ) ; } } }",
    "label": 1
  },
  {
    "text_1": "adds the specified object at the end of this vector .",
    "text_2": "@ Override public synchronized boolean add ( E object ) { if ( element Count = = element Data . length ) { grow By One ( ) ; } element Data [ element Count + + ] = object ; mod Count + + ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "create a new pooled connection object . not connected nor validated .",
    "text_2": "protected Pooled Connection create ( boolean increment Counter ) { if ( increment Counter ) size . increment And Get ( ) ; Pooled Connection con = new Pooled Connection ( get Pool Properties ( ) , this ) ; return con ; }",
    "label": 1
  },
  {
    "text_1": "removes the entries related to the given package in memory and persistent db .",
    "text_2": "public synchronized void remove Icons For Pkg ( String package Name , User Handle Compat user ) { remove From Mem Cache Locked ( package Name , user ) ; long user Serial = m User Manager . get Serial Number For User ( user ) ; m Icon Db . delete ( Icon DB . COLUMN COMPONENT + STRING + Icon DB . COLUMN USER + STRING , new String [ ] { package Name + STRING , Long . to String ( user Serial ) } ) ; }",
    "label": 1
  },
  {
    "text_1": "attempts to prepare the request for a retry . if there are no more attempts remaining in the request ' s retry policy , a timeout exception is thrown .",
    "text_2": "private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }",
    "label": 1
  },
  {
    "text_1": "based on the list contained in the string , build a set of subfield definitions .",
    "text_2": "protected boolean build Subfield Defns ( String psz Sublist ) { if ( psz Sublist . char At ( NUM ) = = STRING ) { b Repeating Subfields = BOOL ; psz Sublist = psz Sublist . substring ( NUM ) ; } Vector pap sz Subfield Names = Prop Utils . parse Markers ( psz Sublist , STRING ) ; pa o Subfield Defns = new Vector ( ) ; for ( Iterator it = pap sz Subfield Names . iterator ( ) ; it . has Next ( ) ; ) { DDF Subfield Definition d df sd = new DDF Subfield Definition ( ) ; d df sd . set Name ( ( String ) it . next ( ) ) ; pa o Subfield Defns . add ( d df sd ) ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "transform a floating - point 2d position coordinate to a screen coordinate . the psp ( tested using 3 d studio ) is applying the following transformation : 0 . 56 2 transformed to 0 0 . 5 63 transformed to 1",
    "text_2": "protected static final int position Coordinate NUM D ( float value ) { return ( int ) ( value + NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "appending the like operator clause .",
    "text_2": "public Statement like ( String expr ) { statement . append ( STRING ) ; append Escaped SQL String ( statement , expr ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "merge to path es to one",
    "text_2": "public static String merge Path ( String current , String real Path ) throws Malformed URL Exception { String curr Dir ; if ( current = = null | | current . index Of ( STRING ) = = - NUM ) curr Dir = STRING ; else if ( current . ends With ( STRING ) ) curr Dir = current ; else curr Dir = current . substring ( NUM , current . last Index Of ( STRING ) + NUM ) ; String path ; if ( real Path . starts With ( STRING ) ) path = curr Dir + real Path . substring ( NUM ) ; else if ( real Path . starts With ( STRING ) ) path = real Path ; else if ( ! real Path . starts With ( STRING ) ) path = curr Dir + real Path ; else { while ( real Path . starts With ( STRING ) | | curr Dir . length ( ) = = NUM ) { real Path = real Path . substring ( NUM ) ; curr Dir = curr Dir . substring ( NUM , curr Dir . length ( ) - NUM ) ; int index = curr Dir . last Index Of ( STRING ) ; if ( index = = - NUM ) throw new Malformed URL Exception ( STRING ) ; curr Dir = curr Dir . substring ( NUM , index + NUM ) ; } path = curr Dir + real Path ; } return path ; }",
    "label": 1
  },
  {
    "text_1": "divide : rounding mode is round half up , result is positive ; distance = - 1",
    "text_2": "public void test Divide Round Half Up Pos ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND HALF UP ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a directory listing of the specified directory .",
    "text_2": "public String [ ] read Directory ( String dir ) { if ( dir = = null ) { throw new Null Pointer Exception ( STRING ) ; } String Array Out list Out = new String Array Out ( ) ; try { check Result ( Lib I Mobile Device . af c read directory ( get Ref ( ) , dir , list Out ) ) ; String Array list = list Out . get Value ( ) ; Array List < String > result = new Array List < String > ( ) ; if ( list ! = null ) { for ( int i = NUM ; ; i + + ) { String s = list . get ( i ) ; if ( s = = null ) { break ; } result . add ( s ) ; } } return result . to Array ( new String [ result . size ( ) ] ) ; } finally { Lib I Mobile Device . delete String Array values z ( list Out . get Value ( ) ) ; list Out . delete ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "use this manager as security manager",
    "text_2": "public void apply ( ) throws Illegal State Exception { try { System . set Security Manager ( this ) ; } catch ( Security Exception e ) { logger . error ( STRING , e ) ; throw new Illegal State Exception ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "remove a network connection from a vm ' s networks .",
    "text_2": "public boolean remove Network Connection ( Network Connection network Connection ) { return network Connections . remove ( network Connection ) ; }",
    "label": 1
  },
  {
    "text_1": "communicate with t master with command",
    "text_2": "@ Visible For Testing public static boolean send To T Master ( String command , String topology Name , Scheduler State Manager Adaptor state Manager , Network Utils . Tunnel Config tunnel Config ) { LOG . fine ( STRING + topology Name ) ; Topology Master . T Master Location location = state Manager . get T Master Location ( topology Name ) ; if ( location = = null ) { LOG . severe ( STRING + topology Name ) ; return BOOL ; } LOG . fine ( STRING + topology Name ) ; String url = String . format ( STRING , location . get Host ( ) , location . get Controller Port ( ) , command , location . get Topology Id ( ) ) ; try { URL endpoint = new URL ( url ) ; LOG . fine ( STRING + endpoint ) ; return send Get Request ( endpoint , command , tunnel Config ) ; } catch ( Malformed URL Exception e ) { throw new Runtime Exception ( STRING + url , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "check if the download has been paused or canceled , stopping the request appropriately if it has been .",
    "text_2": "private void check Paused Or Canceled ( State state ) throws Stop Request { if ( m Service . get Control ( ) = = Downloader Service . CONTROL PAUSED ) { int status = m Service . get Status ( ) ; switch ( status ) { case Downloader Service . STATUS PAUSED BY APP : throw new Stop Request ( m Service . get Status ( ) , STRING ) ; } } }",
    "label": 1
  },
  {
    "text_1": "returns the tip text for this property",
    "text_2": "public String print Leaf Models Tip Text ( ) { return STRING ; }",
    "label": 1
  },
  {
    "text_1": "deletes all instances of class t in the database .",
    "text_2": "@ Transactional public int delete All ( ) { List < T > all Entities = retrieve All ( ) ; for ( T entity : all Entities ) { delete ( entity ) ; } return all Entities . size ( ) ; }",
    "label": 1
  },
  {
    "text_1": "pad the string with the specific character to ensure the string is at least the specified length .",
    "text_2": "public static String pad ( String original , int length , char pad Char ) { if ( original . length ( ) > = length ) return original ; String Builder sb = new String Builder ( original ) ; while ( sb . length ( ) < length ) { sb . append ( pad Char ) ; } return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "verifies the case when borrow ! = 0 in the private divide method .",
    "text_2": "public void test Division Kn uth NUM ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { - NUM , - NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "runs the test case .",
    "text_2": "public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . replace Data ( NUM , NUM , STRING ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }",
    "label": 1
  },
  {
    "text_1": "returns whether this vector is collinear with another vector .",
    "text_2": "public boolean is Coll inear With ( Vector other ) { if ( x = = NUM & & y = = NUM & & z = = NUM ) { return BOOL ; } final double other X = other . x ; final double other Y = other . y ; final double other Z = other . z ; if ( other X = = NUM & & other Y = = NUM & & other Z = = NUM ) { return BOOL ; } if ( ( x = = NUM ) ! = ( other X = = NUM ) ) return BOOL ; if ( ( y = = NUM ) ! = ( other Y = = NUM ) ) return BOOL ; if ( ( z = = NUM ) ! = ( other Z = = NUM ) ) return BOOL ; final double quotient X = other X / x ; if ( ! Double . is Na N ( quotient X ) ) { return other . equals ( multiply ( quotient X ) ) ; } final double quotient Y = other Y / y ; if ( ! Double . is Na N ( quotient Y ) ) { return other . equals ( multiply ( quotient Y ) ) ; } final double quotient Z = other Z / z ; if ( ! Double . is Na N ( quotient Z ) ) { return other . equals ( multiply ( quotient Z ) ) ; } throw new Runtime Exception ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the index of the java like extension of the given file name or - 1 if it doesn ' t end with a known java like extension . note this is the index of the ' . ' even if it is not considered part of the extension .",
    "text_2": "public static int index Of Java Like Extension ( String file Name ) { int file Name Length = file Name . length ( ) ; char [ ] [ ] java Like Extensions = get Java Like Extensions ( ) ; extensions : for ( int i = NUM , length = java Like Extensions . length ; i < length ; i + + ) { char [ ] extension = java Like Extensions [ i ] ; int extension Length = extension . length ; int extension Start = file Name Length - extension Length ; int dot Index = extension Start - NUM ; if ( dot Index < NUM ) continue ; if ( file Name . char At ( dot Index ) ! = STRING ) continue ; for ( int j = NUM ; j < extension Length ; j + + ) { if ( file Name . char At ( extension Start + j ) ! = extension [ j ] ) continue extensions ; } return dot Index ; } return - NUM ; }",
    "label": 1
  },
  {
    "text_1": "adds the card to the view",
    "text_2": "private void add Card ( Shared Preferences shared Preferences , String key ) { String json = shared Preferences . get String ( key , null ) ; if ( json ! = null ) { try { JSON Object json Data = new JSON Object ( json ) ; if ( json Data . has ( IMAGE KEY ) ) { String image = json Data . get String ( IMAGE KEY ) ; List < I Topic > cards = get Source Topic Model ( ) ; switch ( key ) { case POOL KEY : cards . add ( NUM , Cards . pool ( image , get Activity ( ) ) ) ; remove Duplicates ( POOL KEY , cards ) ; break ; case VIDEO KEY : switch ( json Data . get String ( ID KEY ) ) { case POOL CAMERA ID : m Great Shot Url = json Data . get String ( URL KEY ) ; m El v . set On Group Click Listener ( great Shot Listener ) ; cards . add ( NUM , Cards . pool Video ( m Great Shot Url , get Activity ( ) ) ) ; remove Duplicates ( VIDEO KEY , cards ) ; break ; } break ; case FOOD KEY : cards . add ( NUM , Cards . food ( image , get Activity ( ) ) ) ; remove Duplicates ( FOOD KEY , cards ) ; break ; case PRIN TER NUMD KEY : cards . add ( NUM , Cards . printer NUM d ( image , get Activity ( ) ) ) ; remove Duplicates ( PRIN TER NUMD KEY , cards ) ; break ; } } else if ( json Data . has ( MESSAGE KEY ) ) { String message = json Data . get String ( MESSAGE KEY ) ; List < I Topic > cards = get Source Topic Model ( ) ; cards . add ( NUM , Cards . test ( message , get Activity ( ) ) ) ; } UI . execute ( null ) ; } catch ( JSON Exception e ) { e . print Stack Trace ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "return a leaf cell given its cube face ( range 0 . . 5 ) and i - and j - coordinates ( see s2 . h ) .",
    "text_2": "public static S2 Cell Id from Face IJ ( int face , int i , int j ) { long n [ ] = { NUM , face < < ( POS BITS - NUM ) } ; int bits = ( face & SWAP MASK ) ; for ( int k = NUM ; k > = NUM ; - - k ) { bits = get Bits ( n , i , j , k , bits ) ; } S2 Cell Id s = new S2 Cell Id ( ( ( ( n [ NUM ] < < NUM ) + n [ NUM ] ) < < NUM ) + NUM ) ; return s ; }",
    "label": 1
  },
  {
    "text_1": "convert parameters using methods of this utility class",
    "text_2": "public static Object [ ] convert Params ( Object [ ] source , Class < ? > [ ] target ) { Object [ ] converted = new Object [ target . length ] ; for ( int i = NUM ; i < target . length ; i + + ) { converted [ i ] = convert ( source [ i ] , target [ i ] ) ; } return converted ; }",
    "label": 1
  },
  {
    "text_1": "fill in a header with information that points to this data .",
    "text_2": "@ Override public void fill Header ( Header hdr ) { try { Standard . context ( Ascii Table . class ) ; hdr . set X tension ( STRING ) ; hdr . set Bit pix ( Basic HDU . BIT PIX BYTE ) ; hdr . set N axes ( NUM ) ; hdr . set N axis ( NUM , this . row Len ) ; hdr . set N axis ( NUM , this . n Rows ) ; Cursor < String , Header Card > iter = hdr . iterator ( ) ; iter . set Key ( N AXIS NUM . key ( ) ) ; iter . next ( ) ; iter . add ( new Header Card ( P COUNT . key ( ) , NUM , P COUNT . comment ( ) ) ) ; iter . add ( new Header Card ( G COUNT . key ( ) , NUM , G COUNT . comment ( ) ) ) ; iter . add ( new Header Card ( T FIELDS . key ( ) , this . n Fields , T FIELDS . comment ( ) ) ) ; for ( int i = NUM ; i < this . n Fields ; i + = NUM ) { add Col Info ( i , iter ) ; } } catch ( Header Card Exception e ) { LOG . log ( Level . SEVERE , STRING + e . get Message ( ) , e ) ; } finally { Standard . context ( null ) ; } }",
    "label": 1
  },
  {
    "text_1": "read small < 5 mb text files to string .",
    "text_2": "public static final String read File ( File file ) throws IO Exception { Buffered Input Stream in = null ; try { in = new Buffered Input Stream ( new File Input Stream ( file ) ) ; Simple Byte Buffer buffer = new Simple Byte Buffer ( ) ; byte [ ] buf = new byte [ NUM ] ; int len ; while ( ( len = in . read ( buf ) ) ! = - NUM ) { buffer . put ( buf , len ) ; } return new String ( buffer . buffer , NUM , buffer . write ) ; } finally { if ( null ! = in ) { in . close ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "an aes key derived from a base 64 encoded key . this does not generate the key . it ' s not random or a p be key .",
    "text_2": "public static Secret Keys keys ( String keys Str ) throws Invalid Key Exception { String [ ] keys Arr = keys Str . split ( STRING ) ; if ( keys Arr . length ! = NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else { byte [ ] confidentiality Key = Base NUM . decode ( keys Arr [ NUM ] , BASE NUM FLAGS ) ; if ( confidentiality Key . length ! = AES KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + AES KEY LENGTH BITS + STRING ) ; } byte [ ] integrity Key = Base NUM . decode ( keys Arr [ NUM ] , BASE NUM FLAGS ) ; if ( integrity Key . length ! = HMAC KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + HMAC KEY LENGTH BITS + STRING ) ; } Secret Keys secret Keys = new Secret Keys ( ) ; Secret Key Spec secret Key Spec = new Secret Key Spec ( ) ; secret Key Spec . generate ( confidentiality Key , NUM , confidentiality Key . length , CIPHER ) ; Secret Key Spec secret Key Spec NUM = new Secret Key Spec ( ) ; secret Key Spec NUM . generate ( integrity Key , HMAC ALGORITHM ) ; secret Keys . set Confidentiality Key ( secret Key Spec ) ; secret Keys . set Integrity Key ( secret Key Spec NUM ) ; return secret Keys ; } }",
    "label": 1
  },
  {
    "text_1": "eclipse detect sources inside zip automatically while idea doesn ' t . so . eml contains expanded roots which should replace zip root read from . classpath",
    "text_2": "private static void replace Collapsed By Eclipse Source Roots ( Element lib Element , Library . Modifiable Model modifiable Model ) { String [ ] src Urls From Classpath = modifiable Model . get Urls ( Order Root Type . SOURCES ) ; LOG . assert True ( src Urls From Classpath . length < = NUM ) ; final String eclipse Url = src Urls From Classpath . length > NUM ? src Urls From Classpath [ NUM ] : null ; for ( Element r : lib Element . get Children ( SR C ROOT ATTR ) ) { final String url = r . get Attribute Value ( STRING ) ; final String bind Attr = r . get Attribute Value ( SR C ROOT BIND ATTR ) ; boolean not Bind = bind Attr ! = null & & ! Boolean . parse Boolean ( bind Attr ) ; if ( not Bind ) { modifiable Model . add Root ( url , Order Root Type . SOURCES ) ; } else if ( eclipse Url ! = null & & are Urls Point The Same ( url , eclipse Url ) & & ! Comparing . str Equal ( url , eclipse Url ) ) { modifiable Model . add Root ( url , Order Root Type . SOURCES ) ; if ( src Urls From Classpath ! = null & & src Urls From Classpath . length = = NUM ) { modifiable Model . remove Root ( eclipse Url , Order Root Type . SOURCES ) ; src Urls From Classpath = null ; } } } }",
    "label": 1
  },
  {
    "text_1": "use vict ory factory to generate a new vict ory condition checker provided that the vict ory context is saved properly , calling this method at any time is ok and should not affect anything unless the vict ory condition - config options have changed .",
    "text_2": "public void create Victory Conditions ( ) { victory = vf . create Victory ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a fraction corresponding to the given edit rate string .",
    "text_2": "public static Big Fraction parse Edit Rate ( String edit Rate ) { edit Rate = edit Rate . contains ( STRING ) ? r Frame Rate To Edit Rate ( edit Rate ) : edit Rate ; String [ ] parts = edit Rate . split ( STRING ) ; try { if ( parts . length = = NUM ) { return new Big Fraction ( Long . parse Long ( parts [ NUM ] ) , Long . parse Long ( parts [ NUM ] ) ) ; } else if ( parts . length = = NUM ) { return new Big Fraction ( Long . parse Long ( parts [ NUM ] ) ) ; } } catch ( Number Format Exception e ) { throw new Conversion Helper Exception ( STRING , e ) ; } throw new Conversion Helper Exception ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if shard exists and is avail abe for updates",
    "text_2": "protected boolean shard Available ( @ Nullable Index Shard shard ) { return shard ! = null & & shard . can Index ( ) & & CAN UPDATE INDEX BUFFER STATES . contains ( shard . state ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "retrieves the event binder object to bind an eventlistener to ths eventbus that only accepts a specific subclass of & lt ; t & gt ;",
    "text_2": "public < E extends T > Event Binder < E > on ( ) { return new Event Binder < > ( Optional . empty ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "return true if the sentence is empty .",
    "text_2": "public boolean is Empty ( ) { return ( sentence Type = = Sentence Type . UNDEFINED ) & & expressions . is Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "filter out elements that have a property value equal to provided value . ? s ? p ? o . filter not exists ? s < key > < value > .",
    "text_2": "@ Override public Graph Query has Not ( final String key , final Object value ) { criteria . add ( new Has Not ( key , value ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "create the command string for deleting file system export .",
    "text_2": "public String format Delete Nfs Export Cmd ( String data Mover , String path ) { String Builder cmd = new String Builder ( ) ; cmd . append ( STRING ) ; cmd . append ( data Mover ) ; cmd . append ( STRING ) ; cmd . append ( STRING ) ; cmd . append ( path ) ; return cmd . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an ansi output stream handler . we return whatever was passed if we determine we cannot handle ansi based on kernel 32 calls .",
    "text_2": "private static Output Stream wrap Output Stream ( final Output Stream stream ) { String os = System . get Property ( STRING ) ; if ( os . starts With ( STRING ) ) { try { return new Windows Ansi Output Stream ( stream ) ; } catch ( Throwable ignore ) { } return new Ansi Output Stream ( stream ) ; } return stream ; }",
    "label": 1
  },
  {
    "text_1": "when connected , subscribe to the necessary channels to get properly notified",
    "text_2": "private void on Connect ( ) { connection State = Connection State . Connected ; check For Updated Flight = BOOL ; subscribe ( String . format ( traffic Alert Channel , flight Id ) ) ; subscribe ( String . format ( situ ational Awareness Channel , flight Id ) ) ; }",
    "label": 1
  },
  {
    "text_1": "updates the throughput counters .",
    "text_2": "public void update Throughput ( long current Time ) { throughput Calculation Lock . lock ( ) ; try { int interval = ( int ) ( current Time - last Throughput Calculation Time ) ; long min Interval = get Throughput Calculation Interval In Millis ( ) ; if ( ( min Interval = = NUM ) | | ( interval < min Interval ) ) { return ; } long read Bytes = this . read Bytes ; long written Bytes = this . written Bytes ; long read Messages = this . read Messages ; long written Messages = this . written Messages ; read Bytes Throughput = ( read Bytes - last Read Bytes ) * NUM / interval ; written Bytes Throughput = ( written Bytes - last Written Bytes ) * NUM / interval ; read Messages Throughput = ( read Messages - last Read Messages ) * NUM / interval ; written Messages Throughput = ( written Messages - last Written Messages ) * NUM / interval ; if ( read Bytes Throughput > largest Read Bytes Throughput ) { largest Read Bytes Throughput = read Bytes Throughput ; } if ( written Bytes Throughput > largest Written Bytes Throughput ) { largest Written Bytes Throughput = written Bytes Throughput ; } if ( read Messages Throughput > largest Read Messages Throughput ) { largest Read Messages Throughput = read Messages Throughput ; } if ( written Messages Throughput > largest Written Messages Throughput ) { largest Written Messages Throughput = written Messages Throughput ; } last Read Bytes = read Bytes ; last Written Bytes = written Bytes ; last Read Messages = read Messages ; last Written Messages = written Messages ; last Throughput Calculation Time = current Time ; } finally { throughput Calculation Lock . unlock ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "checks a given class",
    "text_2": "public static void verify ( final Class Reader cr , final boolean dump , final Print Writer pw ) { verify ( cr , null , dump , pw ) ; }",
    "label": 1
  },
  {
    "text_1": "if the projection is not null , generate the omgraphic .",
    "text_2": "protected void generate OM Graphic ( OM Graphic g ) { if ( g ! = null & & g . get Need To Regenerate ( ) ) { Projection proj = get Projection ( ) ; if ( proj ! = null ) { g . generate ( proj ) ; } else if ( DEBUG ) { Debug . output ( STRING + g . get Need To Regenerate ( ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "with this method extensions might register additional aggregation functions if needed .",
    "text_2": "public static void register New Aggregation Function ( String name , Class < ? extends Aggregation Function > clazz , Aggregation Function Meta Data Provider meta Data Provider ) { AG GRE ATION FUNCTIONS . put ( name , clazz ) ; AGGREGATION FUNCTIONS META DATA PROVIDER . put ( name , meta Data Provider ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the download meant to be treated as an attachment .",
    "text_2": "public static boolean is Attachment ( String content Disposition ) { return content Disposition ! = null & & content Disposition . region Matches ( BOOL , NUM , STRING , NUM , NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "handle mouse moved events ( used for firing tool tip descriptions over graphics )",
    "text_2": "public boolean mouse Moved ( Mouse Event e ) { Esri Graphic List list = get Esri Graphic List ( ) ; boolean ret = BOOL ; if ( list ! = null ) { OM Graphic omg = list . find Closest ( e . get X ( ) , e . get Y ( ) , NUM ) ; if ( omg ! = null ) { int index ; Integer I = ( ( Integer ) omg . get Attribute ( SHAPE INDEX ATTRIBUTE ) ) ; if ( I ! = null ) { index = I . int Value ( ) ; } else { index = list . index Of ( omg ) ; } if ( parent Layer = = null ) { Component comp = get Component ( ) ; if ( comp instanceof Layer ) { parent Layer = ( Layer ) comp ; } } if ( parent Layer ! = null ) { parent Layer . fire Request Tool Tip ( get Description ( index ) ) ; } ret = BOOL ; } else if ( parent Layer ! = null ) { parent Layer . fire Hide Tool Tip ( ) ; } } return ret ; }",
    "label": 1
  },
  {
    "text_1": "add an enemy unit to the priority list .",
    "text_2": "public void add Priority Unit ( String id ) { if ( ! String Util . is Positive Integer ( id ) ) { return ; } add Priority Unit ( Integer . parse Int ( id ) ) ; }",
    "label": 1
  },
  {
    "text_1": "tests this object for equality with another object .",
    "text_2": "@ Override public boolean equals ( Object obj ) { if ( obj = = this ) { return BOOL ; } if ( ! ( obj instanceof Default Drawing Supplier ) ) { return BOOL ; } Default Drawing Supplier that = ( Default Drawing Supplier ) obj ; if ( ! Arrays . equals ( this . paint Sequence , that . paint Sequence ) ) { return BOOL ; } if ( this . paint Index ! = that . paint Index ) { return BOOL ; } if ( ! Arrays . equals ( this . outline Paint Sequence , that . outline Paint Sequence ) ) { return BOOL ; } if ( this . outline Paint Index ! = that . outline Paint Index ) { return BOOL ; } if ( ! Arrays . equals ( this . stroke Sequence , that . stroke Sequence ) ) { return BOOL ; } if ( this . stroke Index ! = that . stroke Index ) { return BOOL ; } if ( ! Arrays . equals ( this . outline Stroke Sequence , that . outline Stroke Sequence ) ) { return BOOL ; } if ( this . outline Stroke Index ! = that . outline Stroke Index ) { return BOOL ; } if ( ! equal Shapes ( this . shape Sequence , that . shape Sequence ) ) { return BOOL ; } if ( this . shape Index ! = that . shape Index ) { return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "throws a parse exception with line / column information .",
    "text_2": "protected void throw Parse Exception ( Parse Exception e ) throws Parse Exception { if ( locator ! = null ) { String element Location = STRING ; if ( cur Handler ! = null ) { element Location + = STRING + cur Handler . q Name ; } String location = STRING + String . value Of ( locator . get Line Number ( ) ) + STRING + String . value Of ( locator . get Column Number ( ) ) + element Location + STRING ; Log Utils . log Exception ( logger , Level . FINE , location , e ) ; throw new Parse Exception ( location + e . get Message ( ) , e ) ; } else { Log Utils . log Exception ( logger , Level . FINE , null , e ) ; throw e ; } }",
    "label": 1
  },
  {
    "text_1": "indicates whether the given date satisfies the cron expression . note that milliseconds are ignored , so two dates falling on different milliseconds of the same second will always have the same result here .",
    "text_2": "public boolean is Satisfied By ( Date date ) { Calendar test Date Cal = Calendar . get Instance ( get Time Zone ( ) ) ; test Date Cal . set Time ( date ) ; test Date Cal . set ( Calendar . MILLISECOND , NUM ) ; Date original Date = test Date Cal . get Time ( ) ; test Date Cal . add ( Calendar . SECOND , - NUM ) ; Date time After = get Time After ( test Date Cal . get Time ( ) ) ; return ( ( time After ! = null ) & & ( time After . equals ( original Date ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "construct a logrecord with the given level and message values . the sequence property will be initialized with a new unique value . these sequence values are allocated in increasing order within a vm . the millis property will be initialized to the current time . the thread id property will be initialized with a unique id for the current thread . all other properties will be initialized to \" null \" .",
    "text_2": "public Log Record ( Level level , String msg ) { level . get Class ( ) ; this . level = level ; message = msg ; sequence Number = global Sequence Number . get And Increment ( ) ; thread ID = default Thread ID ( ) ; millis = System . current Time Millis ( ) ; need To Infer Caller = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "reports a warning . warnings are non - fatal and can be safely ignored by most applications .",
    "text_2": "@ Override public void warning ( String domain , String key , XML Parse Exception exception ) throws XNI Exception { if ( f Error Handler ! = null ) { SAX Parse Exception sax Exception = create SAX Parse Exception ( exception ) ; try { f Error Handler . warning ( sax Exception ) ; } catch ( SAX Parse Exception e ) { throw create XML Parse Exception ( e ) ; } catch ( SAX Exception e ) { throw create XNI Exception ( e ) ; } } }",
    "label": 1
  },
  {
    "text_1": "gets the client connection and open the channel in a non - blocking mode so we will read whatever is available and loop until all data has been read .",
    "text_2": "public Client ( final Server Socket Channel server ) throws IO Exception { try { client = server . accept ( ) ; client . configure Blocking ( BOOL ) ; if ( ! client . finish Connect ( ) ) throw new IO Exception ( STRING ) ; client Selector = Selector . open ( ) ; client Key = client . register ( client Selector , Selection Key . OP READ ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING ) ; } catch ( IO Exception ex ) { close ( ) ; throw ex ; } }",
    "label": 1
  },
  {
    "text_1": "initializes the signature algorithm for signing a message .",
    "text_2": "private void init Sign ( ) { mess Digest Trees . reset ( ) ; G MSS Private Key Parameters gmss Private Key = ( G MSS Private Key Parameters ) key ; if ( gmss Private Key . is Used ( ) ) { throw new Illegal State Exception ( STRING ) ; } if ( gmss Private Key . get Index ( NUM ) > = gmss Private Key . get Num Leafs ( NUM ) ) { throw new Illegal State Exception ( STRING ) ; } this . gmss PS = gmss Private Key . get Parameters ( ) ; this . num Layer = gmss PS . get Num Of Layers ( ) ; byte [ ] seed = gmss Private Key . get Current Seeds ( ) [ num Layer - NUM ] ; byte [ ] OTS Seed = new byte [ md Length ] ; byte [ ] dummy = new byte [ md Length ] ; System . arraycopy ( seed , NUM , dummy , NUM , md Length ) ; OTS Seed = gmss Random . next Seed ( dummy ) ; this . ots = new W intern itz OT Signature ( OTS Seed , digest Provider . get ( ) , gmss PS . get W intern itz Parameter ( ) [ num Layer - NUM ] ) ; byte [ ] [ ] [ ] help Current Auth Paths = gmss Private Key . get Current Auth Paths ( ) ; current Auth Paths = new byte [ num Layer ] [ ] [ ] ; for ( int j = NUM ; j < num Layer ; j + + ) { current Auth Paths [ j ] = new byte [ help Current Auth Paths [ j ] . length ] [ md Length ] ; for ( int i = NUM ; i < help Current Auth Paths [ j ] . length ; i + + ) { System . arraycopy ( help Current Auth Paths [ j ] [ i ] , NUM , current Auth Paths [ j ] [ i ] , NUM , md Length ) ; } } index = new int [ num Layer ] ; System . arraycopy ( gmss Private Key . get Index ( ) , NUM , index , NUM , num Layer ) ; byte [ ] help Subtree Root Sig ; subtree Root Sig = new byte [ num Layer - NUM ] [ ] ; for ( int i = NUM ; i < num Layer - NUM ; i + + ) { help Subtree Root Sig = gmss Private Key . get Subtree Root Sig ( i ) ; subtree Root Sig [ i ] = new byte [ help Subtree Root Sig . length ] ; System . arraycopy ( help Subtree Root Sig , NUM , subtree Root Sig [ i ] , NUM , help Subtree Root Sig . length ) ; } gmss Private Key . mark Used ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks whether the supplied character is a letter or number according to the n - triples specification .",
    "text_2": "public static boolean is Letter Or Number ( int c ) { return is Letter ( c ) | | is Number ( c ) ; }",
    "label": 1
  },
  {
    "text_1": "determines how two calendars compare up to no more than the specified most significant field .",
    "text_2": "public static int truncated Compare To ( final Calendar cal NUM , final Calendar cal NUM , final int field ) { final Calendar truncated Cal NUM = truncate ( cal NUM , field ) ; final Calendar truncated Cal NUM = truncate ( cal NUM , field ) ; return truncated Cal NUM . compare To ( truncated Cal NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "return the attribute list as a string which can be directly output as part of an xml tag .",
    "text_2": "@ Override public String to String ( ) { String Builder buf = new String Builder ( ) ; for ( Name Value Pair pair : name Value Pair List ) { buf . append ( STRING ) ; buf . append ( pair . get Name ( ) ) ; buf . append ( STRING ) ; buf . append ( STRING ) ; buf . append ( get Quoted Attribute Value ( pair . get Value ( ) ) ) ; buf . append ( STRING ) ; } return buf . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "reads a xml element attribute ans cast it to a boolean value",
    "text_2": "public boolean to Boolean ( Element el , String attribute Name , boolean default Value ) { String value = el . get Attribute ( attribute Name ) ; if ( value = = null ) return default Value ; return Caster . to Boolean Value ( value , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "move to the next line",
    "text_2": "void next Line ( ) { try { next Line = current Episode . read Line ( ) ; while ( next Line . equals ( STRING ) ) next Line = current Episode . read Line ( ) ; } catch ( IO Exception | Null Pointer Exception e ) { next Line = null ; } }",
    "label": 1
  },
  {
    "text_1": "resolves all not loopback addresses and collect results .",
    "text_2": "public static Collection < Inet Socket Address > resolve Addresses ( Address Resolver addr R sl vr , Iterable < String > addrs , int port ) throws Ignite Spi Exception { assert addr R sl vr ! = null ; Collection < Inet Socket Address > ext Addrs = new Hash Set < > ( ) ; for ( String addr : addrs ) { Inet Socket Address sock Addr = new Inet Socket Address ( addr , port ) ; if ( ! sock Addr . is Unresolved ( ) ) { Collection < Inet Socket Address > ext Addrs NUM = resolve Address ( addr R sl vr , sock Addr ) ; if ( ext Addrs NUM ! = null ) ext Addrs . add All ( ext Addrs NUM ) ; } } return ext Addrs ; }",
    "label": 1
  },
  {
    "text_1": "util method to write an attribute with the ns prefix",
    "text_2": "private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) = = null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a listener for events that shift the projection stack .",
    "text_2": "public void add Action Listener ( Action Listener listener ) { forward Projection Button . add Action Listener ( listener ) ; back Projection Button . add Action Listener ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "determines the height of this view",
    "text_2": "private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode = = Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode = = Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }",
    "label": 1
  },
  {
    "text_1": "reads the service id , encoded as specified by the serviceid . write bytes method .",
    "text_2": "private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; service ID = new Service ID ( in ) ; }",
    "label": 1
  },
  {
    "text_1": "toggle a drawer in the stack",
    "text_2": "public void toggle ( JFX Drawer drawer ) { if ( ! draw ers . contains ( drawer ) ) add Drawer ( drawer ) ; if ( drawer . is Shown ( ) | | drawer . is Showing ( ) ) drawer . close ( ) ; else { update Drawer Position ( drawer ) ; drawer . open ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "tests whether numbers are the same up to the specified decimals .",
    "text_2": "public static void assert Almost Equals ( double expected , double actual , int decimals ) { assert Almost Equals ( null , new Double ( expected ) , new Double ( actual ) , decimals ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the given purchase information to the database and returns the total number of times that the given product has been purchased .",
    "text_2": "public synchronized int update Purchase ( String order Id , String product Id , Purchase State purchase State , long purchase Time , String developer Payload ) { insert Order ( order Id , product Id , purchase State , purchase Time , developer Payload ) ; Cursor cursor = m Db . query ( PUR CH ASE HISTORY TABLE NAME , HISTORY COLUMNS , HISTORY PRODUCT ID COL + STRING , new String [ ] { product Id } , null , null , null , null ) ; if ( cursor = = null ) { return NUM ; } int quantity = NUM ; try { while ( cursor . move To Next ( ) ) { int state Index = cursor . get Int ( NUM ) ; Purchase State state = Purchase State . value Of ( state Index ) ; if ( state = = Purchase State . PUR CHA SED | | state = = Purchase State . RE FUN DED ) { quantity + = NUM ; } } update Purchased Item ( product Id , quantity ) ; } finally { if ( cursor ! = null ) { cursor . close ( ) ; } } return quantity ; }",
    "label": 1
  },
  {
    "text_1": "process each regex group matched substring of the given pattern . if the closure parameter takes one argument , an array with all match groups is passed to it . if the closure takes as many arguments as there are match groups , then each parameter will be one match group .",
    "text_2": "public static < T extends Char Sequence > T each Match ( T self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { each Match ( self . to String ( ) , pattern , closure ) ; return self ; }",
    "label": 1
  },
  {
    "text_1": "convert an image to yuv 420 p format . see http : / / en . wikipedia . org / wiki / yuv y . uv 420 p . 28 and y . 27 v 12 or y v 12 . 29 to rgb 88 8 conversion for the description of the yuv 420 p format : \" y ' uv 420 p is a planar format , meaning that the y ' , u , and v values are grouped together instead of inter sper sed . the reason for this is that by grouping the u and v values together , the image becomes much more compres sible . when given an array of an image in the y ' uv 420 p format , all the y ' values come first , followed by all the u values , followed finally by all the v values . as with most y ' uv formats , there are as many y ' values as there are pixels . where x equals the height multiplied by the width , the first x indices in the array are y ' values that correspond to each individual pixel . however , there are only one fourth as many u and v values . the u and v values correspond to each 2 by 2 block of the image , meaning each u and v entry applies to four pixels . after the y ' values , the next x / 4 indices are the u values for each 2 by 2 block , and the next x / 4 indices after that are the v values that also apply to each 2 by 2 block . size . total = size . width size . height ; y = yuv [ position . y size . width + position . x ] ; u = yuv [ ( position . y / 2 ) ( size . width / 2 ) + ( position . x / 2 ) + size . total ] ; v = yuv [ ( position . y / 2 ) ( size . width / 2 ) + ( position . x / 2 ) + size . total + ( size . total / 4 ) ] ; rgb = y ' uv 44 4 t org b 88 8 ( y , u , v ) ; \"",
    "text_2": "public int hle Jpeg Decode Y Cb Cr ( Buffered Image buffered Image , T Pointer y Cb Cr Buffer , int y Cb Cr Buffer Size , int dht Mode ) { int width = buffered Image . get Width ( ) ; int height = buffered Image . get Height ( ) ; int size Y = width * height ; int size Cb = size Y > > NUM ; int address Y = y Cb Cr Buffer . get Address ( ) ; int address Cb = address Y + size Y ; int address Cr = address Cb + size Cb ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , address Y , address Cb , address Cr ) ) ; } int [ ] buffer Cb = new int [ size Cb ] ; int [ ] buffer Cr = new int [ size Cb ] ; I Memory Writer image Writer Y = Memory Writer . get Memory Writer ( address Y , size Y , NUM ) ; for ( int y = NUM ; y < height ; y + + ) { int index Cb = ( y > > NUM ) * ( width > > NUM ) ; for ( int x = NUM ; x < width ; x + = NUM , index Cb + + ) { int argb NUM = buffered Image . get RGB ( x , y ) ; int y Cb Cr NUM = color ARGB To Y Cb Cr ( argb NUM ) ; int argb NUM = buffered Image . get RGB ( x + NUM , y ) ; int y Cb Cr NUM = color ARGB To Y Cb Cr ( argb NUM ) ; image Writer Y . write Next ( get Y ( y Cb Cr NUM ) ) ; image Writer Y . write Next ( get Y ( y Cb Cr NUM ) ) ; buffer Cb [ index Cb ] + = get Cb ( y Cb Cr NUM ) ; buffer Cb [ index Cb ] + = get Cb ( y Cb Cr NUM ) ; buffer Cr [ index Cb ] + = get Cr ( y Cb Cr NUM ) ; buffer Cr [ index Cb ] + = get Cr ( y Cb Cr NUM ) ; } } image Writer Y . flush ( ) ; I Memory Writer image Writer Cb = Memory Writer . get Memory Writer ( address Cb , size Cb , NUM ) ; I Memory Writer image Writer Cr = Memory Writer . get Memory Writer ( address Cr , size Cb , NUM ) ; for ( int i = NUM ; i < size Cb ; i + + ) { image Writer Cb . write Next ( buffer Cb [ i ] > > NUM ) ; image Writer Cr . write Next ( buffer Cr [ i ] > > NUM ) ; } image Writer Cb . flush ( ) ; image Writer Cr . flush ( ) ; return get Width Height ( width , height ) ; }",
    "label": 1
  },
  {
    "text_1": "parses a node in the xml structure and returns the corresponding ns object",
    "text_2": "private static NS Object parse Object ( Node n ) throws Parse Exception , IO Exception { String type = n . get Node Name ( ) ; if ( type . equals ( STRING ) ) { NS Dictionary dict = new NS Dictionary ( ) ; List < Node > children = filter Element Nodes ( n . get Child Nodes ( ) ) ; for ( int i = NUM ; i < children . size ( ) ; i + = NUM ) { Node key = children . get ( i ) ; Node val = children . get ( i + NUM ) ; String key String = get Node Text Contents ( key ) ; dict . put ( key String , parse Object ( val ) ) ; } return dict ; } else if ( type . equals ( STRING ) ) { List < Node > children = filter Element Nodes ( n . get Child Nodes ( ) ) ; NS Array array = new NS Array ( children . size ( ) ) ; for ( int i = NUM ; i < children . size ( ) ; i + + ) { array . set Value ( i , parse Object ( children . get ( i ) ) ) ; } return array ; } else if ( type . equals ( STRING ) ) { return new NS Number ( BOOL ) ; } else if ( type . equals ( STRING ) ) { return new NS Number ( BOOL ) ; } else if ( type . equals ( STRING ) ) { return new NS Number ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS Number ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS String ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS Data ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS Date ( get Node Text Contents ( n ) ) ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "generates an indentation string .",
    "text_2": "private String indent ( int level ) { final String s = STRING ; if ( level = = NUM ) return STRING ; String Builder sb = new String Builder ( level * s . length ( ) ) ; for ( int i = NUM ; i < level ; i + + ) { sb . append ( s ) ; } return s . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "tests this renderer for equality with another object .",
    "text_2": "@ Override public boolean equals ( Object obj ) { if ( obj = = this ) { return BOOL ; } if ( ! ( obj instanceof Candlestick Renderer ) ) { return BOOL ; } Candlestick Renderer that = ( Candlestick Renderer ) obj ; if ( this . candle Width ! = that . candle Width ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . up Paint , that . up Paint ) ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . down Paint , that . down Paint ) ) { return BOOL ; } if ( this . draw Volume ! = that . draw Volume ) { return BOOL ; } if ( this . max Candle Width In Milliseconds ! = that . max Candle Width In Milliseconds ) { return BOOL ; } if ( this . auto Width Method ! = that . auto Width Method ) { return BOOL ; } if ( this . auto Width Factor ! = that . auto Width Factor ) { return BOOL ; } if ( this . auto Width Gap ! = that . auto Width Gap ) { return BOOL ; } if ( this . use Outline Paint ! = that . use Outline Paint ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . volume Paint , that . volume Paint ) ) { return BOOL ; } return super . equals ( obj ) ; }",
    "label": 1
  },
  {
    "text_1": "ask the current default engine to launch the matching install tts data activity so the required tts files are properly installed .",
    "text_2": "private void install Voice Data ( ) { if ( Text Utils . is Empty ( get Engine Name ( ) ) ) return ; Intent intent = new Intent ( Text To Speech . Engine . ACTION INSTALL TTS DATA ) ; intent . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; intent . set Package ( get Engine Name ( ) ) ; try { Log . v ( TAG , STRING + intent . to Uri ( NUM ) ) ; start Activity ( intent ) ; } catch ( Activity Not Found Exception ex ) { Log . e ( TAG , STRING + intent + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "verify that every non - physical , non - parameter symbolic register that has a use also has at least one def",
    "text_2": "private void verify Register Defs ( String where ) { Def Use . compute DU ( this ) ; for ( Register r = regpool . get First Symbolic Register ( ) ; r ! = null ; r = r . get Next ( ) ) { if ( r . is Physical ( ) ) continue ; if ( r . use List ! = null ) { if ( r . def List = = null ) { print Instructions ( ) ; ver ror ( where , STRING + r + STRING ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "extract a single element from a table . this returns an array of length 1 .",
    "text_2": "private Object single Element ( int row , int col ) { Object res = null ; if ( this . is Null = = null | | ! this . is Null [ row * this . n Fields + col ] ) { res = Array Funcs . new Instance ( this . types [ col ] , NUM ) ; System . arraycopy ( this . data [ col ] , row , res , NUM , NUM ) ; } return res ; }",
    "label": 1
  },
  {
    "text_1": "return top context from the queue , without removing it .",
    "text_2": "public Page Object Context peek ( ) { return deque . peek ( ) ; }",
    "label": 1
  },
  {
    "text_1": "quantile function of gp d distribution",
    "text_2": "public static double quantile ( double val , double mu , double sigma , double xi ) { if ( val < NUM | | val > NUM ) { return Double . Na N ; } if ( xi = = NUM ) { return mu - sigma * Math . log ( NUM - val ) ; } return mu - sigma / xi * ( NUM - Math . pow ( NUM - val , - xi ) ) ; }",
    "label": 1
  },
  {
    "text_1": "retrieve listing of secrets . if \" idx \" and \" num \" are both provided , retrieve \" num \" names starting at \" idx \" from a list of secrets ordered by creation date , with order depending on \" ne west first \" ( which defaults to \" true \" )",
    "text_2": "@ Timed @ Exception Metered @ Path ( STRING ) @ GET @ Produces ( APPLICATION JSON ) public Iterable < Sanitized Secret > secret Listing V NUM ( @ Auth Automation Client automation Client , @ Query Param ( STRING ) Integer idx , @ Query Param ( STRING ) Integer num , @ Default Value ( STRING ) @ Query Param ( STRING ) boolean newest First ) { if ( idx ! = null & & num ! = null ) { if ( idx < NUM | | num < NUM ) { throw new Bad Request Exception ( STRING ) ; } return secret Controller . get Secrets Batched ( idx , num , newest First ) ; } return secret Controller . get Sanitized Secrets ( null , null ) ; }",
    "label": 1
  },
  {
    "text_1": "append a range of bytes to the end of the given text",
    "text_2": "public void append ( byte [ ] utf NUM , int start , int len ) { set Capacity ( length + len , BOOL ) ; System . arraycopy ( utf NUM , start , bytes , length , len ) ; length + = len ; }",
    "label": 1
  },
  {
    "text_1": "creates a polyline consisting of 3 lines",
    "text_2": "public Polyline ( Pla Point Int p from corner , Pla Point Int p to corner ) { if ( p from corner . equals ( p to corner ) ) throw new Illegal Argument Exception ( classname + STRING ) ; lines list = new Array List < Pla Line Int > ( NUM ) ; Pla Direction dir = new Pla Direction ( p from corner , p to corner ) ; lines list . add ( new Pla Line Int ( p from corner , dir . rotate NUM deg ( NUM ) ) ) ; lines list . add ( new Pla Line Int ( p from corner , p to corner ) ) ; lines list . add ( new Pla Line Int ( p to corner , dir . rotate NUM deg ( NUM ) ) ) ; corners allocate ( corner count ( ) ) ; p recalculated corners [ NUM ] = p from corner ; p recalculated corners [ NUM ] = p to corner ; }",
    "label": 1
  },
  {
    "text_1": "populate symbol type list . given a panel details class iterate over all the field panels asking them to populate the symbol type list . the returned the list contains all possible symbol types .",
    "text_2": "private List < Value Combo Box Data Group > populate Symbol List ( Class < ? > panel Details ) { List < Value Combo Box Data Group > combined Symbol List = new Array List < Value Combo Box Data Group > ( ) ; for ( Field State panel : symbol Type Field List ) { panel . populate Symbol List ( panel Details , combined Symbol List ) ; } return combined Symbol List ; }",
    "label": 1
  },
  {
    "text_1": "fill an array with the values of a 61 - db 3 - sample black man - har ris window function",
    "text_2": "private void black man Har ris NUM s ( int size ) { int start = ( window Function . length - size ) / NUM ; int stop = ( window Function . length + size ) / NUM ; double scale = NUM / ( double ) size / NUM ; for ( int i = NUM ; start < stop ; start + + , i + + ) window Function [ i ] = scale * ( NUM - NUM * Math . cos ( two PI * i / size ) + NUM * Math . cos ( NUM * two PI * i / size ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .",
    "text_2": "public static Input Stream to Input Stream ( Char Sequence input , Charset encoding ) { return to Input Stream ( input . to String ( ) , encoding ) ; }",
    "label": 1
  },
  {
    "text_1": "generate file with random data and provided argument .",
    "text_2": "private void generate File ( int word Cnt ) throws Exception { Random rnd = new Random ( System . current Time Millis ( ) ) ; try ( Output Stream Writer writer = new Output Stream Writer ( igfs . create ( FILE , BOOL ) ) ) { int cnt = NUM ; while ( cnt < word Cnt ) { String word = DICTIONARY [ rnd . next Int ( DICTIONARY . length ) ] ; writer . write ( word + STRING ) ; cnt + + ; } } }",
    "label": 1
  },
  {
    "text_1": "calculates control width and creates text layouts",
    "text_2": "private int calculate Layout Width ( int width Size , int mode ) { init Resources If Necessary ( ) ; items Layout . set Layout Params ( new Layout Params ( Layout Params . WRAP CONTENT , Layout Params . WRAP CONTENT ) ) ; items Layout . measure ( Measure Spec . make Measure Spec ( width Size , Measure Spec . UNSPECIFIED ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; int width = items Layout . get Measured Width ( ) ; if ( mode = = Measure Spec . EXACTLY ) { width = width Size ; } else { width + = NUM * PADDING ; width = Math . max ( width , get Suggested Minimum Width ( ) ) ; if ( mode = = Measure Spec . AT MOST & & width Size < width ) { width = width Size ; } } items Layout . measure ( Measure Spec . make Measure Spec ( width - NUM * PADDING , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; return width ; }",
    "label": 1
  },
  {
    "text_1": "redirects a relationships to a new target node .",
    "text_2": "@ Procedure @ Per forms Writes @ Description ( STRING ) public Stream < Relationship Refactor Result > from ( @ Name ( STRING ) Relationship rel , @ Name ( STRING ) Node new Node ) { Relationship Refactor Result result = new Relationship Refactor Result ( rel . get Id ( ) ) ; try { Relationship new Rel = new Node . create Relationship To ( rel . get End Node ( ) , rel . get Type ( ) ) ; copy Properties ( rel , new Rel ) ; rel . delete ( ) ; return Stream . of ( result . with Other ( new Rel ) ) ; } catch ( Exception e ) { return Stream . of ( result . with Error ( e ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "convenience method for removing data rows .",
    "text_2": "public Data Row remove Data Row ( int index ) { return data List . remove ( index ) ; }",
    "label": 1
  },
  {
    "text_1": "rather than creating contexts directly , instead associate with externally created context .",
    "text_2": "public void test Nested Allocation Contexts ( ) { final I Allocation Context context = manager . new Allocation Context ( BOOL ) ; final String test = STRING ; final long addr NUM = allocate ( manager , context , test ) ; final long addr NUM = allocate ( manager , context , test ) ; assert True ( addr NUM ! = addr NUM ) ; final String res = get String ( addr NUM ) ; assert True ( res . equals ( test ) ) ; manager . free ( addr NUM , context ) ; final long addr NUM = allocate ( manager , context , test ) ; assert True ( addr NUM ! = addr NUM ) ; manager . detach Context ( context ) ; final I Allocation Context context NUM = manager . new Allocation Context ( BOOL ) ; final long addr NUM = allocate ( manager , context NUM , test ) ; assert True ( addr NUM = = addr NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "obtains the sine of this angle .",
    "text_2": "public final double sin ( ) { return Math . sin ( this . radians ) ; }",
    "label": 1
  },
  {
    "text_1": "public static method to construct a system name from type character and bit number this routine returns a system name in the cl xxxx , ct xxxx , or cs xxxx format . the returned name is normalized . if the supplied character is not valid , or the bit number is out of the 1 - 9000 range , an error message is logged and the null string \" \" is returned .",
    "text_2": "public static String make System Name ( String type , int bit Num ) { String n Name = STRING ; if ( ( ! type . equals ( STRING ) ) & & ( ! type . equals ( STRING ) ) & & ( ! type . equals ( STRING ) ) ) { log . error ( STRING + type ) ; return ( n Name ) ; } if ( ( bit Num < NUM ) | | ( ( type . equals ( STRING ) ) & & ( bit Num > NUM ) ) | | ( bit Num > NUM ) ) { log . error ( STRING + bit Num ) ; return ( n Name ) ; } n Name = STRING + type + Integer . to String ( bit Num ) ; return ( n Name ) ; }",
    "label": 1
  },
  {
    "text_1": "instantiates a new forced user extension .",
    "text_2": "public Extension Forced User ( ) { super ( ) ; initialize ( ) ; }",
    "label": 1
  },
  {
    "text_1": "unregisters the listener from the service for the given listener id . the id was issued when the listener was registered .",
    "text_2": "void remove Listener ( String listener ID ) { if ( listener Objects ! = null ) { synchronized ( listener Objects ) { listener Objects . remove ( listener ID ) ; if ( listener Objects . is Empty ( ) ) { deregister Listener ( ) ; } } if ( debug . message Enabled ( ) ) { debug . message ( STRING + service Name + STRING + listener ID ) ; } } }",
    "label": 1
  },
  {
    "text_1": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >",
    "text_2": "@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Datatype Package . CONSTRAINT TYPE : return type ! = TYPE EDEFAULT ; case Datatype Package . CONSTRAINT CONSTRAINT VALUES : return CONSTRAINT VALUES EDEFAULT = = null ? constraint Values ! = null : ! CONSTRAINT VALUES EDEFAULT . equals ( constraint Values ) ; } return super . e Is Set ( feature ID ) ; }",
    "label": 1
  },
  {
    "text_1": "handles edit site request .",
    "text_2": "public void handle Tbl Data Site Action Href Request ( Request Invocation Event event ) throws Model Control Exception { String site Name = hex To String ( ( String ) get Display Field Value ( TBL DATA SITE ACTION HREF ) ) ; set Page Session Attribute ( Site Edit View Bean . PG ATTR SITE NAME , site Name ) ; Site Edit View Bean vb = ( Site Edit View Bean ) get View Bean ( Site Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "converts this class to a class file . once this method is called , further modifications are not possible any more .",
    "text_2": "public byte [ ] to Bytecode ( ) throws IO Exception , Cannot Compile Exception { Byte Array Output Stream barray = new Byte Array Output Stream ( ) ; Data Output Stream out = new Data Output Stream ( barray ) ; try { to Bytecode ( out ) ; } finally { out . close ( ) ; } return barray . to Byte Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "to be invoked when an item in the list is clicked ( even when not in multi selection mode ) .",
    "text_2": "public boolean on Click ( int position ) { if ( m Mode = = MODE MULTIPLE SELECT ) { if ( m Selected Items . contains ( position ) ) { m Selected Items . remove ( position ) ; if ( m Selected Items . is Empty ( ) ) { set Mode ( MODE SINGLE SELECT ) ; } } else { m Selected Items . add ( position ) ; } notify Selection Changed ( position ) ; return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >",
    "text_2": "@ Override public boolean is Factory For Type ( Object type ) { return supported Types . contains ( type ) | | super . is Factory For Type ( type ) ; }",
    "label": 1
  },
  {
    "text_1": "this is the default configuration used by checker framework junit tests .",
    "text_2": "public static Test Configuration build Default Configuration ( String test Source Path , File test File , String checker Name , List < String > options , boolean should Emit Debug Info ) { List < File > java Files = Arrays . as List ( test File ) ; List < String > processors = Arrays . as List ( checker Name ) ; return build Default Configuration ( test Source Path , java Files , processors , options , should Emit Debug Info ) ; }",
    "label": 1
  },
  {
    "text_1": "accept a training set",
    "text_2": "@ Override public void accept Training Set ( Training Set Event e ) { Instances training Set = e . get Training Set ( ) ; Data Set Event dse = new Data Set Event ( this , training Set ) ; accept Data Set ( dse ) ; }",
    "label": 1
  },
  {
    "text_1": "create a view on a scale - out index .",
    "text_2": "public Abstract Scale Out Client Index View ( final Abstract Scale Out Federation fed , final String name , final long timestamp , final I Metadata Index metadata Index ) { if ( fed = = null ) throw new Illegal Argument Exception ( ) ; if ( name = = null ) throw new Illegal Argument Exception ( ) ; if ( metadata Index = = null ) throw new Illegal Argument Exception ( ) ; this . fed = fed ; this . name = name ; this . timestamp = timestamp ; this . metadata Index = metadata Index ; this . metadata Index Metadata = metadata Index . get Index Metadata ( ) ; final Abstract Client < ? > client = fed . get Client ( ) ; this . capacity = client . get Default Range Query Capacity ( ) ; this . batch Only = client . get Batch Api Only ( ) ; this . task Timeout = client . get Task Timeout ( ) ; this . read Consistent = client . is Read Consistent ( ) ; }",
    "label": 1
  },
  {
    "text_1": "calculates the number of decimal digits for the given value , including the sign .",
    "text_2": "public static int calculate Digit Count ( long value ) { if ( value < NUM ) { if ( value ! = Long . MIN VALUE ) { return calculate Digit Count ( - value ) + NUM ; } else { return NUM ; } } return ( value < NUM ? NUM : ( value < NUM ? NUM : ( value < NUM ? NUM : ( value < NUM ? NUM : ( ( int ) ( Math . log ( value ) / LOG NUM ) + NUM ) ) ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "after rotating , the matrix needs to be translated . this function finds the area of image which was previously centered and adjusts translations so that is again the center , post - rotation .",
    "text_2": "private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "measure a child view to fit within cell - based formatting . the child ' s width will be measured to a whole multiple of cell size . sets the expandable and cell s used fields of layoutparams .",
    "text_2": "static int measure Child For Cells ( View child , int cell Size , int cells Remaining , int parent Height Measure Spec , int parent Height Padding ) { final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; final int child Height Size = Measure Spec . get Size ( parent Height Measure Spec ) - parent Height Padding ; final int child Height Mode = Measure Spec . get Mode ( parent Height Measure Spec ) ; final int child Height Spec = Measure Spec . make Measure Spec ( child Height Size , child Height Mode ) ; int cells Used = NUM ; if ( cells Remaining > NUM ) { final int child Width Spec = Measure Spec . make Measure Spec ( cell Size * cells Remaining , Measure Spec . AT MOST ) ; child . measure ( child Width Spec , child Height Spec ) ; final int measured Width = child . get Measured Width ( ) ; cells Used = measured Width / cell Size ; if ( measured Width % cell Size ! = NUM ) cells Used + + ; } final Action Menu Item View item View = child instanceof Action Menu Item View ? ( Action Menu Item View ) child : null ; final boolean expandable = ! lp . is Overflow Button & & item View ! = null & & item View . has Text ( ) ; lp . expandable = expandable ; lp . cells Used = cells Used ; final int target Width = cells Used * cell Size ; child . measure ( Measure Spec . make Measure Spec ( target Width , Measure Spec . EXACTLY ) , child Height Spec ) ; return cells Used ; }",
    "label": 1
  },
  {
    "text_1": "return whether the stop watch is currently running .",
    "text_2": "public boolean is Running ( ) { return this . running ; }",
    "label": 1
  },
  {
    "text_1": "removes the first attribute with the specified name in the set of modifications .",
    "text_2": "public synchronized void remove ( String name ) { for ( int i = NUM ; i < modifications . size ( ) ; i + + ) { Modification mod = modifications . get ( i ) ; Attribute attr = mod . get Attribute ( ) ; if ( name . equals Ignore Case ( attr . get Attribute Description As String ( ) ) ) { modifications . remove ( i ) ; return ; } } }",
    "label": 1
  },
  {
    "text_1": "creates the xml element for a boolean value .",
    "text_2": "private void create Element ( Document doc , Element parent Element , String element Name , boolean value ) { Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node ( Boolean . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }",
    "label": 1
  },
  {
    "text_1": "returns whether a language having the given key should be allowed to be loaded . if language availability restrictions are imposed through guacamole . properties , this may return false in some cases . by default , this function will always return true . note that just because a language key is allowed to be loaded does not imply that the language key is valid .",
    "text_2": "private boolean is Language Allowed ( String language Key ) { if ( allowed Languages = = null ) return BOOL ; return allowed Languages . contains ( language Key ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new instance of search engine",
    "text_2": "public Searcher ( ) throws IO Exception { searcher = new Index Searcher ( Directory Reader . open ( FS Directory . open ( Paths . get ( INDEX DIR ) ) ) ) ; parser = new Query Parser ( CONTENT FIELD , new Standard Analyzer ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the food data for the player .",
    "text_2": "@ Override public void read NBT ( NBT Tag Compound compound ) { super . read NBT ( compound ) ; if ( compound . has Key ( STRING ) ) { this . exhau stion Timer = compound . get Integer ( STRING ) ; } if ( ! compound . has Key ( STRING ) ) { set Food Level ( get Food Level ( ) * NUM ) ; set Saturation ( NUM ) ; } if ( get Food Level ( ) > NUM ) set Food Level ( NUM ) ; if ( get Saturation Level ( ) > NUM ) set Saturation ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "parses what ' s left of the target name in the specified tokenizer , and initializes the transient fields . peer is false when parsing the local principals , true when parsing the peer principals .",
    "text_2": "private void parse Name ( String Tokenizer st , boolean peer ) { List vals = new Array List ( NUM ) ; outer : while ( BOOL ) { String cls ; do { if ( ! st . has More Tokens ( ) ) { break outer ; } cls = st . next Token ( ) ; } while ( cls . equals ( STRING ) ) ; if ( ! peer & & cls . equals Ignore Case ( STRING ) ) { parse Name ( st , BOOL ) ; break ; } if ( cls . equals ( STRING ) ) { if ( peer ) { throw new Illegal Argument Exception ( STRING ) ; } cls = null ; vals = null ; } String nm ; do { if ( ! st . has More Tokens ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } nm = st . next Token ( ) ; } while ( nm . equals ( STRING ) ) ; if ( ! nm . starts With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } while ( ! nm . ends With ( STRING ) ) { if ( ! st . has More Tokens ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } nm = nm + st . next Token ( ) ; } if ( nm . equals ( STRING ) ) { if ( peer ) { throw new Illegal Argument Exception ( STRING ) ; } if ( cls = = null ) { continue ; } nm = null ; } else if ( cls = = null ) { throw new Illegal Argument Exception ( STRING ) ; } else { nm = nm . substring ( NUM , nm . length ( ) - NUM ) ; } if ( vals ! = null ) { for ( int i = vals . size ( ) ; i > NUM ; ) { String on m = ( String ) vals . get ( - - i ) ; String oc ls = ( String ) vals . get ( - - i ) ; if ( cls . equals ( oc ls ) ) { if ( on m = = null | | ( on m ! = null & & on m . equals ( nm ) ) ) { continue outer ; } else if ( nm = = null ) { vals . remove ( i ) ; vals . remove ( i ) ; } } } vals . add ( cls ) ; vals . add ( nm ) ; } } String [ ] res = null ; if ( vals ! = null ) { if ( vals . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } res = ( String [ ] ) vals . to Array ( new String [ vals . size ( ) ] ) ; } if ( peer ) { this . peer = res ; } else { this . me = res ; } }",
    "label": 1
  },
  {
    "text_1": "restore values of original keys stored .",
    "text_2": "private void restore Data ( ) { Map < String , ? > map = preference Utils . get All ( ) ; Set < String > strings = map . key Set ( ) ; for ( String string : strings ) { if ( string . starts With ( Shared Preference Utils . key Test Mode ) ) { preference Utils . restore Key ( string ) ; } } refresh Key Values ( ) ; }",
    "label": 1
  },
  {
    "text_1": "execute a \" heapify upwards \" aka \" si ft up \" . used in insertions .",
    "text_2": "@ Override @ Suppress Warnings ( STRING ) protected void heapify Up Comparable ( int pos , Object elem ) { final Comparable < Object > cur = ( Comparable < Object > ) elem ; while ( pos > NUM ) { final int parent = ( pos - NUM ) > > > NUM ; Object par = queue [ parent ] ; if ( cur . compare To ( par ) > = NUM ) { break ; } queue [ pos ] = par ; index . put ( par , pos ) ; pos = parent ; } queue [ pos ] = cur ; index . put ( cur , pos ) ; }",
    "label": 1
  },
  {
    "text_1": "for the given pattern , find the revision number .",
    "text_2": "public static long find Revision ( final List < String > output , final Pattern pattern ) { long revision = - NUM ; for ( final String line : output ) { final Matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { revision = Long . parse Long ( matcher . group ( NUM ) ) ; break ; } } return revision ; }",
    "label": 1
  },
  {
    "text_1": "creates a new instance .",
    "text_2": "public JO SM Tolerant Fast XML Parser ( Sink sink , XML Stream Reader reader , boolean enable Date Parsing ) { this . sink = sink ; this . enable Date Parsing = enable Date Parsing ; this . reader = reader ; if ( enable Date Parsing ) { timestamp Format = new Xml Timestamp Format ( ) ; } else { Calendar calendar ; calendar = Calendar . get Instance ( ) ; calendar . set ( Calendar . MILLISECOND , NUM ) ; dummy Timestamp Container = new Simple Timestamp Container ( calendar . get Time ( ) ) ; } member Type Parser = new Member Type Parser ( ) ; }",
    "label": 1
  },
  {
    "text_1": "add a chunk of intermediate results for consumption by some query . the chunk will be attached to the query and the query will be scheduled for execution .",
    "text_2": "protected boolean accept Chunk ( final I Chunk Message < I Binding Set > msg ) { if ( msg = = null ) throw new Illegal Argument Exception ( ) ; if ( ! msg . is Materialized ( ) ) throw new Illegal State Exception ( ) ; final Abstract Running Query q = get Running Query ( msg . get Query Id ( ) ) ; if ( q = = null ) { throw new Illegal State Exception ( ) ; } if ( ! q . accept Chunk ( msg ) ) { msg . release ( ) ; return BOOL ; } if ( ! is Running ( ) ) { msg . release ( ) ; return BOOL ; } priority Queue . add ( q ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "removes wheel clicking listener",
    "text_2": "public void remove Cl icking Listener ( On Wheel Clicked Listener listener ) { cl icking Listeners . remove ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a string based on the input string , but with all characters with ordinal values < 32 or > = 128 replaced with ' ' .",
    "text_2": "public static String clean String ( String src ) { if ( src = = null ) { return null ; } boolean found Bad = BOOL ; final Character Iterator it = new String Character Iterator ( src ) ; for ( char c = it . first ( ) ; c ! = Character Iterator . DONE ; c = it . next ( ) ) { if ( c < ASCII PRINTABLE LOW | | c > = ASCII PRINTABLE HI ) { found Bad = BOOL ; break ; } } if ( ! found Bad ) { return src ; } final String Builder res = new String Builder ( ) ; for ( char c = it . first ( ) ; c ! = Character Iterator . DONE ; c = it . next ( ) ) { if ( c < ASCII PRINTABLE LOW | | c > = ASCII PRINTABLE HI ) { res . append ( ASCII SPACE ) ; } else { res . append ( c ) ; } } return res . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create marshaller based on schema for itunes specific metadata format .",
    "text_2": "private static Marshaller create Marshaller ( JAXB Context jaxb Context , String schema Path ) throws SAX Exception , JAXB Exception { Schema schema = Xml Parser . get Schema ( new String [ ] { schema Path } ) ; Marshaller jaxb Marshaller = jaxb Context . create Marshaller ( ) ; jaxb Marshaller . set Schema ( schema ) ; jaxb Marshaller . set Property ( Marshaller . JAXB FORMATTED OUTPUT , BOOL ) ; jaxb Marshaller . set Property ( Marshaller . JAXB ENCODING , STRING ) ; return jaxb Marshaller ; }",
    "label": 1
  },
  {
    "text_1": "this is a facade method for the encoding operation . this method encodes the remaining character sequence of the given character buffer into a new byte buffer . this method performs a complete encoding operation , resets at first , then encodes , and flushes at last . this method should not be invoked if another encode operation is ongoing .",
    "text_2": "public final Byte Buffer encode ( Char Buffer in ) throws Character Coding Exception { int length = ( int ) ( in . remaining ( ) * average Bytes Per Char ) ; Byte Buffer out = Byte Buffer . allocate ( length ) ; reset ( ) ; while ( state ! = FLU SHED ) { Coder Result result = encode ( in , out , BOOL ) ; if ( result = = Coder Result . OVERFLOW ) { out = allocate More ( out ) ; continue ; } else { check Coder Result ( result ) ; } result = flush ( out ) ; if ( result = = Coder Result . OVERFLOW ) { out = allocate More ( out ) ; } else { check Coder Result ( result ) ; } } out . flip ( ) ; return out ; }",
    "label": 1
  },
  {
    "text_1": "read a number of characters from a reader and close it .",
    "text_2": "public static String read String And Close ( Reader in , int length ) throws IO Exception { try { if ( length < = NUM ) { length = Integer . MAX VALUE ; } int block = Math . min ( Constants . IO BUFFER SIZE , length ) ; String Writer out = new String Writer ( block ) ; copy And Close Input ( in , out , length ) ; return out . to String ( ) ; } finally { in . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "get the type of the wrapped object .",
    "text_2": "public Class < ? > type ( ) { if ( is Class ) { return ( Class < ? > ) object ; } else { return object . get Class ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "check that a single pair of attributes changed .",
    "text_2": "private boolean check Attribute Changed ( String existing , String current ) { if ( existing = = null & & current = = null ) { return BOOL ; } if ( ( existing = = null ) ^ ( current = = null ) ) { return BOOL ; } return ( ! existing . equals Ignore Case ( current ) ) ; }",
    "label": 1
  },
  {
    "text_1": "notifies this token that a response message ( an ack or nack ) has been received .",
    "text_2": "protected void notify Complete ( ) { final String method Name = STRING ; log . fine ( CLASS NAME , method Name , STRING , new Object [ ] { get Key ( ) , this . response , this . exception } ) ; synchronized ( response Lock ) { if ( exception = = null & & pending Complete ) { completed = BOOL ; pending Complete = BOOL ; } else { pending Complete = BOOL ; } response Lock . notify All ( ) ; } synchronized ( sent Lock ) { sent = BOOL ; sent Lock . notify All ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "return the first child element returns the first element .",
    "text_2": "public static Element first Child Element ( Element element ) { if ( element = = null ) return null ; Node node = element . get First Child ( ) ; if ( node ! = null ) { do { if ( node . get Node Type ( ) = = Node . ELEMENT NODE ) { Element child Element = ( Element ) node ; return child Element ; } } while ( ( node = node . get Next Sibling ( ) ) ! = null ) ; } return null ; }",
    "label": 1
  },
  {
    "text_1": "formats a double value as a fraction and appends the result to a stringbuffer .",
    "text_2": "@ Override public String Buffer format ( final double value , final String Buffer buffer , final Field Position position ) { return format ( Double . value Of ( value ) , buffer , position ) ; }",
    "label": 1
  },
  {
    "text_1": "create the object after serialization . this implementation reinitializes the transient properties .",
    "text_2": "private void read Object ( final Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; init ( ) ; }",
    "label": 1
  },
  {
    "text_1": "this method is responsible for writing block let to the data file",
    "text_2": "protected long write Data To File ( Node Holder node Holder , File Channel channel ) throws Carbon Data Writer Exception { byte [ ] [ ] compressed Index = node Holder . get Compressed Index ( ) ; byte [ ] [ ] compressed Index Map = node Holder . get Compressed Index Map ( ) ; byte [ ] [ ] compressed Data Index = node Holder . get Compressed Data Index ( ) ; int index Block Size = NUM ; int index = NUM ; for ( int i = NUM ; i < node Holder . get Key Block Index Length ( ) . length ; i + + ) { index Block Size + = node Holder . get Key Block Index Length ( ) [ index + + ] + Carbon Common Constants . INT SIZE IN BYTE ; } for ( int i = NUM ; i < node Holder . get Data Index Map Length ( ) . length ; i + + ) { index Block Size + = node Holder . get Data Index Map Length ( ) [ i ] ; } Byte Buffer byte Buffer = Byte Buffer . allocate ( node Holder . get Key Array ( ) . length + node Holder . get Data Array ( ) . length + index Block Size ) ; long offset = NUM ; try { offset = channel . size ( ) ; byte Buffer . put ( node Holder . get Key Array ( ) ) ; byte Buffer . put ( node Holder . get Data Array ( ) ) ; Byte Buffer buffer NUM = null ; for ( int i = NUM ; i < compressed Index . length ; i + + ) { buffer NUM = Byte Buffer . allocate ( node Holder . get Key Block Index Length ( ) [ i ] ) ; buffer NUM . put Int ( compressed Index [ i ] . length ) ; buffer NUM . put ( compressed Index [ i ] ) ; if ( compressed Index Map [ i ] . length > NUM ) { buffer NUM . put ( compressed Index Map [ i ] ) ; } buffer NUM . rewind ( ) ; byte Buffer . put ( buffer NUM . array ( ) ) ; } for ( int i = NUM ; i < compressed Data Index . length ; i + + ) { byte Buffer . put ( compressed Data Index [ i ] ) ; } byte Buffer . flip ( ) ; channel . write ( byte Buffer ) ; } catch ( IO Exception exception ) { throw new Carbon Data Writer Exception ( STRING , exception ) ; } return offset ; }",
    "label": 1
  },
  {
    "text_1": "returns a map of discovered itemsets and their support , where the support is the number of times the combination appears in the input data",
    "text_2": "public Object NUM Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object NUM Int Open Hash Map < int [ ] > confidence Map = new Object NUM Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }",
    "label": 1
  },
  {
    "text_1": "resolves the macro t by writing the current date and time in the result buffer .",
    "text_2": "private void resolve Time Macro ( String Buffer result ) { Calendar calendar = new Gregorian Calendar ( ) ; result . append ( calendar . get ( Calendar . YEAR ) + STRING ) ; String month = calendar . get ( Calendar . MONTH ) + NUM + STRING ; if ( month . length ( ) < NUM ) { month = STRING + month ; } result . append ( month + STRING ) ; String day = calendar . get ( Calendar . DAY OF MONTH ) + STRING ; if ( day . length ( ) < NUM ) { day = STRING + day ; } result . append ( day + STRING ) ; int am Pm = calendar . get ( Calendar . AM PM ) ; String am Pm String = am Pm = = Calendar . AM ? STRING : STRING ; result . append ( am Pm String + STRING ) ; String hour = calendar . get ( Calendar . HOUR ) + STRING ; if ( hour . length ( ) < NUM ) { hour = STRING + hour ; } result . append ( hour + STRING ) ; String minute = calendar . get ( Calendar . MINUTE ) + STRING ; if ( minute . length ( ) < NUM ) { minute = STRING + minute ; } result . append ( minute + STRING ) ; String second = calendar . get ( Calendar . SECOND ) + STRING ; if ( second . length ( ) < NUM ) { second = STRING + second ; } result . append ( second ) ; }",
    "label": 1
  },
  {
    "text_1": "reads a null - terminated string from the stream .",
    "text_2": "@ Override public final String read Null Terminated Ascii String ( ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; byte b ; while ( BOOL ) { b = read Byte ( ) ; if ( b = = NUM ) { break ; } baos . write ( b ) ; } byte [ ] buf = baos . to Byte Array ( ) ; char [ ] chr Buf = new char [ buf . length ] ; for ( int x = NUM ; x < buf . length ; x + + ) { chr Buf [ x ] = ( char ) buf [ x ] ; } return String . value Of ( chr Buf ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a string representation of this error .",
    "text_2": "public String to String ( ) { String Buffer buffer = new String Buffer ( ) ; if ( override > NUM ) { buffer . append ( STRING + override + STRING ) ; if ( lineno > NUM ) buffer . append ( STRING + lineno + STRING ) ; } else { if ( location Name = = null & & lineno > NUM ) { buffer . append ( STRING + lineno + STRING ) ; } else if ( location Name ! = null ) { buffer . append ( location Name + STRING ) ; if ( lineno > NUM ) buffer . append ( lineno + STRING ) ; } } buffer . append ( description ) ; return buffer . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "see the general contract of the skip bytes method of datainput . bytes for this operation are read from the contained input stream .",
    "text_2": "public final int skip Bytes ( int count ) throws java . io . IO Exception { int skipped = NUM ; long skip ; while ( skipped < count & & ( skip = in . skip ( count - skipped ) ) ! = NUM ) { skipped + = skip ; } return skipped ; }",
    "label": 1
  },
  {
    "text_1": "add additional properties to the on - clause , which are logical - and to existing properties",
    "text_2": "public Outer Join Qualifier add ( String property Left , String property Right ) { additional Properties . add ( new Property Value Expression Pair ( new Property Value Expression ( property Left ) , new Property Value Expression ( property Right ) ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "constructs a sort of the given type with a starting point and explicitly specifies the order ( ascending or descending ) .",
    "text_2": "public Top N Metric ( Top N Metric Type type , String previous Stop , Sort Direction order ) { this ( type , previous Stop ) ; if ( order = = Sort Direction . ASC ) { this . type = Top N Metric Type . INVERTED ; this . nested = Optional . of ( new Top N Metric ( type , previous Stop ) ) ; this . previous Stop = Optional . empty ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "removes the xy series from the list .",
    "text_2": "public synchronized void remove Series ( XY Series series ) { m Series . remove ( series ) ; }",
    "label": 1
  },
  {
    "text_1": "this method validates a detach iso response object , raising an exception if the response reflects an operation failure .",
    "text_2": "private static Detach ISO Response check Detach ISO Response ( Detach ISO Response detach ISO Response ) throws Rpc Exception { logger . info ( STRING , detach ISO Response ) ; switch ( detach ISO Response . get Result ( ) ) { case OK : break ; case ISO NOT ATTACHED : logger . warn ( STRING , detach ISO Response ) ; throw new Iso Not Attached Exception ( detach ISO Response . get Error ( ) ) ; case SYSTEM ERROR : logger . warn ( STRING , detach ISO Response ) ; throw new System Error Exception ( detach ISO Response . get Error ( ) ) ; case VM NOT FOUND : logger . warn ( STRING , detach ISO Response ) ; throw new Vm Not Found Exception ( detach ISO Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , detach ISO Response . get Result ( ) ) ) ; } return detach ISO Response ; }",
    "label": 1
  },
  {
    "text_1": "whether or not this column is a customization",
    "text_2": "@ Suppress Warnings ( STRING ) public boolean is Customized ( ) { if ( m customization Level = = null ) { get Element ID ( ) ; m customization Level = new Integer ( s parameters . CUSTOM NONE ) ; if ( m parent . is Custom Prefix ( m name ) ) { m customization Level = new Integer ( s parameters . CUSTO MP RE FIXED ) ; } else { if ( m parent . is Object Exists ( STRING , m parent . get Tables ( ) ) & & m parent . is Object Exists ( STRING , m parent . get Tables ( ) ) ) { String sql = s db Engine . sql AD get Table Column Entity Type ( m parent . get Vendor ( ) , m parent . get Catalog ( ) , m parent . get Schema ( ) , m table , m name ) ; Statement stmt = m parent . set Statement ( ) ; Result Set rs = m parent . execute Query ( stmt , sql ) ; if ( m parent . get Result Set Next ( rs ) ) { String s = m parent . get Result Set String ( rs , STRING ) ; if ( m parent . is Custom Entity Type ( s ) ) m customization Level = new Integer ( s parameters . CUSTOM MARKED ) ; } m parent . release Result Set ( rs ) ; m parent . release Statement ( stmt ) ; } } } if ( m customization Level . int Value ( ) > s parameters . CUSTOM NONE ) return BOOL ; else return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "the first item in list",
    "text_2": "public T first Item ( ) { if ( m Data List = = null | | m Data List . size ( ) = = NUM ) { return null ; } return m Data List . get ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the specified items at the end of the array .",
    "text_2": "public void add All ( T . . . items ) { if ( m Event Delegate ! = null ) m Event Delegate . add Data ( items = = null ? NUM : items . length ) ; if ( items ! = null & & items . length ! = NUM ) { synchronized ( m Lock ) { Collections . add All ( m Objects , items ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the specified sorting fields .",
    "text_2": "public Search Builder sort ( Sort Field Builder . . . builders ) { sort . add All ( Arrays . as List ( builders ) ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "bitlength ( ) of a positive number .",
    "text_2": "public void test Bit Length Positive NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; assert Equals ( NUM , a Number . bit Length ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "stems everything in the given string . string is converted to lower case before stemming .",
    "text_2": "public String stem String ( String str ) { String Buffer result = new String Buffer ( ) ; int start = - NUM ; for ( int j = NUM ; j < str . length ( ) ; j + + ) { char c = str . char At ( j ) ; if ( Character . is Letter Or Digit ( c ) ) { if ( start = = - NUM ) { start = j ; } } else if ( c = = STRING ) { if ( start = = - NUM ) { result . append ( c ) ; } } else { if ( start ! = - NUM ) { result . append ( stem ( str . substring ( start , j ) ) ) ; start = - NUM ; } result . append ( c ) ; } } if ( start ! = - NUM ) { result . append ( stem ( str . substring ( start , str . length ( ) ) ) ) ; } return result . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "converts a timestamp to the byte sequence to be sent to the current time characteristic",
    "text_2": "public static byte [ ] calendar To Raw Bytes ( Calendar timestamp , boolean hon or Device Time Offset ) { if ( hon or Device Time Offset ) { int offset In Hours = Mi Band Coordinator . get Device Time Offset Hours ( ) ; if ( offset In Hours ! = NUM ) { timestamp . add ( Calendar . HOUR OF DAY , offset In Hours ) ; } } byte [ ] year = from Uint NUM ( timestamp . get ( Calendar . YEAR ) ) ; return new byte [ ] { year [ NUM ] , year [ NUM ] , from Uint NUM ( timestamp . get ( Calendar . MONTH ) + NUM ) , from Uint NUM ( timestamp . get ( Calendar . DATE ) ) , from Uint NUM ( timestamp . get ( Calendar . HOUR OF DAY ) ) , from Uint NUM ( timestamp . get ( Calendar . MINUTE ) ) , from Uint NUM ( timestamp . get ( Calendar . SECOND ) ) , day Of Week To Raw Bytes ( timestamp ) , NUM } ; }",
    "label": 1
  },
  {
    "text_1": "remove unnecessary mappings from sparse array .",
    "text_2": "private void clean Mapping ( ) { Array List < Integer > to Remove = new Array List < Integer > ( ) ; int size = m List Mapping . size ( ) ; for ( int i = NUM ; i < size ; + + i ) { if ( m List Mapping . key At ( i ) = = m List Mapping . value At ( i ) ) { to Remove . add ( m List Mapping . key At ( i ) ) ; } } size = to Remove . size ( ) ; for ( int i = NUM ; i < size ; + + i ) { m List Mapping . delete ( to Remove . get ( i ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "checks if all non - nullable properties of an entity are non - empty .",
    "text_2": "protected void validate Properties ( final Object entity , final Entity Data Model edm ) throws O Data Exception { final Type type = edm . get Type ( entity . get Class ( ) ) ; if ( ! ( type instanceof Structured Type ) ) { return ; } visit Properties ( edm , ( Structured Type ) type , null ) ; }",
    "label": 1
  },
  {
    "text_1": "convenient method for testing",
    "text_2": "public Subject login ( String username , String password ) { if ( String Utils . is Blank ( username ) | | String Utils . is Blank ( password ) ) return null ; Properties credentials = new Properties ( ) ; credentials . set Property ( Resource Constants . USER NAME , username ) ; credentials . set Property ( Resource Constants . PASSWORD , password ) ; return login ( credentials ) ; }",
    "label": 1
  },
  {
    "text_1": "normalize an attribute value ( id - style ) . cdata - style attribute normalization is already done .",
    "text_2": "public static String normalize ( String value ) { if ( value = = null ) return value ; value = value . trim ( ) ; if ( value . index Of ( STRING ) = = - NUM ) return value ; boolean space = BOOL ; int len = value . length ( ) ; String Buffer b = new String Buffer ( len ) ; for ( int i = NUM ; i < len ; i + + ) { char v = value . char At ( i ) ; if ( v = = STRING ) { if ( ! space ) b . append ( v ) ; space = BOOL ; } else { b . append ( v ) ; space = BOOL ; } } return b . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new instance of aes decryption",
    "text_2": "public Aes Decryptor ( byte [ ] key , int off , int len ) { this . key = new byte [ len ] ; System . arraycopy ( key , off , this . key , NUM , len ) ; }",
    "label": 1
  },
  {
    "text_1": "create a new property by parsing the given string .",
    "text_2": "Part ( String contents , String property ) throws Exception { this . contents = STRING + contents ; this . property = property ; simplify ( ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if the sd card is mounted on the device .",
    "text_2": "public static boolean is Sd Card Mounted ( ) { String status = Environment . get External Storage State ( ) ; if ( status . equals ( Environment . MEDIA MOUNTED ) ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )",
    "text_2": "public static F Size calc Text Size ( Paint paint , String demo Text ) { Rect r = new Rect ( ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; return new F Size ( r . width ( ) , r . height ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "loops through relation json array and maps annotated objects .",
    "text_2": "public Resource map Relations ( Resource object , JSON Object json Object , List < Resource > included ) throws Exception { Hash Map < String , String > relationship Names = get Relationship Names ( object . get Class ( ) ) ; for ( String relationship : relationship Names . key Set ( ) ) { JSON Object relation Json Object = null ; try { relation Json Object = json Object . get JSON Object ( relationship ) ; } catch ( JSON Exception e ) { Logger . debug ( STRING + relationship + STRING ) ; continue ; } JSON Object relation Data Object = null ; try { relation Data Object = relation Json Object . get JSON Object ( STRING ) ; Resource relation Object = Factory . new Object From JSON Object ( relation Data Object , null ) ; relation Object = match Included To Relation ( relation Object , included ) ; m Deserializer . set Field ( object , relationship Names . get ( relationship ) , relation Object ) ; } catch ( JSON Exception e ) { Logger . debug ( STRING ) ; } JSON Array relation Data Array = null ; try { relation Data Array = relation Json Object . get JSON Array ( STRING ) ; List < Resource > relation Array = Factory . new Object From JSON Array ( relation Data Array , null ) ; relation Array = match Included To Relation ( relation Array , included ) ; m Deserializer . set Field ( object , relationship Names . get ( relationship ) , relation Array ) ; } catch ( JSON Exception e ) { Logger . debug ( STRING ) ; } } return object ; }",
    "label": 1
  },
  {
    "text_1": "velocity is independent of the position of the events , it only depends on their relative distance .",
    "text_2": "@ Medium Test public void test Stability In Space ( ) { long t = System . current Time Millis ( ) ; Velocity Tracker vt = Velocity Tracker . obtain ( ) ; drag ( vt , NUM , NUM , NUM , NUM , NUM , t , NUM ) ; vt . compute Current Velocity ( NUM ) ; float first X = vt . get X Velocity ( ) ; float first Y = vt . get Y Velocity ( ) ; vt . clear ( ) ; drag ( vt , NUM , NUM , NUM , NUM , NUM , t , NUM ) ; vt . compute Current Velocity ( NUM ) ; float second X = vt . get X Velocity ( ) ; float second Y = vt . get Y Velocity ( ) ; assert Equal Fuzzy ( first X , second X , NUM ) ; assert Equal Fuzzy ( first Y , second Y , NUM ) ; vt . recycle ( ) ; }",
    "label": 1
  },
  {
    "text_1": "opens a spatial index file for reading based on the location of the provided shp file .",
    "text_2": "public Spatial Index ( String shp Filename ) throws IO Exception { this . shp File Name = shp Filename ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + shp Filename + STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a w gl - based backbuffer for the given peer and returns the image wrapper .",
    "text_2": "@ Override public Volatile Image create Back Buffer ( W Component Peer peer ) { Component target = ( Component ) peer . get Target ( ) ; return new Sun Volatile Image ( target , target . get Width ( ) , target . get Height ( ) , Boolean . TRUE ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs an external problem using the specified socket .",
    "text_2": "External Problem ( Socket socket ) throws IO Exception { this ( socket . get Input Stream ( ) , socket . get Output Stream ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convert an input number object into a string .",
    "text_2": "protected String convert To String ( Object value ) throws Throwable { String result = null ; if ( use Locale Format & & value instanceof Number ) { Number Format format = get Format ( ) ; format . set Grouping Used ( BOOL ) ; result = format . format ( value ) ; } else { result = value . to String ( ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "replaces a portion of the string builder with another string . the length of the inserted string does not have to match the removed length .",
    "text_2": "public Str Builder replace ( final int start Index , int end Index , final String replace Str ) { end Index = validate Range ( start Index , end Index ) ; final int insert Len = ( replace Str = = null ? NUM : replace Str . length ( ) ) ; replace Impl ( start Index , end Index , end Index - start Index , replace Str , insert Len ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "deploy the war to the given context path .",
    "text_2": "protected void deploy ( Http Servlet Response response , String context Path , String war URL ) throws IO Exception { String context = context Path ; boolean error = BOOL ; if ( context = = null ) { File file = new File ( war URL ) ; String file Name = file . get Name ( ) ; if ( file Name . ends With ( STRING ) ) { file Name = file Name . substring ( NUM , file Name . last Index Of ( STRING ) ) ; } context = STRING + file Name ; } if ( get Context Handler ( context ) ! = null ) { send Error ( response , STRING + context ) ; error = BOOL ; } else if ( ! context . starts With ( STRING ) ) { send Error ( response , STRING ) ; error = BOOL ; } if ( error ) { return ; } else { File webapp Dest = new File ( web App Directory , context + STRING ) ; URI uri = null ; try { uri = new URI ( war URL ) ; } catch ( URI Syntax Exception e ) { send Error ( response , STRING + war URL ) ; Log . warn ( e ) ; return ; } File webapp Source = new File ( uri ) ; File Input Stream file Input Stream = new File Input Stream ( webapp Source ) ; File Output Stream file Output Stream = new File Output Stream ( webapp Dest ) ; int i = file Input Stream . read ( ) ; while ( i ! = - NUM ) { file Output Stream . write ( i ) ; i = file Input Stream . read ( ) ; } file Input Stream . close ( ) ; file Output Stream . flush ( ) ; file Output Stream . close ( ) ; Web App Context web app context = new Web App Context ( ) ; web app context . set Context Path ( context ) ; web app context . set War ( webapp Dest . get Path ( ) ) ; ch c . add Handler ( web app context ) ; try { web app context . start ( ) ; } catch ( Exception e ) { send Error ( response , STRING ) ; Log . warn ( e ) ; return ; } } send Message ( response , STRING + context Path ) ; }",
    "label": 1
  },
  {
    "text_1": "get the max value for a byte",
    "text_2": "static private String BYTE Max ( ) { byte temp Value = Byte . MAX VALUE ; return String . value Of ( temp Value ) ; }",
    "label": 1
  },
  {
    "text_1": "create a new thread factory , using the specified pool id as a basis for naming each thread .",
    "text_2": "public Named Thread Factory ( final String pool ID ) { id = pool ID ; }",
    "label": 1
  },
  {
    "text_1": "close a bytearrayoutputstream passed in .",
    "text_2": "public static void close Output Stream ( Output Stream stream , String tag ) { if ( stream ! = null ) { try { stream . close ( ) ; } catch ( IO Exception e ) { Log . e ( tag , STRING + e ) ; } } }",
    "label": 1
  },
  {
    "text_1": "determines if the given index page is a leaf or node page .",
    "text_2": "private boolean is Leaf Page ( Byte Buffer buffer ) throws IO Exception { byte page Type = buffer . get ( NUM ) ; if ( page Type = = Page Types . INDEX LEAF ) { return BOOL ; } else if ( page Type = = Page Types . INDEX NODE ) { return BOOL ; } throw new IO Exception ( with Error Context ( STRING + page Type ) ) ; }",
    "label": 1
  },
  {
    "text_1": "upon close , this reads the remainder of the chunked message , leaving the underlying socket at a position to start reading the next response without scanning .",
    "text_2": "@ Override public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }",
    "label": 1
  },
  {
    "text_1": "replace the old child with a new child .",
    "text_2": "public Node replace Child ( Node new Child , Node old Child ) throws DOM Exception { if ( old Child = = null | | old Child . get Parent Node ( ) ! = this ) return null ; Elem Template Element new Child Elem = ( ( Elem Template Element ) new Child ) ; Elem Template Element old Child Elem = ( ( Elem Template Element ) old Child ) ; Elem Template Element prev = ( Elem Template Element ) old Child Elem . get Previous Sibling ( ) ; if ( null ! = prev ) prev . m next Sibling = new Child Elem ; if ( m first Child = = old Child Elem ) m first Child = new Child Elem ; new Child Elem . m parent Node = this ; old Child Elem . m parent Node = null ; new Child Elem . m next Sibling = old Child Elem . m next Sibling ; old Child Elem . m next Sibling = null ; return new Child Elem ; }",
    "label": 1
  },
  {
    "text_1": "returns the pid for this process using the specified name from runtime mxbean .",
    "text_2": "public static int identify Pid ( final String name ) throws Pid Unavailable Exception { try { final int index = name . index Of ( STRING ) ; if ( index < NUM ) { throw new Pid Unavailable Exception ( STRING + name ) ; } return Integer . value Of ( name . substring ( NUM , index ) ) ; } catch ( Number Format Exception e ) { throw new Pid Unavailable Exception ( STRING + name , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "generating private key . source : https : / / cr . yp . to / ec dh . html",
    "text_2": "public static byte [ ] key Gen Private ( byte [ ] random Bytes ) throws No Such Algorithm Exception , Digest Exception { if ( random Bytes . length < NUM ) { throw new Runtime Exception ( STRING ) ; } Message Digest digest = Message Digest . get Instance ( STRING ) ; digest . digest ( random Bytes , NUM , random Bytes . length ) ; byte [ ] private Key = digest . digest ( ) ; private Key [ NUM ] & = NUM ; private Key [ NUM ] & = NUM ; private Key [ NUM ] | = NUM ; return private Key ; }",
    "label": 1
  },
  {
    "text_1": "creates a new job definition create request based on user specified parameters .",
    "text_2": "public Job Definition Create Request create Job Definition Create Request ( String namespace Cd , String job Name , String job Description , String activiti Xml , List < Parameter > parameters ) { Job Definition Create Request request = new Job Definition Create Request ( ) ; request . set Namespace ( namespace Cd ) ; request . set Job Name ( job Name ) ; request . set Description ( job Description ) ; request . set Activiti Job Xml ( activiti Xml ) ; request . set Parameters ( parameters ) ; return request ; }",
    "label": 1
  },
  {
    "text_1": "generates the files associated with vector gave as parameters",
    "text_2": "private void generate Vector Drawable Result ( Vector Drawable vector , String next Vector Name , boolean is Last , boolean is First ) throws IO Exception { Custom Logger . log Error ( STRING + vector . get File Name ( ) + STRING + is Last ) ; if ( ! vector Already Defined . contains ( vector . get File Name ( ) ) ) { current Vector File Name = vector . get File Name ( ) ; Custom Logger . log Error ( STRING + current Vector File Name ) ; File vector File = new File ( drawable Folder , current Vector File Name + STRING ) ; Buffered Writer vector BW = create It ( vector File ) ; Custom Logger . log ( STRING + vector File . get Absolute Path ( ) ) ; generate Vector Drawable ( vector , vector BW , is Last ) ; vector Already Defined . add ( vector . get File Name ( ) ) ; vector BW . flush ( ) ; vector BW . close ( ) ; } if ( ! is Last ) { File animated Vector File = new File ( drawable Folder , animated Vector . replace ( STRING , current Vector File Name ) ) ; Buffered Writer animated Vector BW = create It ( animated Vector File ) ; Custom Logger . log ( STRING + animated Vector File . get Absolute Path ( ) ) ; Custom Logger . log Error ( STRING + animated Vector File . get Absolute Path ( ) + STRING + next Vector Name ) ; generate Animated Vector ( vector , animated Vector BW , next Vector Name , BOOL ) ; generate Animator Set ( vector , BOOL ) ; animated Vector BW . flush ( ) ; animated Vector BW . close ( ) ; } if ( ! is Last ) { File animated Vector File = new File ( drawable Folder , animated Vector . replace ( STRING , current Vector File Name + reverse ) ) ; Buffered Writer animated Vector BW = create It ( animated Vector File ) ; Custom Logger . log ( STRING + animated Vector File . get Absolute Path ( ) ) ; Custom Logger . log Error ( STRING + animated Vector File . get Absolute Path ( ) + STRING + next Vector Name ) ; generate Animated Vector ( vector , animated Vector BW , next Vector Name , BOOL ) ; generate Animator Set ( vector , BOOL ) ; animated Vector BW . flush ( ) ; animated Vector BW . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "clears the data . currently just adds a single vector to each data source .",
    "text_2": "public void reset Data ( ) { data . clear ( ) ; data Names . clear ( ) ; data Set . reset Data ( data Names , data , bins ) ; }",
    "label": 1
  },
  {
    "text_1": "called when related system properties are changed , and we need to reschedule",
    "text_2": "@ Override public void do Notify ( ) throws Exception { log . info ( STRING ) ; Scheduled Executor Service svc = service ; if ( svc ! = null ) { try { svc . schedule ( ( Callable < Object > ) this , NUM , Time Unit . MICROSECONDS ) ; } catch ( Rejected Execution Exception ex ) { if ( svc . is Shutdown ( ) ) { log . info ( STRING ) ; } else { throw ex ; } } } else { log . info ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a path from a single edge .",
    "text_2": "public Path ( final Vertex v0 , final Vertex v1 , final Edge Sample edge Sample ) { if ( v0 = = null ) throw new Illegal Argument Exception ( ) ; if ( v1 = = null ) throw new Illegal Argument Exception ( ) ; if ( v0 . sample = = null ) throw new Illegal Argument Exception ( ) ; if ( edge Sample = = null ) throw new Illegal Argument Exception ( ) ; if ( edge Sample . get Sample ( ) = = null ) throw new Illegal Argument Exception ( ) ; this . vertices = new Vertex [ ] { v0 , v1 } ; this . preds = get Predicates ( vertices ) ; this . edge Sample = edge Sample ; this . sum Est Read = v0 . sample . est Card + edge Sample . est Read ; this . sum Est Card = edge Sample . est Card ; this . sum Est Cost = get Cost ( this . sum Est Read , this . sum Est Card ) ; }",
    "label": 1
  },
  {
    "text_1": "tests whether the type parameter is bounded by bounded generic methods like : < t extends bounded generic methods > .",
    "text_2": "private void check Bounded Type Parameter ( Method method ) { Type Variable < Method > type Parameter = get Type Parameter ( method ) ; assert Equals ( STRING , type Parameter . get Name ( ) ) ; assert Equals ( method , type Parameter . get Generic Declaration ( ) ) ; Type [ ] bounds = type Parameter . get Bounds ( ) ; assert Lenght One ( bounds ) ; Type bound = bounds [ NUM ] ; assert Equals ( Bounded Wildcards Generic Methods . class , bound ) ; }",
    "label": 1
  },
  {
    "text_1": "check if the time that has been typed so far is completely legal , as is .",
    "text_2": "private boolean is Typed Time Fully Legal ( ) { if ( m Is NUM Hour Mode ) { int [ ] values = get Entered Time ( null ) ; return ( values [ NUM ] > = NUM & & values [ NUM ] > = NUM & & values [ NUM ] < NUM & & values [ NUM ] > = NUM & & values [ NUM ] < NUM ) ; } else { return ( m Typed Times . contains ( get Am Or Pm Key Code ( AM ) ) | | m Typed Times . contains ( get Am Or Pm Key Code ( PM ) ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "logs the given message with a newline associated with the given event .",
    "text_2": "public void log ( String event , String message ) { boolean event Active = is Event Active ( event ) ; if ( ( this . logging & & event Active & & ! writers . is Empty ( ) ) ) { try { for ( Writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( STRING ) ; writer . flush ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "add a constraint statement to this statement . the primary key definition is one possible constraint statement .",
    "text_2": "public void add Constraint Command ( Define Command command ) { if ( command instanceof Create Index ) { constraint Commands . add ( command ) ; } else { Alter Table Add Constraint con = ( Alter Table Add Constraint ) command ; boolean already Set ; if ( con . get Type ( ) = = Command Interface . ALTER TABLE ADD CONSTRAINT PRIMARY KEY ) { already Set = set Primary Key Columns ( con . get Index Columns ( ) ) ; } else { already Set = BOOL ; } if ( ! already Set ) { constraint Commands . add ( command ) ; } } }",
    "label": 1
  },
  {
    "text_1": "calculate the md 5 of a raw string",
    "text_2": "public static String raw MD NUM ( String s ) { return bin l NUM r str ( bin l NUM md NUM ( r str NUM bin l ( s ) , s . length ( ) * NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "prepares a user to be ranked for the first time after having follower data imported , resetting the previous pager an ks and preparing for a new calculation and ranking .",
    "text_2": "private void prepare User For Ranking ( User user ) { User updated User = user Repository . find One ( user . get Id ( ) , NUM ) ; if ( updated User . get Imported ( ) = = null | | ! updated User . get Imported ( ) ) { updated User . set Imported ( BOOL ) ; updated User . set Pag erank ( null ) ; updated User . set Last Page Rank ( null ) ; updated User . set Current Rank ( null ) ; updated User . set Previous Rank ( null ) ; user Repository . save ( updated User , NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "copies the elements from our element array into the specified array , in order ( from first to last element in the deque ) . it is assumed that the array is large enough to hold all elements in the deque .",
    "text_2": "private < T > T [ ] copy Elements ( T [ ] a ) { if ( head < tail ) { System . arraycopy ( elements , head , a , NUM , size ( ) ) ; } else if ( head > tail ) { int head Portion Len = elements . length - head ; System . arraycopy ( elements , head , a , NUM , head Portion Len ) ; System . arraycopy ( elements , NUM , a , head Portion Len , tail ) ; } return a ; }",
    "label": 1
  },
  {
    "text_1": "add a new string to the string table .",
    "text_2": "public void add String To Table ( byte [ ] old String , byte new String ) { int length = old String . length ; byte [ ] str = new byte [ length + NUM ] ; System . arraycopy ( old String , NUM , str , NUM , length ) ; str [ length ] = new String ; string Table [ table Index + + ] = str ; if ( table Index = = NUM ) { bits To Get = NUM ; } else if ( table Index = = NUM ) { bits To Get = NUM ; } else if ( table Index = = NUM ) { bits To Get = NUM ; } }",
    "label": 1
  },
  {
    "text_1": "adds the specified url to the search list .",
    "text_2": "protected void add URL ( URL url ) { try { original Urls . add ( url ) ; search List . add ( create Search URL ( url ) ) ; } catch ( Malformed URL Exception e ) { } }",
    "label": 1
  },
  {
    "text_1": "constructs a connection manager instance .",
    "text_2": "public Connection Manager ( Connection Manager Configuration configuration ) throws Exception { configuration = configuration ; if ( configuration = = null ) { throw new Connection Manager Exception ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "start running the tor client service .",
    "text_2": "public synchronized void start ( ) { if ( is Started ) { return ; } if ( is Stopped ) { throw new Illegal State Exception ( STRING ) ; } logger . info ( STRING + Tor . get Full Version ( ) + STRING ) ; verify Unlimited Strength Policy Installed ( ) ; directory Downloader . start ( directory ) ; circuit Manager . start Building Circuits ( ) ; if ( dashboard . is Enabled By Property ( ) ) { dashboard . start Listening ( ) ; } is Started = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "returns the complem ented incomplete gamma function .",
    "text_2": "public static double incomplete Gamma Complement ( double a , double x ) { double ans , ax , c , yc , r , t , y , z ; double pk , pkm NUM , pkm NUM , qk , qkm NUM , qkm NUM ; if ( x < = NUM | | a < = NUM ) return NUM ; if ( x < NUM | | x < a ) return NUM - incomplete Gamma ( a , x ) ; ax = a * Math . log ( x ) - x - ln Gamma ( a ) ; if ( ax < - MAX LOG ) return NUM ; ax = Math . exp ( ax ) ; y = NUM - a ; z = x + y + NUM ; c = NUM ; pkm NUM = NUM ; qkm NUM = x ; pkm NUM = x + NUM ; qkm NUM = z * x ; ans = pkm NUM / qkm NUM ; do { c + = NUM ; y + = NUM ; z + = NUM ; yc = y * c ; pk = pkm NUM * z - pkm NUM * yc ; qk = qkm NUM * z - qkm NUM * yc ; if ( qk ! = NUM ) { r = pk / qk ; t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = NUM ; pkm NUM = pkm NUM ; pkm NUM = pk ; qkm NUM = qkm NUM ; qkm NUM = qk ; if ( Math . abs ( pk ) > big ) { pkm NUM * = biginv ; pkm NUM * = biginv ; qkm NUM * = biginv ; qkm NUM * = biginv ; } } while ( t > MAC HEP ) ; return ans * ax ; }",
    "label": 1
  },
  {
    "text_1": "obtains a boolean glass function from the boolean glass gene pm provided and uses it to create a glass history and a measurement simulator . editing this im consists in editing the wrapped measurement simulator .",
    "text_2": "public Boolean Glass Gene Im ( Boolean Glass Gene Pm gene Pm , Parameters parameters ) { try { this . gene Pm = gene Pm ; this . glass Function = new Boolean Glass Function ( gene Pm . get Lag Graph ( ) ) ; this . initializer = new Basal Initializer ( glass Function , NUM , NUM ) ; this . history = new Gene History ( initializer , glass Function ) ; this . simulator = new Measurement Simulator Params ( parameters ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "called at least once on complete",
    "text_2": "public void essential ( final Consumer < On Complete > fn ) { this . essential = fn ; if ( done ) { fn . accept ( build On Complete ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "the main run ( ) method of an image fetcher thread . calls fetch loop ( ) to do the work , then removes itself from the array of image fetch ers .",
    "text_2": "public void run ( ) { final Fetcher Info info = Fetcher Info . get Fetcher Info ( ) ; try { fetch loop ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } finally { synchronized ( info . wait List ) { Thread me = Thread . current Thread ( ) ; for ( int i = NUM ; i < info . fet chers . length ; i + + ) { if ( info . fet chers [ i ] = = me ) { info . fet chers [ i ] = null ; info . num Fet chers - - ; } } } } }",
    "label": 1
  },
  {
    "text_1": "generates as chat id which will be unique for a given sender / receiver pair",
    "text_2": "public static String generate Chat Id ( final String receiver Id , final String sender Id ) { String combined = null ; if ( receiver Id . compare To ( sender Id ) < NUM ) { combined = String . format ( Locale . US , App Constants . CHAT ID FORMAT , receiver Id , sender Id ) ; } else { combined = String . format ( Locale . US , App Constants . CHAT ID FORMAT , sender Id , receiver Id ) ; } String hashed = null ; try { hashed = Utils . sha NUM ( combined ) ; } catch ( final No Such Algorithm Exception e ) { hashed = combined ; } return hashed ; }",
    "label": 1
  },
  {
    "text_1": "set if client cookies are enabled or not",
    "text_2": "public void update Client Cookies ( Boolean client Cookies ) throws Security Exception { check Write Access ( ) ; boolean has Access = Config Web Util . has Access ( config , Security Manager . TYPE SETTING ) ; if ( ! has Access ) throw new Security Exception ( STRING ) ; Element scope = get Root Element ( STRING ) ; scope . set Attribute ( STRING , Caster . to String ( client Cookies , STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "clear the internal cursor data .",
    "text_2": "public void remove All ( ) { if ( m Records . size ( ) > = NUM ) { m Records . clear ( ) ; m Current Position = - NUM ; notify Observers ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "validates if zk host contains a chroot . see http : / / zookeeper . apache . org / doc / r3 . 2 . 2 / zookeeper programmers . html ch zk sessions",
    "text_2": "public static boolean contains Ch root ( String zk Host ) { return zk Host . contains ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "reads a float ( 32 bit ) from the source stream .",
    "text_2": "public float read Float ( ) throws IO Exception { return primitive Types . read Float ( ) ; }",
    "label": 1
  },
  {
    "text_1": "find words for a more - query from documents - this query former .",
    "text_2": "public Map < String , Map < String , Flt > > retrieve Terms ( int doc Num ) throws IO Exception { return retrieve Terms ( doc Num , null ) ; }",
    "label": 1
  },
  {
    "text_1": "tell if the current node is outside the document element .",
    "text_2": "private boolean is Outside Doc Elem ( ) { return ( null = = m doc Frag ) & & m elem Stack . size ( ) = = NUM & & ( null = = m current Node | | m current Node . get Node Type ( ) = = Node . DOCUMENT NODE ) ; }",
    "label": 1
  },
  {
    "text_1": "interpolates between two rasters according to the alpha level of a mask raster .",
    "text_2": "public static void compose Through Mask ( Raster src , Writable Raster dst , Raster sel ) { int x = src . get Min X ( ) ; int y = src . get Min Y ( ) ; int w = src . get Width ( ) ; int h = src . get Height ( ) ; int src RGB [ ] = null ; int sel RGB [ ] = null ; int dst RGB [ ] = null ; for ( int i = NUM ; i < h ; i + + ) { src RGB = src . get Pixels ( x , y , w , NUM , src RGB ) ; sel RGB = sel . get Pixels ( x , y , w , NUM , sel RGB ) ; dst RGB = dst . get Pixels ( x , y , w , NUM , dst RGB ) ; int k = x ; for ( int j = NUM ; j < w ; j + + ) { int sr = src RGB [ k ] ; int dir = dst RGB [ k ] ; int sg = src RGB [ k + NUM ] ; int dig = dst RGB [ k + NUM ] ; int sb = src RGB [ k + NUM ] ; int dib = dst RGB [ k + NUM ] ; int sa = src RGB [ k + NUM ] ; int dia = dst RGB [ k + NUM ] ; float a = sel RGB [ k + NUM ] / NUM ; float ac = NUM - a ; dst RGB [ k ] = ( int ) ( a * sr + ac * dir ) ; dst RGB [ k + NUM ] = ( int ) ( a * sg + ac * dig ) ; dst RGB [ k + NUM ] = ( int ) ( a * sb + ac * dib ) ; dst RGB [ k + NUM ] = ( int ) ( a * sa + ac * dia ) ; k + = NUM ; } dst . set Pixels ( x , y , w , NUM , dst RGB ) ; y + + ; } }",
    "label": 1
  },
  {
    "text_1": "process a new port . if link discovery is disabled on the port , then do nothing . if autop ort fast feature is enabled and the port is a fast port , then do nothing . otherwise , send l ldp message . add the port to quarant ine .",
    "text_2": "private void process New Port ( long sw , short p ) { if ( is Link Discovery Suppressed ( sw , p ) ) { return ; } IOF Switch iof Switch = floodlight Provider . get Switch ( sw ) ; if ( iof Switch = = null ) return ; if ( auto Port Fast Feature & & iof Switch . is Fast Port ( p ) ) { return ; } Node Port Tuple npt = new Node Port Tuple ( sw , p ) ; discover ( sw , p ) ; if ( ! iof Switch . is Fast Port ( p ) ) { add To Quarantine Queue ( npt ) ; } else { add To Maintenance Queue ( npt ) ; } }",
    "label": 1
  },
  {
    "text_1": "removes the mapping for the specified key from this map if present .",
    "text_2": "public int remove ( Object key ) { Entry e = remove Entry For Key ( key ) ; return ( e = = null ? NUM : e . value ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new request .",
    "text_2": "private Spe ed runs Live Request ( ) { super ( URL ) ; }",
    "label": 1
  },
  {
    "text_1": "checks that all trips start and end in zones represented in the zones file .",
    "text_2": "private boolean check Trip Zone Consistency ( ) { log . info ( STRING ) ; Hash Set < String > missing Zones = new Hash Set < String > ( ) ; for ( Trip T : trips . values ( ) ) { Basic Location zo = zones . get Location ( Id . create ( T . zone o , Zone . class ) ) ; Basic Location zd = zones . get Location ( Id . create ( T . zone d , Zone . class ) ) ; if ( zo = = null ) { missing Zones . add ( T . zone o ) ; } if ( zd = = null ) { missing Zones . add ( T . zone d ) ; } } if ( missing Zones . size ( ) > NUM ) { String msg = missing Zones . size ( ) + STRING ; for ( String s : missing Zones ) msg + = STRING + s . to String ( ) + STRING ; log . error ( msg ) ; return BOOL ; } else log . info ( STRING ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "adds a new addition date",
    "text_2": "public void add Addition ( String addition ) { additions . add ( addition ) ; }",
    "label": 1
  },
  {
    "text_1": "awaits the completion of the exploded super graph . when complete , computes result values , shuts down the executor and returns .",
    "text_2": "protected void await Completion Compute Values And Shutdown ( ) { { run Executor And Await Completion ( ) ; } if ( logger . is Debug Enabled ( ) ) print Stats ( ) ; executor . shutdown ( ) ; while ( ! executor . is Terminated ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "determines if the argument provisioning has been done via the environment .",
    "text_2": "public boolean is Defined In Env ( ) { if ( env Vars = = null | | param Names . length = = NUM ) { return BOOL ; } for ( String var : env Vars ) { if ( System . getenv ( var ) = = null ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "removes a listener from the set of listeners",
    "text_2": "public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners = = null ) { return ; } m Listeners . remove ( listener ) ; }",
    "label": 1
  },
  {
    "text_1": "set union over the gathered edges .",
    "text_2": "@ Override public Set < Statement > sum ( final IG AS State < Set < Statement > , Set < Statement > , Set < Statement > > state , final Set < Statement > left , final Set < Statement > right ) { final Set < Statement > tmp = new Linked Hash Set < Statement > ( left ) ; tmp . add All ( right ) ; return tmp ; }",
    "label": 1
  },
  {
    "text_1": "create a new uni xstream of lines of the given file .",
    "text_2": "static Unix Stream < String > cat ( final String file Path ) throws IO Exception { Objects . require Non Null ( file Path , STRING ) ; return new Unix Stream Impl < > ( lines ( Paths . get ( file Path ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "check if a file is excluded or not",
    "text_2": "protected boolean exclude File ( String file ) { if ( excluded = = null ) return BOOL ; Iterator < String > iter = excluded . iterator ( ) ; while ( iter . has Next ( ) ) if ( file . ends With ( iter . next ( ) ) ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "unpacks the compressed character translation table .",
    "text_2": "private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i + + ) ; char value = packed . char At ( i + + ) ; do map [ j + + ] = value ; while ( - - count > NUM ) ; } return map ; }",
    "label": 1
  },
  {
    "text_1": "parse a url query and fragment parameters into a key - value bundle .",
    "text_2": "@ Deprecated public static Bundle parse Url ( String url ) { url = url . replace ( STRING , STRING ) ; try { URL u = new URL ( url ) ; Bundle b = decode Url ( u . get Query ( ) ) ; b . put All ( decode Url ( u . get Ref ( ) ) ) ; return b ; } catch ( Malformed URL Exception e ) { return new Bundle ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "this should always be called before attempting to call send payment .",
    "text_2": "public boolean is Expired ( ) { return payment Details . has Expires ( ) & & System . current Time Millis ( ) / NUM > payment Details . get Expires ( ) ; }",
    "label": 1
  },
  {
    "text_1": "splits a name formatted like a . b . c into a parent ' a . b ' and key ' c ' for a given index ( 2 in this example )",
    "text_2": "private String [ ] parent Key ( String name , int idx ) { String [ ] parts = name . split ( STRING ) ; if ( idx > parts . length ) return null ; String parent = STRING ; String key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = NUM ; i < idx ; i + + ) { parent = parent . length ( ) > NUM ? parent + STRING + parts [ i ] : parts [ i ] ; } return new String [ ] { parent , key } ; }",
    "label": 1
  },
  {
    "text_1": "runs any pending requests that are waiting for a connection to the service to be established . this runs in the main ui thread .",
    "text_2": "private void run Pending Requests ( ) { int max Start Id = - NUM ; Billing Request request ; while ( ( request = m Pending Requests . peek ( ) ) ! = null ) { if ( request . run If Connected ( ) ) { m Pending Requests . remove ( ) ; if ( max Start Id < request . get Start Id ( ) ) { max Start Id = request . get Start Id ( ) ; } } else { bind To Market Billing Service ( ) ; return ; } } if ( max Start Id > = NUM ) { if ( Consts . DEBUG ) { Log . i ( TAG , STRING + max Start Id ) ; } stop Self ( max Start Id ) ; } }",
    "label": 1
  },
  {
    "text_1": "displays a message to the output stream if verbose mode is enabled .",
    "text_2": "public final void print Verbose Message ( final Localizable Message msg ) { if ( is Verbose ( ) ) { out . println ( wrap ( msg ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a calendar from a given string using the provided format .",
    "text_2": "public static Calendar to Calendar ( String dat estring , String format ) { Date d = parse ( dat estring , format ) ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time In Millis ( d . get Time ( ) ) ; return cal ; }",
    "label": 1
  },
  {
    "text_1": "computes and returns the horizontal dialog base units . honors the font , font size and resolution . implementation note : 14 d lu y map to 22 pixel for 8 pt ta ho ma on 96 dpi . i could not yet manage to compute the microsoft compliant font height . therefore this method adds a correction value that seems to work well with the v ast majority of deskto ps . todo : revi se the computation of vertical base units as soon as there are more information about the original computation in microsoft environments .",
    "text_2": "private Dialog Base Units compute Dialog Base Units ( Font Metrics metrics ) { double average Char Width = compute Average Char Width ( metrics , average Char Width Test String ) ; int ascent = metrics . get Ascent ( ) ; double height = ascent > NUM ? ascent : ascent + ( NUM - ascent ) / NUM ; Dialog Base Units dialog Base Units = new Dialog Base Units ( average Char Width , height ) ; if ( LOGGER . is Loggable ( Level . CONFIG ) ) { LOGGER . config ( STRING + dialog Base Units + STRING + metrics . get Font ( ) ) ; } return dialog Base Units ; }",
    "label": 1
  },
  {
    "text_1": "tests the functionality of the method , which allows to set the regular expression .",
    "text_2": "public final void test Set Regex ( ) { Regex Constraint regex Constraint = new Regex Constraint ( Pattern . compile ( STRING ) ) ; regex Constraint . set Regex ( REGEX ) ; assert Equals ( REGEX , regex Constraint . get Regex ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "below method will be used to write the ide x file",
    "text_2": "private void write Index File ( ) throws IO Exception , Carbon Data Writer Exception { Index Header index Header = Carbon Metadata Util . get Index Header ( local Cardinality , thrift Column Schema List ) ; List < Block Index > block Index Thrift = Carbon Metadata Util . get Block Index Info ( block Index Info List ) ; String file Name = store Location + File . separator + carbon Table Path . get Carbon Index File Name ( carbon Data File Attributes . get Task Id ( ) , carbon Data File Attributes . get Fact Time Stamp ( ) ) ; Carbon Index File Writer writer = new Carbon Index File Writer ( ) ; writer . open Thrift Writer ( file Name ) ; writer . write Thrift ( index Header ) ; for ( Block Index block Index : block Index Thrift ) { writer . write Thrift ( block Index ) ; } writer . close ( ) ; copy Carbon Data File To Carbon Store Path ( file Name ) ; }",
    "label": 1
  },
  {
    "text_1": "updates the enabled state of this action depending on the new enabled state of the application .",
    "text_2": "protected void update Application Enabled ( ) { fire Property Change ( STRING , Boolean . value Of ( ! is Enabled ( ) ) , Boolean . value Of ( is Enabled ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "reads gif image from byte array",
    "text_2": "public int read ( final byte [ ] data ) { init ( ) ; if ( data ! = null ) { raw Data = Byte Buffer . wrap ( data ) ; raw Data . rewind ( ) ; raw Data . order ( Byte Order . LITTLE ENDIAN ) ; read Header ( ) ; if ( ! err ( ) ) { read Contents ( ) ; if ( frame Count < NUM ) { status = STATUS FORMAT ERROR ; } } } else { status = STATUS OPEN ERROR ; } return status ; }",
    "label": 1
  },
  {
    "text_1": "return a new collection without any inner class names",
    "text_2": "public static Collection remove Inner Class Names ( Collection col ) { List list = new Array List ( ) ; list . add All ( col ) ; Iterator it = list . iterator ( ) ; while ( it . has Next ( ) ) { String name = ( String ) it . next ( ) ; if ( name . index Of ( STRING ) ! = - NUM ) it . remove ( ) ; } return list ; }",
    "label": 1
  },
  {
    "text_1": "stops all executors and running tasks .",
    "text_2": "private void shutdown ( ) { if ( exec Svc ! = null ) exec Svc . shutdown ( NUM ) ; if ( msg Exec Svc ! = null ) msg Exec Svc . shutdown Now ( ) ; try { job . dispose ( BOOL ) ; } catch ( Ignite Checked Exception e ) { U . error ( log , STRING , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "internal callback method for subclasses to use to be able to configure image reader loader vector with specific image reader loaders . by default , loads geo tif fi mage reader . loader .",
    "text_2": "protected void configure Image Reader Loaders ( ) { image Reader Loaders = new Vector < Image Reader Loader > ( ) ; Image Reader Loader idl = ( Image Reader Loader ) Component Factory . create ( STRING ) ; if ( idl ! = null ) { image Reader Loaders . add ( idl ) ; } else { logger . warning ( STRING ) ; } idl = ( Image Reader Loader ) Component Factory . create ( STRING ) ; if ( idl ! = null ) { image Reader Loaders . add ( idl ) ; } else { logger . warning ( STRING ) ; } }",
    "label": 1
  },
  {
    "text_1": "writes the image out . the input data should be a valid jpeg format . after writing , it ' s exif header will be replaced by the given header .",
    "text_2": "@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { while ( ( m Byte To Skip > NUM | | m Byte To Copy > NUM | | m State ! = STATE JPEG DATA ) & & length > NUM ) { if ( m Byte To Skip > NUM ) { int byte To Process = length > m Byte To Skip ? m Byte To Skip : length ; length - = byte To Process ; m Byte To Skip - = byte To Process ; offset + = byte To Process ; } if ( m Byte To Copy > NUM ) { int byte To Process = length > m Byte To Copy ? m Byte To Copy : length ; out . write ( buffer , offset , byte To Process ) ; length - = byte To Process ; m Byte To Copy - = byte To Process ; offset + = byte To Process ; } if ( length = = NUM ) { return ; } switch ( m State ) { case STATE SO I : int byte Read = request Byte To Buffer ( NUM , buffer , offset , length ) ; offset + = byte Read ; length - = byte Read ; if ( m Buffer . position ( ) < NUM ) { return ; } m Buffer . rewind ( ) ; if ( m Buffer . get Short ( ) ! = Jpeg Header . SO I ) { throw new IO Exception ( STRING ) ; } out . write ( m Buffer . array ( ) , NUM , NUM ) ; m State = STATE FRAME HEADER ; m Buffer . rewind ( ) ; write Exif Data ( ) ; break ; case STATE FRAME HEADER : byte Read = request Byte To Buffer ( NUM , buffer , offset , length ) ; offset + = byte Read ; length - = byte Read ; if ( m Buffer . position ( ) = = NUM ) { short tag = m Buffer . get Short ( ) ; if ( tag = = Jpeg Header . EOI ) { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m Buffer . rewind ( ) ; } } if ( m Buffer . position ( ) < NUM ) { return ; } m Buffer . rewind ( ) ; short marker = m Buffer . get Short ( ) ; if ( marker = = Jpeg Header . APP NUM ) { m Byte To Skip = ( m Buffer . get Short ( ) & NUM ) - NUM ; m State = STATE JPEG DATA ; } else if ( ! Jpeg Header . is S of Marker ( marker ) ) { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m Byte To Copy = ( m Buffer . get Short ( ) & NUM ) - NUM ; } else { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m State = STATE JPEG DATA ; } m Buffer . rewind ( ) ; } } if ( length > NUM ) { out . write ( buffer , offset , length ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a new server builder .",
    "text_2": "public Server Builder ( Config config ) { Objects . require Non Null ( config ) ; config = config ; }",
    "label": 1
  },
  {
    "text_1": "converts the provided string to bytes using the utf - 8 encoding . if the input is malformed , invalid chars are replaced by a default value .",
    "text_2": "public static Byte Buffer encode ( String string ) throws Character Coding Exception { return encode ( string , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new skeleton ( iterator ) instance .",
    "text_2": "public Skeleton ( Print Writer out ) { this . out = out ; }",
    "label": 1
  },
  {
    "text_1": "checks basic missing value handling of the scheme . if the missing values cause an exception to be thrown by the scheme , this will be recorded .",
    "text_2": "protected boolean [ ] can Handle Missing ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing , int missing Level ) { if ( missing Level = = NUM ) { print ( STRING ) ; } print ( STRING ) ; if ( predictor Missing ) { print ( STRING ) ; if ( class Missing ) { print ( STRING ) ; } } if ( class Missing ) { print ( STRING ) ; } print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }",
    "label": 1
  },
  {
    "text_1": "make a change to a node in the displayed tree . either its name or the contents of its leaves ( image references )",
    "text_2": "public boolean node Change ( Catalog Tree Node node , String name ) { Catalog Tree Node c Node = get Corresponding Node ( node ) ; c Node . set Leaves ( node . get Leaves ( ) ) ; Abstract Catalog Tree tree = ( Abstract Catalog Tree ) get Co respon ding Model ( node ) ; c Node . set User Object ( name ) ; node . set User Object ( name ) ; tree . node Changed ( c Node ) ; model . node Changed ( node ) ; update Panel ( ) ; Image Index Editor . index Changed ( BOOL ) ; update Panel ( ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "checks if test is expected to crash . path given should relative within layout tests folder , e . g . fast / dom / foo . html",
    "text_2": "public boolean is Crash ( String test Path ) { for ( String prefix : get Prefixes ( test Path ) ) { if ( m Crash List . contains ( prefix ) ) { return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "notifies the listener , if registered , of a change of the value of this number picker .",
    "text_2": "private void notify Change ( int previous , int current ) { if ( m On Value Change Listener ! = null ) { m On Value Change Listener . on Value Change ( this , previous , m Value ) ; } }",
    "label": 1
  },
  {
    "text_1": "advances through the circular list returning the first element for which the predicate evaluates to true . if there is no such element , returns null leaving the head of the list back in the same place .",
    "text_2": "public T advance To Element ( Predicate < T > predicate ) { Node < T > start = head ; if ( head = = null ) return null ; do { T curr Element = advance ( ) ; if ( predicate . test ( curr Element ) ) { return curr Element ; } } while ( head ! = start ) ; return null ; }",
    "label": 1
  },
  {
    "text_1": "kill the latest alive entry",
    "text_2": "Entry kill ( ) { Entry entry ; for ( int i = entries . size ( ) - NUM ; i > = NUM ; i - - ) { entry = entries . get ( i ) ; if ( ! entry . dead ) { entry . dead = BOOL ; return entry ; } } throw new Illegal State Exception ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "create a class descriptor from a resource name .",
    "text_2": "public static Class Descriptor create Class Descriptor From Resource Name ( String resource Name ) { if ( ! is Class Resource ( resource Name ) ) { throw new Illegal Argument Exception ( STRING + resource Name + STRING ) ; } return create Class Descriptor ( resource Name . substring ( NUM , resource Name . length ( ) - NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the minimum amount of space the layout needs .",
    "text_2": "public Dimension minimum Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = get Insets ( ) ; if ( content Pane ! = null ) { rd = content Pane . get Minimum Size ( ) ; } else { rd = parent . get Size ( ) ; } if ( menu Bar ! = null & & menu Bar . is Visible ( ) ) { mbd = menu Bar . get Minimum Size ( ) ; } else { mbd = new Dimension ( NUM , NUM ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }",
    "label": 1
  },
  {
    "text_1": "indicates if a shutdown hook is registered or not .",
    "text_2": "public boolean has Shutdown Hook ( Runnable shutdown Hook ) { return hooks . contains ( shutdown Hook ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a multisig aggregate modification .",
    "text_2": "public static Multisig Aggregate Modification Transaction create Multisig Modification ( ) { return new Multisig Aggregate Modification Transaction ( Time Instant . ZERO , Utils . generate Random Account ( ) , Collections . singleton List ( new Multisig Co sign atory Modification ( Multisig Modification Type . Add Co sign atory , Utils . generate Random Account ( ) ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the velocity con stri ction coefficient .",
    "text_2": "protected double constr iction Coefficient ( double c1 , double c2 ) { double rho = c1 + c2 ; if ( rho < = NUM ) { return NUM ; } else { return NUM / ( NUM - rho - Math . sqrt ( Math . pow ( rho , NUM ) - NUM * rho ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "constructs a new parser for the given format string .",
    "text_2": "Format Specifier Parser ( String format ) { this . format = format ; this . length = format . length ( ) ; }",
    "label": 1
  },
  {
    "text_1": "this must be called after creation from the artifact info factory after this class has been put into the global map in order to avoid recursive initialization",
    "text_2": "public void populate All ( ) throws General Exception { for ( Service E ca Action eca Action : service E ca Rule . get E ca Action List ( ) ) { services Called By This Service E ca . add ( a if . get Service Artifact Info ( eca Action . get Service Name ( ) ) ) ; Util Misc . add To Sorted Set In Map ( this , a if . all Service E ca Infos Referring To Service Name , eca Action . get Service Name ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "create a deep copy of the peer which references the same remote peer but whose peer network is a distinct object .",
    "text_2": "public Peer clone ( ) { Peer clone = new Peer ( network . clone ( ) , address ) ; return clone ; }",
    "label": 1
  },
  {
    "text_1": "insert one row into database with the auto incremental id returned .",
    "text_2": "public static int create With Id Generation ( Connection connection , String raw Sql Query , Object . . . parameters ) throws SQL Exception { Prepared Statement stmt = null ; Result Set rs = null ; try { stmt = connection . prepare Statement ( raw Sql Query , Statement . RETURN GENERATED KEYS ) ; for ( int index = NUM ; index < parameters . length ; index + + ) { Jdbc Utils . bind Parameter ( stmt , index + NUM , parameters [ index ] ) ; } stmt . execute Update ( ) ; rs = stmt . get Generated Keys ( ) ; rs . next ( ) ; return rs . get Int ( NUM ) ; } finally { Jdbc Utils . close Result Set ( rs ) ; Jdbc Utils . close Statement ( stmt ) ; } }",
    "label": 1
  },
  {
    "text_1": "this is the default implementation of writeobject . customize if necessary .",
    "text_2": "private void write Object ( Object Output Stream a Output Stream ) throws IO Exception { a Output Stream . default Write Object ( ) ; }",
    "label": 1
  },
  {
    "text_1": "determines if a car type can have a specific load name .",
    "text_2": "public boolean contains Name ( String type , String name ) { List < String > names = get Names ( type ) ; return names . contains ( name ) ; }",
    "label": 1
  },
  {
    "text_1": "wsp type decoder test , decode om a content type",
    "text_2": "public void test Decoder NUM ( ) { boolean res ; String original App Id Name = m App Id Name ; int original Content Type Value = m Content Type Value ; Random rd = new Random ( ) ; for ( int i = NUM ; i < OMA CONTENT TYPE NAMES . length ; i + + ) { m Content Type Name = OMA CONTENT TYPE NAMES [ i ] ; byte [ ] pdu = create PDU ( NUM ) ; Wsp Type Decoder pdu Decoder = new Wsp Type Decoder ( pdu ) ; res = pdu Decoder . decode Content Type ( m Wsp Content Type Start ) ; assert True ( res ) ; Log . d ( LOG TAG , STRING + m Content Type Name + STRING + pdu Decoder . get Value String ( ) + STRING ) ; assert True ( m Content Type Name . equals ( pdu Decoder . get Value String ( ) ) ) ; } m App Id Name = original App Id Name ; m Content Type Value = original Content Type Value ; }",
    "label": 1
  },
  {
    "text_1": "asserts the type of this column as reported by the resultsetmetadata of this resultset .",
    "text_2": "public void assert Column Type ( Result Set rs ) throws SQL Exception { Result Set Meta Data md = rs . get Meta Data ( ) ; int sql Type = md . get Column Type ( mdi . get Position ( ) ) ; assert True ( String . format ( STRING , sql Type , mdi ) , is Allowed Sql Type ( sql Type ) ) ; }",
    "label": 1
  },
  {
    "text_1": "det atches the bitmap container from the request and cancels the request if no one is left listening .",
    "text_2": "public boolean remove Container And Cancel If Necessary ( Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . size ( ) = = NUM ) { m Request . cancel ( ) ; return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "when an instance of this class is used as a delegate for the implementation of the beancontext protocols ( and its sub protocols ) there exists a ' chic ken and egg ' problem during deserialization",
    "text_2": "public final void read Children ( Object Input Stream ois ) throws IO Exception , Class Not Found Exception { int count = serializable ; while ( count - - > NUM ) { Object child = null ; Bean Context Support . BCS Child bs cc = null ; try { child = ois . read Object ( ) ; bs cc = ( Bean Context Support . BCS Child ) ois . read Object ( ) ; } catch ( IO Exception ioe ) { continue ; } catch ( Class Not Found Exception cnfe ) { continue ; } synchronized ( child ) { Bean Context Child bcc = null ; try { bcc = ( Bean Context Child ) child ; } catch ( Class Cast Exception cce ) { } if ( bcc ! = null ) { try { bcc . set Bean Context ( get Bean Context Peer ( ) ) ; bcc . add Property Change Listener ( STRING , child PCL ) ; bcc . add Vetoable Change Listener ( STRING , child V CL ) ; } catch ( Property Veto Exception pve ) { continue ; } } child Deserialized Hook ( child , bs cc ) ; } } }",
    "label": 1
  },
  {
    "text_1": "return a ds : keyvalue element in dom . keyvalue | - - - - - rsa keyvalue",
    "text_2": "private Element create Key Value ( ) throws Exception { Element key Value Ele = null ; Private Key key = idm Client . get Tenant Private Key ( tenant Name ) ; if ( key ! = null ) { RSA Private Key rsa Key = ( RSA Private Key ) key ; Element rsa Key Ele = create RSA Key Value ( rsa Key ) ; if ( rsa Key Ele ! = null ) { key Value Ele = doc . create Element ( SAML Names . DS KEY VALUE ) ; key Value Ele . append Child ( rsa Key Ele ) ; } } return key Value Ele ; }",
    "label": 1
  },
  {
    "text_1": "determines if there is valid cover for an inf an try unit to utilize the using non - inf an try as cover rules ( to pg 108 ) .",
    "text_2": "public static boolean has Valid Cover ( I Game game , Coords pos , int elevation ) { if ( ( pos = = null ) | | ( elevation > NUM ) ) { return BOOL ; } boolean has Moved Entity = BOOL ; for ( Entity e : game . get Entities Vector ( pos ) ) { if ( e . is Done ( ) & & ! ( e instanceof Infantry ) & & ( e . get Elevation ( ) = = elevation ) ) { has Moved Entity = BOOL ; break ; } } if ( ! has Moved Entity ) { Enumeration < Entity > w rec ks = game . get W rec ked Entities ( ) ; while ( w rec ks . has More Elements ( ) ) { Entity e = w rec ks . next Element ( ) ; if ( pos . equals ( e . get Position ( ) ) & & ! ( e instanceof Infantry ) ) { has Moved Entity = BOOL ; } } } return has Moved Entity ; }",
    "label": 1
  },
  {
    "text_1": "method that never returns , e . g . to keep a daemon running .",
    "text_2": "protected int never ( ) { synchronized ( sleep Lock ) { while ( running ) { try { sleep Lock . wait ( NUM * NUM * NUM ) ; } catch ( Interrupted Exception e ) { continue ; } } return NUM ; } }",
    "label": 1
  },
  {
    "text_1": "draws an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics 2 d . the given transformation is applied to the image before the transform attribute in the graphics 2 d state is applied . the rendering attributes applied include the clip , transform , and composite attributes . note that the result is undefined , if the given transform is non invertible .",
    "text_2": "public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img = = null ) { return BOOL ; } boolean result ; int src Width = img . get Width ( null ) ; int src Height = img . get Height ( null ) ; if ( src Width < NUM | | src Height < NUM ) { result = BOOL ; } else { result = draw Image To Platform ( img , xform , null , NUM , NUM , src Width , src Height , BOOL ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "create an scaling icon that will be moved around .",
    "text_2": "public Temporal OM Scaling Icon ( Object id , int render Type , boolean interpolate , Image Icon ii ) { this ( id , render Type , interpolate , ii . get Image ( ) , NUM ) ; set Max Scale ( NUM ) ; set Min Scale ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "converts a disconnected multiple indicator model into a set of clusters . assumes the given graph contains a number of lat ents li , i = 0 , . . . , n - 1 , for each of which there is a list of indicators w j , j = 0 , . . . , m i - 1 , such that , li - - > w j . returns a clusters object mapping i to w j . the name for cluster i is set to li .",
    "text_2": "public static Clusters convert To Clusters ( Graph cluster Graph , List < Node > measured Variables ) { List < String > latents = new Array List < > ( ) ; Clusters clusters = new Clusters ( ) ; cluster Graph = Graph Utils . replace Nodes ( cluster Graph , measured Variables ) ; for ( Node node : cluster Graph . get Nodes ( ) ) { if ( ! measured Variables . contains ( node ) ) { latents . add ( node . get Name ( ) ) ; } } Collections . sort ( latents ) ; for ( int i = NUM ; i < latents . size ( ) ; i + + ) { String name = latents . get ( i ) ; clusters . set Cluster Name ( i , name ) ; Node latent = cluster Graph . get Node ( name ) ; List < Node > measured = cluster Graph . get Nodes Out To ( latent , Endpoint . ARROW ) ; for ( Node node : measured ) { if ( measured Variables . contains ( node ) ) { clusters . add To Cluster ( i , node . get Name ( ) ) ; } } } return clusters ; }",
    "label": 1
  },
  {
    "text_1": "add menu item to - add new line to node",
    "text_2": "private void add Menu Item ( J Popup Menu menu , String title , MWF Node node , int AD WF Node To ID ) { WF Popup Item item = new WF Popup Item ( title , node , AD WF Node To ID ) ; menu . add ( item ) ; item . add Action Listener ( this ) ; }",
    "label": 1
  },
  {
    "text_1": "in the idl , fonts are represented by a string . tradit ionally , with mat t , the font was a x representation of a font . that ' s what is being done here - we ' re taking the font structure , and then going to x font type text structure . dashes need to be included , line feeds are not . they are here only for readability . the j text object brings this back to a java font . like wise , doing the transformation this way makes all special ists compatible with all other clients .",
    "text_2": "public String resolve Font ( java . awt . Font font ) { String ret = STRING ; ret = ret . concat ( STRING + font . get Name ( ) ) ; if ( font . is Bold ( ) ) ret = ret . concat ( STRING ) ; else ret = ret . concat ( STRING ) ; if ( font . is Italic ( ) ) ret = ret . concat ( STRING ) ; else ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING + font . get Size ( ) ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; return ret ; }",
    "label": 1
  },
  {
    "text_1": "try to lock the file .",
    "text_2": "public synchronized boolean try Lock ( ) { try { lock = file . try Lock ( ) ; return lock ! = null ; } catch ( Exception e ) { return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "decode phase information for each subband of a channel .",
    "text_2": "private void decode Tones Phase ( int ch Num , boolean band Has Tones [ ] ) { Waves Data dst [ ] = ctx . channels [ ch Num ] . tones Info ; for ( int sb = NUM ; sb < ctx . waves Info . num Tone Bands ; sb + + ) { if ( ! band Has Tones [ sb ] ) { continue ; } int w param = dst [ sb ] . start Index ; for ( int i = NUM ; i < dst [ sb ] . num W avs ; i + + ) { ctx . waves Info . waves [ w param + i ] . phase Index = br . read ( NUM ) ; } } }",
    "label": 1
  },
  {
    "text_1": "returns a random number from the distribution ; bypasses the internal state .",
    "text_2": "public double next Double ( double k ) { double u , v , w , c , z ; if ( k < = NUM ) throw new Illegal Argument Exception ( ) ; if ( k set ! = k ) { tau = NUM + Math . sqrt ( NUM + NUM * k * k ) ; rho = ( tau - Math . sqrt ( NUM * tau ) ) / ( NUM * k ) ; r = ( NUM + rho * rho ) / ( NUM * rho ) ; k set = k ; } do { u = random Generator . raw ( ) ; v = random Generator . raw ( ) ; z = Math . cos ( Math . PI * u ) ; w = ( NUM + r * z ) / ( r + z ) ; c = k * ( r - w ) ; } while ( ( c * ( NUM - c ) < v ) & & ( Math . log ( c / v ) + NUM < c ) ) ; return ( random Generator . raw ( ) > NUM ) ? Math . acos ( w ) : - Math . acos ( w ) ; }",
    "label": 1
  },
  {
    "text_1": "performs an auto - focus scan , blocking until the scan starts , runs , and completes .",
    "text_2": "@ Override public void run ( ) throws Interrupted Exception , Camera Access Exception , Camera Capture Session Closed Exception , Resource Acquisition Failed Exception { Frame Server . Session session = m Frame Server . try Create Exclusive Session ( ) ; if ( session = = null ) { return ; } try { AF Trigger Result af Scan Result = new AF Trigger Result ( ) ; Request Builder idle Builder = create AF Idle Request ( null ) ; session . submit Request ( Arrays . as List ( idle Builder . build ( ) ) , Frame Server . Request Type . REPE ATING ) ; Request Builder cancel Builder = create AF Cancel Request ( null ) ; session . submit Request ( Arrays . as List ( cancel Builder . build ( ) ) , Frame Server . Request Type . NON REPE ATING ) ; idle Builder = create AF Idle Request ( af Scan Result ) ; session . submit Request ( Arrays . as List ( idle Builder . build ( ) ) , Frame Server . Request Type . REPE ATING ) ; Request Builder trigger Builder = create AF Trigger Request ( af Scan Result ) ; session . submit Request ( Arrays . as List ( trigger Builder . build ( ) ) , Frame Server . Request Type . NON REPE ATING ) ; af Scan Result . get ( ) ; } finally { session . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "sets time limit for a ranking list in days ( the default value is all time ) .",
    "text_2": "public Ranking Image List Provider in Days ( int days ) { m Time = Integer . to String ( days ) + STRING ; return this ; }",
    "label": 1
  },
  {
    "text_1": "performs a sort on the given string array . elements will be re - ordered into ascending order . uses a stable ternary quick sort algorithm .",
    "text_2": "private static void stable String Sort ( String [ ] arr , String [ ] src , String [ ] dst , int start , int end , int ch Id ) { int length = end - start ; if ( length < SIMPLE LENGTH ) { if ( src = = arr ) { for ( int i = start + NUM ; i < end ; i + + ) { String current = arr [ i ] ; String prev = arr [ i - NUM ] ; if ( current . compare To ( prev ) < NUM ) { int j = i ; do { arr [ j - - ] = prev ; } while ( j > start & & current . compare To ( prev = arr [ j - NUM ] ) < NUM ) ; arr [ j ] = current ; } } } else { int actual End = end - NUM ; dst [ start ] = src [ actual End - - ] ; for ( int i = start + NUM ; i < end ; i + + , actual End - - ) { String current = src [ actual End ] ; String prev ; int j = i ; while ( j > start & & current . compare To ( prev = dst [ j - NUM ] ) < NUM ) { dst [ j - - ] = prev ; } dst [ j ] = current ; } } return ; } int s ; int mid = start + length / NUM ; int lo = start ; int hi = end - NUM ; if ( length > NUM ) { s = length / NUM ; lo = med Char ( lo , lo + s , lo + s * NUM , src , ch Id ) ; mid = med Char ( mid - s , mid , mid + s , src , ch Id ) ; hi = med Char ( hi , hi - s , hi - s * NUM , src , ch Id ) ; } mid = med Char ( lo , mid , hi , src , ch Id ) ; int mid Val = char At ( src [ mid ] , ch Id ) ; int a , b , c ; a = b = start ; c = end - NUM ; int cmp ; for ( int i = start ; i < end ; i + + ) { String el = src [ i ] ; cmp = char At ( el , ch Id ) - mid Val ; if ( cmp < NUM ) { src [ a ] = el ; a + + ; } else if ( cmp > NUM ) { dst [ c ] = el ; c - - ; } else { dst [ b ] = el ; b + + ; } } s = b - start ; if ( s > NUM ) { if ( arr = = src ) { System . arraycopy ( dst , start , arr , a , s ) ; } else { copy Swap ( dst , start , arr , a , s ) ; } if ( b > = end & & mid Val = = - NUM ) { return ; } stable String Sort ( arr , arr , arr = = dst ? src : dst , a , a + s , ch Id + NUM ) ; } s = a - start ; if ( s > NUM ) { stable String Sort ( arr , src , dst , start , a , ch Id ) ; } c + + ; s = end - c ; if ( s > NUM ) { stable String Sort ( arr , dst , src , c , end , ch Id ) ; } }",
    "label": 1
  },
  {
    "text_1": "a part is considered manufact ured if it has child nodes and unless igno res upp lier products is set , if it also has no un expired supplier products defined",
    "text_2": "public boolean is Manufac tured ( boolean ignore Supplier Products ) { List < Generic Value > supplier Products = null ; try { supplier Products = product . get Related ( STRING , Util Misc . to Map ( STRING , STRING ) , Util Misc . to List ( STRING ) , BOOL ) ; } catch ( Generic Entity Exception gee ) { Debug . log Error ( STRING , module ) ; } supplier Products = Entity Util . filter By Date ( supplier Products , Util Date Time . now Timestamp ( ) , STRING , STRING , BOOL ) ; return children Nodes . size ( ) > NUM & & ( ignore Supplier Products | | Util Validate . is Empty ( supplier Products ) ) ; }",
    "label": 1
  },
  {
    "text_1": "copies a bit range from one vector to another .",
    "text_2": "public static void copy ( long [ ] src , int src Offset , long [ ] dst , int dst Offset , int len ) { int src Limit = src Offset + len ; while ( src Offset < src Limit ) { int src Idx = src Offset & NUM ; int dst Idx = dst Offset & NUM ; int src Remainder = NUM - src Idx ; int dst Remainder = NUM - dst Idx ; int chunk Len = Math . min ( src Remainder , dst Remainder ) ; long mask = mask Below ( chunk Len ) < < src Idx ; dst [ dst Offset > > NUM ] | = ( ( src [ src Offset > > NUM ] & mask ) > > > src Idx ) < < dst Offset ; src Offset + = chunk Len ; dst Offset + = chunk Len ; } }",
    "label": 1
  },
  {
    "text_1": "allocates / reserv ates memory : a specified block size in bytes , multiplied by a given number of blocks . currently does not check whether the starting address is a multiple of the requested size , e . g . it is perfectly possible that a 4 - byte block will start at address 3",
    "text_2": "public Address malloc ( int size , int howmany ) { int result = next Reser vable Address ; next Reser vable Address + = size * howmany ; if ( next Reser vable Address > ( MEM SIZE + mem Address Start ) ) { address Out Of Range = BOOL ; return null ; } return new Address ( Op . MEM , size , result ) ; }",
    "label": 1
  },
  {
    "text_1": "cancel all the download .",
    "text_2": "void cancel All ( ) { synchronized ( current Requests ) { for ( Download Request request : current Requests ) { request . cancel ( ) ; } } current Requests . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "decodes a byte array from base 64 format . no blanks or line breaks are allowed within the base 64 encoded input data .",
    "text_2": "public static byte [ ] decode ( String s ) { return decode ( s . to Char Array ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "compute the bounds of all of the split / divider / leaf nodes in the layout model , and then set the bounds of each child component with a matching leaf node .",
    "text_2": "public void layout Container ( final Container parent ) { check Layout ( get Model ( ) ) ; final Insets insets = parent . get Insets ( ) ; final Dimension size = parent . get Size ( ) ; final int width = size . width - ( insets . left + insets . right ) ; final int height = size . height - ( insets . top + insets . bottom ) ; final Rectangle bounds = new Rectangle ( insets . left , insets . top , width , height ) ; layout NUM ( get Model ( ) , bounds ) ; layout NUM ( get Model ( ) , bounds ) ; }",
    "label": 1
  },
  {
    "text_1": "< rm > , r rx operation : shifter operand = ( c flag logical shift left 31 ) or ( rm logical shift right 1 ) shifter carry out = rm [ 0 ]",
    "text_2": "protected static Pair < String , String > r rx Register ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value ) { final String shifter Operand = environment . get Next Variable String ( ) ; final String shifter Carry Out = environment . get Next Variable String ( ) ; final String tmp Var NUM = environment . get Next Variable String ( ) ; final String tmp Var NUM = environment . get Next Variable String ( ) ; final String tmp Var NUM = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset + + , byte Size , STRING , word Size , th irty One Set , d Word Size , tmp Var NUM ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset + + , d Word Size , register Node Value , byte Size , STRING + one Set , d Word Size , tmp Var NUM ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset + + , d Word Size , tmp Var NUM , d Word Size , tmp Var NUM , d Word Size , tmp Var NUM ) ) ; instructions . add ( Reil Helpers . create And ( base Offset + + , d Word Size , tmp Var NUM , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add ( Reil Helpers . create And ( base Offset + + , d Word Size , register Node Value , byte Size , String . value Of ( NUM ) , byte Size , shifter Carry Out ) ) ; return new Pair < String , String > ( shifter Operand , shifter Carry Out ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new scanne rexception with a message only .",
    "text_2": "public Scanner Exception ( Error Messages message ) { this ( null , Error Messages . get ( message ) , message , - NUM , - NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if this configuration supports the given rendering capability",
    "text_2": "public boolean supports ( @ Magic Constant ( flags From Class = Features . class ) int capability ) { I Android Target target = get Target ( ) ; if ( target ! = null ) { return Render Service . supports Capability ( get Module ( ) , target , capability ) ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "puts all views in the sc rap heap into the supplied list .",
    "text_2": "void reclaim Scrap Views ( List < View > views ) { if ( m View Type Count = = NUM ) { views . add All ( m Current Scrap ) ; } else { final int view Type Count = m View Type Count ; final Array List < View > [ ] scrap Views = m Scrap Views ; for ( int i = NUM ; i < view Type Count ; + + i ) { final Array List < View > scrap Pile = scrap Views [ i ] ; views . add All ( scrap Pile ) ; } } }",
    "label": 1
  },
  {
    "text_1": "get the distance between this vector and another vector .",
    "text_2": "public double distance ( Vector other ) { return Math . sqrt ( Math . pow ( other . x - x , NUM ) + Math . pow ( other . y - y , NUM ) + Math . pow ( other . z - z , NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "validates this soot class for logical errors . note that this does not validate the method bodies , only the class structure .",
    "text_2": "public void validate ( ) { final List < Validation Exception > exception List = new Array List < Validation Exception > ( ) ; validate ( exception List ) ; if ( ! exception List . is Empty ( ) ) throw exception List . get ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an instance of a date unit .",
    "text_2": "public static Date Time Unit create Local Date Unit Instance ( Date date , org . h isp . d his . calendar . Calendar calendar ) { return calendar . from Iso ( Date Time Unit . from Jdk Date ( date ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method requires the caller to hold the permission access network state .",
    "text_2": "public static boolean is Wifi Connected ( Context context ) { Connectivity Manager connectivity Manager = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info network Info = connectivity Manager . get Active Network Info ( ) ; return network Info ! = null & & network Info . get Type ( ) = = Connectivity Manager . TYPE WIFI ; }",
    "label": 1
  },
  {
    "text_1": "after all lines created , clean all non - linked stations , all pt - exclusive links ( check allowed modes ) and all nodes which are non - linked to any link after the above cleaning . . . clean also the allowed modes for only the modes , no line - number any more . . .",
    "text_2": "protected void clean Stations And Network ( ) { log . info ( STRING ) ; clean Schedule ( ) ; remove Non Used Stop Facilities ( ) ; clean Modes ( ) ; remove Non Used Links ( ) ; log . info ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "adds p object to the undoable object slist a check is made to make sure that p object is non null by doing this i am guarantee that a get will always return a non null object",
    "text_2": "public void insert ( Undo Object Storable p object ) { if ( p object = = null ) throw new Illegal Argument Exception ( classname + STRING ) ; disable redo ( ) ; Undo Object Node undoable object = new Undo Object Node ( p object , stack level ) ; objects map . put ( p object , undoable object ) ; }",
    "label": 1
  },
  {
    "text_1": "loads the current meta state for each index in the new cluster state and checks if it has to be persisted . each index state that should be written to disk will be returned . this is only run for data only nodes . it will return only the states for indices that actually have a shard allocated on the current node .",
    "text_2": "public static Iterable < Gateway Meta State . Index Meta Write Info > resolve States To Be Written ( Immutable Set < String > previously Written Indices , Set < String > potentially Un written Indices , Meta Data previous Meta Data , Meta Data new Meta Data ) { List < Gateway Meta State . Index Meta Write Info > indices To Write = new Array List < > ( ) ; for ( String index : potentially Un written Indices ) { Index Meta Data new Index Meta Data = new Meta Data . index ( index ) ; Index Meta Data previous Index Meta Data = previous Meta Data = = null ? null : previous Meta Data . index ( index ) ; String write Reason = null ; if ( previously Written Indices . contains ( index ) = = BOOL | | previous Index Meta Data = = null ) { write Reason = STRING ; } else if ( previous Index Meta Data . get Version ( ) ! = new Index Meta Data . get Version ( ) ) { write Reason = STRING + previous Index Meta Data . get Version ( ) + STRING + new Index Meta Data . get Version ( ) + STRING ; } if ( write Reason ! = null ) { indices To Write . add ( new Gateway Meta State . Index Meta Write Info ( new Index Meta Data , previous Index Meta Data , write Reason ) ) ; } } return indices To Write ; }",
    "label": 1
  },
  {
    "text_1": "adds a extension point .",
    "text_2": "public void add Extension Point ( Extension Point extension Point ) { f Extension Points . add ( extension Point ) ; }",
    "label": 1
  },
  {
    "text_1": "makes this object immutable .",
    "text_2": "public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "when the slider is clicked we need to record the offset from the thumb centre .",
    "text_2": "@ Override public void mouse Pressed ( Mouse Event evt ) { int pos = ( slider . get Orientation ( ) = = J Slider . HORIZONTAL ) ? evt . get X ( ) : evt . get Y ( ) ; int loc = get Location For Value ( get Snapped Value ( evt ) ) ; this . offset = ( loc < NUM ) ? NUM : pos - loc ; }",
    "label": 1
  },
  {
    "text_1": "reset any internal state , allowing this builder to be recycled .",
    "text_2": "@ Suppress Warnings ( STRING ) public Selection Builder reset ( ) { m Table = null ; if ( m Projection Map ! = null ) { m Projection Map . clear ( ) ; } if ( m Selection ! = null ) { m Selection . set Length ( NUM ) ; } if ( m Selection Args ! = null ) { m Selection Args . clear ( ) ; } return this ; }",
    "label": 1
  },
  {
    "text_1": "subtract two positive numbers of the same length . the first is greater .",
    "text_2": "public void test Case NUM ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "writes a ma ple - convention ascii string to the stream .",
    "text_2": "public final void write Maple Ascii String ( final String s ) { write Short ( ( short ) s . length ( ) ) ; write Ascii String ( s ) ; }",
    "label": 1
  },
  {
    "text_1": "receives an cloudlet to be executed in the vm managed by this scheduler .",
    "text_2": "@ Override public double cloudlet Submit ( Cloudlet cl ) { return cloudlet Submit ( cl , NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "returns new min start and new length that is inside the range specified by the arguments .",
    "text_2": "protected double [ ] random Sub Range ( double bound Start , double bound Len ) { if ( bound Len > = NUM & & usu ally ( ) ) { int int Bound Start = ( int ) Math . ceil ( bound Start ) ; int int Bound End = ( int ) ( bound Start + bound Len ) ; int int Bound Len = int Bound End - int Bound Start ; int new Len = ( int ) random Gaussian Mean Max ( int Bound Len / NUM , int Bound Len ) ; int new Start = int Bound Start + random Int ( int Bound Len - new Len ) ; return new double [ ] { new Start , new Len } ; } else { double new Len = random Gaussian Mean Max ( bound Len / NUM , bound Len ) ; double new Start = bound Start + ( bound Len - new Len = = NUM ? NUM : ( random Double ( ) % ( bound Len - new Len ) ) ) ; return new double [ ] { new Start , new Len } ; } }",
    "label": 1
  },
  {
    "text_1": "util method to write an attribute with the ns prefix",
    "text_2": "private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) = = null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }",
    "label": 1
  },
  {
    "text_1": "trigger the notification of all propertychangelisteners",
    "text_2": "@ Suppress Warnings ( STRING ) protected void notify Property Change Listener ( String property , Object old Value , Object new Value ) { if ( ( old Value ! = null & & old Value . equals ( new Value ) ) | | old Value = = new Value ) { log . error ( STRING ) ; } Vector < Property Change Listener > v ; synchronized ( this ) { v = ( Vector < Property Change Listener > ) listeners . clone ( ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + v . size ( ) + STRING + property ) ; } int cnt = v . size ( ) ; for ( int i = NUM ; i < cnt ; i + + ) { Property Change Listener client = v . element At ( i ) ; client . property Change ( new Property Change Event ( this , property , old Value , new Value ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "converts a natural language list of numerals into a list of integers . sample input of \" 10 , 20 , 20 , 303 , 50 , 10 12 - 10 14 . 1 - 2 , 5 - - - 5 \" would produce [ 1 , 2 , 5 , 10 , 20 , 20 , 50 , 303 , 10 12 , 10 13 , 10 14 ] .",
    "text_2": "public static List < Integer > parse Numeric List ( String string ) { Array List < Integer > list = new Array List < > ( ) ; Pattern ranges = Pattern . compile ( STRING ) ; Matcher m = ranges . matcher ( string ) ; while ( m . find ( ) ) { String range = m . group ( STRING ) ; string = string . replace ( range , STRING ) ; parse Numeric Range ( range , list ) ; } String [ ] numbers = string . split ( STRING ) ; for ( int i = NUM ; i < numbers . length ; + + i ) { String number = numbers [ i ] ; if ( ! number . is Empty ( ) ) { list . add ( Integer . value Of ( number ) ) ; } } Collections . sort ( list ) ; return list ; }",
    "label": 1
  },
  {
    "text_1": "tries to schedule a runnable on the underlying executor . rejected executions will be suppressed . this is useful for cases when the clients eventloop is shut down before the eventloop of the underlying connection .",
    "text_2": "private void try Schedule Action ( Runnable action ) { try { scheduler . submit ( action ) ; } catch ( Rejected Execution Exception e ) { } }",
    "label": 1
  },
  {
    "text_1": "closes the underlying file",
    "text_2": "public void close ( ) throws IO Exception { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } try { if ( input File ! = null ) input File . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } input File = null ; }",
    "label": 1
  },
  {
    "text_1": "updates the status about the service state ( and the status bar )",
    "text_2": "private void on Connection Status Changed ( int old Status , int status ) { if ( s Settings Mgr . show Status Icon ) { Notification Compat . Builder builder = new Notification Compat . Builder ( this ) ; builder . set When ( System . current Time Millis ( ) ) ; switch ( status ) { case Xmpp Manager . CONNECTED : builder . set Content Text ( get String ( R . string . main service connected , get Connection Status Action ( ) ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON GREEN ) ) ; break ; case Xmpp Manager . CONNECTING : builder . set Content Text ( get String ( R . string . main service connecting ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON ORANGE ) ) ; break ; case Xmpp Manager . DISCONNECTED : builder . set Content Text ( get String ( R . string . main service disconnected ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON RED ) ) ; break ; case Xmpp Manager . DISCONNECTING : builder . set Content Text ( get String ( R . string . main service dis connecting ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON ORANGE ) ) ; break ; case Xmpp Manager . WAITING TO CONNECT : case Xmpp Manager . WAITING FOR NETWORK : builder . set Content Text ( get String ( R . string . main service waiting to connect ) + STRING + get Connection Status Action ( ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON BLUE ) ) ; break ; default : return ; } builder . set Content Intent ( s Pending Intent Launch Application ) ; builder . set Content Title ( Tools . APP NAME ) ; start Foreground ( NOTIFICATION CONNECTION , builder . get Notification ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "create / reconnect fl ume rpc client",
    "text_2": "private void start Client ( ) { if ( fl ume Client ! = null & & ! fl ume Client . is Active ( ) ) { fl ume Client . close ( ) ; fl ume Client = null ; } if ( fl ume Client = = null ) { try { fl ume Client = Rpc Client Factory . get Default Instance ( fl ume Host Name , fl ume Port , max Span Batch Size ) ; } catch ( Fl ume Exception e ) { LOG . warn ( STRING + e . get Message ( ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "remove options that are matched by this processor .",
    "text_2": "public void remove Supported Options ( Set < String > unmatched Processor Options ) { unmatched Processor Options . remove All ( supported Option Names ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true iff all of the items on each set exist on the other set .",
    "text_2": "public static < T > boolean are Sets Identical ( final Set < T > set NUM , final Set < T > set NUM ) { if ( set NUM = = set NUM ) return BOOL ; if ( Collection Util . size ( set NUM ) ! = Collection Util . size ( set NUM ) ) return BOOL ; if ( Collection Util . is Empty ( set NUM ) ) return BOOL ; for ( final T t : set NUM ) if ( ! set NUM . contains ( t ) ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "encodes this transport configuration into a buffer . note that this is only used internally activemq arte mis .",
    "text_2": "public void encode ( final Active MQ Buffer buffer ) { buffer . write String ( name ) ; buffer . write String ( factory Class Name ) ; buffer . write Int ( params = = null ? NUM : params . size ( ) ) ; if ( params ! = null ) { encode Map ( buffer , params ) ; } if ( extra Props ! = null ) { encode Map ( buffer , extra Props ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates a new journal that omits redundant information . this replaces the current journal if it exists .",
    "text_2": "private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer ! = null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( journal File Tmp ) , Util . US ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION NUM ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor ! = null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } } finally { writer . close ( ) ; } if ( journal File . exists ( ) ) { rename To ( journal File , journal File Backup , BOOL ) ; } rename To ( journal File Tmp , journal File , BOOL ) ; journal File Backup . delete ( ) ; journal Writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( journal File , BOOL ) , Util . US ASCII ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convert from a calendar to the appropriate date type",
    "text_2": "protected Object to Type ( Calendar value ) { return value . get Time ( ) ; }",
    "label": 1
  },
  {
    "text_1": "use an xpath string to select a single node . xpath namespace prefixes are resolved from the namespac enode .",
    "text_2": "public Node select Single Node ( Node context Node , String str , Node namespace Node ) throws Transformer Exception { Node Iterator nl = select Node Iterator ( context Node , str , namespace Node ) ; return nl . next Node ( ) ; }",
    "label": 1
  },
  {
    "text_1": "formats the applied args into the template content . the supplied locale is used to format the text .",
    "text_2": "public String format With Locale ( Locale locale , String . . . args ) { return String . format ( locale , this . content , ( Object [ ] ) args ) ; }",
    "label": 1
  },
  {
    "text_1": "this method is invoked by the action owner component .",
    "text_2": "@ Override public void action Perform ( Component component ) { if ( ! is Enabled ( ) ) { return ; } if ( before Action Performed Handler ! = null ) { if ( ! before Action Performed Handler . before Action Performed ( ) ) return ; } Set selected = target . get Selected ( ) ; if ( ! selected . is Empty ( ) ) { if ( confirm ) { confirm And Remove ( selected ) ; } else { remove ( selected ) ; } } }",
    "label": 1
  },
  {
    "text_1": "makes a query request and returns the json string response",
    "text_2": "public static String JQ ( String request ) throws Exception { int query Start Pos = request . index Of ( STRING ) ; String query ; String path ; if ( - NUM = = query Start Pos ) { query = STRING ; path = request ; } else { query = request . substring ( query Start Pos + NUM ) ; path = request . substring ( NUM , query Start Pos ) ; } query = set Param ( query , STRING , STRING ) ; request = path + STRING + set Param ( query , STRING , STRING ) ; String response ; boolean failed = BOOL ; try { response = rest Test Harness . query ( request ) ; failed = BOOL ; } finally { if ( failed ) { log . error ( STRING + request ) ; } } return response ; }",
    "label": 1
  },
  {
    "text_1": "dump a long value into a stringbuilder .",
    "text_2": "private static String Builder dump ( String Builder l buffer , long value ) { for ( int j = NUM ; j < NUM ; j + + ) { l buffer . append ( CHARS [ ( int ) ( value > > SHIF TS [ j ] ) & NUM ] ) ; } return l buffer ; }",
    "label": 1
  },
  {
    "text_1": "this method will be invoked when the current page is scrolled , either as part of a programmatically initiated smooth scroll or a user initiated touch scroll . if you override this method you must call through to the superclass implementation ( e . g . super . onpage scrolled ( position , offset , offset pixels ) ) before onpage scrolled returns .",
    "text_2": "protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i + + ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int h grav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM ; switch ( h grav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left + = child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right + = child . get Measured Width ( ) ; break ; } child Left + = scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset ! = NUM ) { child . offset Left And Right ( child Offset ) ; } } } if ( m On Page Change Listener ! = null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener ! = null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer ! = null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i + + ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = BOOL ; }",
    "label": 1
  },
  {
    "text_1": "for given property name ' name ' , look for getname / is name method or ' name ' field . also look for setname method ( optional - could be readonly ) . failing method getters and field results in throwing nosuch property exception .",
    "text_2": "public Reflective Property ( Class < T > property Holder , Class < V > value Type , String name ) { super ( value Type , name ) ; char first Letter = Character . to Upper Case ( name . char At ( NUM ) ) ; String the Rest = name . substring ( NUM ) ; String capitalized Name = first Letter + the Rest ; String getter Name = PREFIX GET + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e2 ) { getter Name = PREFIX IS + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e3 ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e4 ) { try { m Field = property Holder . get Field ( name ) ; Class field Type = m Field . get Type ( ) ; if ( ! types Match ( value Type , field Type ) ) { throw new No Such Property Exception ( STRING + field Type + STRING + STRING + value Type + STRING ) ; } return ; } catch ( No Such Field Exception e5 ) { throw new No Such Property Exception ( STRING + STRING + name ) ; } } } } } Class getter Type = m Getter . get Return Type ( ) ; if ( ! types Match ( value Type , getter Type ) ) { throw new No Such Property Exception ( STRING + getter Type + STRING + STRING + value Type + STRING ) ; } String setter Name = PREFIX SET + capitalized Name ; try { m Setter = property Holder . get Declared Method ( setter Name , getter Type ) ; m Setter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception ignored ) { } }",
    "label": 1
  },
  {
    "text_1": "sorts an array of strings , returning a new array with the sorted items . the original array is left untouched .",
    "text_2": "public static String [ ] sort Copy ( String [ ] objects ) { int len = objects . length ; String [ ] copy = new String [ len ] ; System . arraycopy ( objects , NUM , copy , NUM , len ) ; sort ( copy ) ; return copy ; }",
    "label": 1
  },
  {
    "text_1": "returns the complex sine of this complex number .",
    "text_2": "public Complex sin ( ) { return new Complex ( Math . sin ( re ) * Math . cosh ( im ) , Math . cos ( re ) * Math . sinh ( im ) ) ; }",
    "label": 1
  },
  {
    "text_1": "handles edit charset alias request .",
    "text_2": "public void handle Tbl Charset Alias Href Action Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; G 11 N Charset Alias Edit View Bean vb = ( G 11 N Charset Alias Edit View Bean ) get View Bean ( G 11 N Charset Alias Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( ( String ) get Display Field Value ( STRING ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a child to this composite at the end of the list .",
    "text_2": "public void add Child ( Component child ) { components . add ( child ) ; child . set Parent ( this ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the header of a chunk . if chunk id is non - null , it ' s assumed to have already been read .",
    "text_2": "public boolean read Header ( Random Access File raf ) throws IO Exception { String Buffer id = new String Buffer ( NUM ) ; for ( int i = NUM ; i < NUM ; i + + ) { int ch = raf . read ( ) ; if ( ch < NUM ) { String hx = Integer . to Hex String ( ch ) ; if ( hx . length ( ) < NUM ) { hx = STRING + hx ; } return BOOL ; } id . append ( ( char ) ch ) ; } chunk ID = id . to String ( ) ; size = A iff Util . read UINT NUM ( raf ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "computes the normalized type value to ensure that the implementation can use object identity rather than equality .",
    "text_2": "private String normalize Type Value ( String type ) { if ( INSERT . equals ( type ) ) return INSERT ; if ( REMOVE . equals ( type ) ) return REMOVE ; return null ; }",
    "label": 1
  },
  {
    "text_1": "compiles the given path into the compiled form",
    "text_2": "private Object [ ] compile ( String path ) { List list = new Array List ( ) ; if ( path = = null ) { return list . to Array ( ) ; } String Tokenizer tok = new String Tokenizer ( path , STRING ) ; while ( tok . has More Tokens ( ) ) { String token = tok . next Token ( ) ; Op Enum op = Op Enum . get Instance ( token ) ; if ( op = = null ) { throw new Error ( STRING + path ) ; } list . add ( op ) ; if ( op = = Op Enum . RELATION ) { list . add ( tok . next Token ( ) ) ; } } return list . to Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the offset of the byte array which this buffer is based on , if there is one . the offset is the index of the array which corresponds to the zero position of the buffer .",
    "text_2": "@ Override public final int array Offset ( ) { return protected Array Offset ( ) ; }",
    "label": 1
  },
  {
    "text_1": "transfers node , if necessary , to sync queue after a cancelled wait . returns true if thread was cancelled before being signalled .",
    "text_2": "final boolean transfer After Cancelled Wait ( Node node ) { if ( compare And Set Wait Status ( node , Node . CONDITION , NUM ) ) { en q ( node ) ; return BOOL ; } while ( ! is On Sync Queue ( node ) ) Thread . yield ( ) ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "removes the provider at the specified 1 - based position .",
    "text_2": "public static synchronized void remove Provider ( int provider Number ) { Provider p = providers . remove ( provider Number - NUM ) ; providers Names . remove ( p . get Name ( ) ) ; set Need Refresh ( ) ; }",
    "label": 1
  },
  {
    "text_1": "shows an unknown error .",
    "text_2": "public static void show Unknown Error ( Context context , Throwable t , Dialog Interface . On Cancel Listener listener ) { show Error ( context , String . format ( context . get String ( R . string . af c p msg unknown error ) , t ) , listener ) ; }",
    "label": 1
  },
  {
    "text_1": "determine whether a feature has been seen enough times to learn a decoding model weight for it",
    "text_2": "boolean has Min Feature Count ( String feature ) { if ( min Feature Count = = NUM ) return BOOL ; Set < Integer > ids = clipped Feature Index . get ( feature ) ; if ( ids = = null ) return BOOL ; return ids . size ( ) > = min Feature Count ; }",
    "label": 1
  },
  {
    "text_1": "pops a type from the output frame stack .",
    "text_2": "private void pop ( final String desc ) { char c = desc . char At ( NUM ) ; if ( c = = STRING ) { pop ( ( Type . get Arguments And Return Sizes ( desc ) > > NUM ) - NUM ) ; } else if ( c = = STRING | | c = = STRING ) { pop ( NUM ) ; } else { pop ( NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "implements inputstream . read ( int ) in terms of inputstream . read ( byte [ ] , int , int ) . inputstream assumes that you implement inputstream . read ( int ) and provides default implementations of the others , but often the opposite is more efficient .",
    "text_2": "public static int read Single Byte ( Input Stream in ) throws IO Exception { byte [ ] buffer = new byte [ NUM ] ; int result = in . read ( buffer , NUM , NUM ) ; return ( result ! = - NUM ) ? buffer [ NUM ] & NUM : - NUM ; }",
    "label": 1
  },
  {
    "text_1": "asks the user for input .",
    "text_2": "public static Optional < String > create Input Dialog ( final Window owner , final String title , final String label ) { final Text Input Dialog dialog = new Text Input Dialog ( ) ; dialog . set Title ( title ) ; dialog . set Header Text ( null ) ; dialog . set Content Text ( label ) ; dialog . init Owner ( owner ) ; return dialog . show And Wait ( ) ; }",
    "label": 1
  },
  {
    "text_1": "generic method to remove a permission from a holder",
    "text_2": "private void remove ( String world , Permission Holder holder , String permission ) { try { if ( world ! = null & & ! world . equals ( STRING ) ) { holder . unset Permission ( permission , server , world ) ; } else { holder . unset Permission ( permission , server ) ; } } catch ( Object L acks Exception ignored ) { } save ( holder ) ; }",
    "label": 1
  },
  {
    "text_1": "load all existing plugins from the specified class loader .",
    "text_2": "private static void load Plugins From Class Loader ( Class Loader class Loader ) { Service Loader < GDS Factory Plugin > plugin Loader = Service Loader . load ( GDS Factory Plugin . class , class Loader ) ; for ( GDS Factory Plugin plugin : plugin Loader ) { register Plugin ( plugin ) ; } }",
    "label": 1
  },
  {
    "text_1": "this method checks that the given list of posts display within the vertical grid view . at the time of writing this , recycler view actions is really buggy with grid based recycler views - so this method traverses through the rows of the grid ( starting at left - to - right , then right - to - left and vice versa ) . this isn ' t ideal , but currently proper testing doesn ' t seem supported .",
    "text_2": "private void check Posts Display On Recycler View ( List < Post > posts To Check , int position ) { int column Count = NUM ; int size = posts To Check . size ( ) + position ; int pos = NUM ; for ( int i = position ; i < size ; i + + ) { check Item At Position ( i , posts To Check . get ( pos ) ) ; if ( ( ( i + NUM ) % column Count ) = = NUM ) { int next Row Start = i + column Count ; int next Row End = next Row Start - column Count + NUM ; for ( int n = next Row Start ; n > = next Row End ; n - - ) { check Item At Position ( n , posts To Check . get ( n - position ) ) ; } i = i + column Count ; } pos + + ; } }",
    "label": 1
  },
  {
    "text_1": "writes an xml comment with the data enclosed . nothing is done cos wb xml does not use comments .",
    "text_2": "@ Override public void write Comment ( String data ) throws XML Stream Exception { log . log ( Level . FINE , STRING , data ) ; }",
    "label": 1
  },
  {
    "text_1": "create an entry in the directory",
    "text_2": "public void create ( SSO Token token , String dn , Map attrs ) throws SMS Exception , SSO Exception { create ( token . get Principal ( ) , dn , attrs ) ; object Changed ( dn , ADD ) ; }",
    "label": 1
  },
  {
    "text_1": "this adds a divider at the bottom of this layout . used to separate fields in lists .",
    "text_2": "public void add Divider ( Image View v ) { Relative Layout . Layout Params divider Params = new Relative Layout . Layout Params ( Layout Params . FILL PARENT , Layout Params . WRAP CONTENT ) ; if ( m Image View ! = null ) { divider Params . add Rule ( Relative Layout . BELOW , m Image View . get Id ( ) ) ; } else if ( m Missing Image ! = null ) { divider Params . add Rule ( Relative Layout . BELOW , m Missing Image . get Id ( ) ) ; } else if ( m Video Button ! = null ) { divider Params . add Rule ( Relative Layout . BELOW , m Video Button . get Id ( ) ) ; } else if ( m Audio Button ! = null ) { divider Params . add Rule ( Relative Layout . BELOW , m Audio Button . get Id ( ) ) ; } else if ( m View Text ! = null ) { divider Params . add Rule ( Relative Layout . BELOW , m View Text . get Id ( ) ) ; } else { Log . e ( t , STRING ) ; return ; } add View ( v , divider Params ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the domain component of an email address is valid .",
    "text_2": "protected boolean is Valid Domain ( String domain ) { Matcher ip Domain Matcher = IP DOMAIN PATTERN . matcher ( domain ) ; if ( ip Domain Matcher . matches ( ) ) { Inet Address Validator inet Address Validator = Inet Address Validator . get Instance ( ) ; return inet Address Validator . is Valid ( ip Domain Matcher . group ( NUM ) ) ; } Domain Validator domain Validator = Domain Validator . get Instance ( allow Local ) ; return domain Validator . is Valid ( domain ) | | domain Validator . is Valid Tld ( domain ) ; }",
    "label": 1
  },
  {
    "text_1": "computes the index of the next character in the given string that is not a quote , starting from given index and going either forward or backward",
    "text_2": "private static int next Non Quote Index ( String trimmed , int i , boolean forward ) { while ( trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING | | trimmed . char At ( i ) = = STRING ) { if ( forward ) i + + ; else i - - ; } return i ; }",
    "label": 1
  },
  {
    "text_1": "reads the next ruleid from the definition , skipping over any leading spaces .",
    "text_2": "static Integer read Rule ID ( final Substring Reader reader ) throws Decode Exception { int length = NUM ; reader . skip Whitespaces ( ) ; reader . mark ( ) ; try { while ( reader . read ( ) ! = STRING ) { length + + ; } if ( length = = NUM ) { throw Decode Exception . error ( ERR ATTR SYNTAX RULE ID NO VALUE NUM . get ( reader . pos ( ) - NUM ) ) ; } reader . reset ( ) ; final String rule ID = reader . read ( length ) ; try { return Integer . value Of ( rule ID ) ; } catch ( final Number Format Exception e ) { throw Decode Exception . error ( ERR ATTR SYNTAX RULE ID INVALID NUM . get ( rule ID ) ) ; } } catch ( final String Index Out Of Bounds Exception e ) { throw Decode Exception . error ( ERR ATTR SYNTAX TRUN CATED VALUE NUM . get ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "stores double value into object field .",
    "text_2": "public static void put Double Field ( Object obj , long field Off , double val ) { UNSAFE . put Double ( obj , field Off , val ) ; }",
    "label": 1
  },
  {
    "text_1": "dump map value into string .",
    "text_2": "public static String dump ( Map < ? , ? > map ) { String Builder string Builder = new String Builder ( ) ; for ( Map . Entry < ? , ? > entry : map . entry Set ( ) ) { string Builder . append ( entry . get Key ( ) ) ; string Builder . append ( STRING ) ; string Builder . append ( entry . get Value ( ) ) ; } return string Builder . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the given component to be associated with this element . this is used internally to apply css styling .",
    "text_2": "void add Associated Component At ( int index , Component cmp ) { if ( comps = = null ) { comps = new Vector ( ) ; } comps . insert Element At ( cmp , index ) ; }",
    "label": 1
  },
  {
    "text_1": "enter the symbols found in a list of parse trees . as a side - effect , this puts elements on the \" todo \" list . also stores a list of all top level classes in root classes .",
    "text_2": "public List < JC Compilation Unit > enter Trees ( List < JC Compilation Unit > roots ) { if ( ! task Listener . is Empty ( ) ) { for ( JC Compilation Unit unit : roots ) { Task Event e = new Task Event ( Task Event . Kind . ENTER , unit ) ; task Listener . started ( e ) ; } } enter . main ( roots ) ; if ( ! task Listener . is Empty ( ) ) { for ( JC Compilation Unit unit : roots ) { Task Event e = new Task Event ( Task Event . Kind . ENTER , unit ) ; task Listener . finished ( e ) ; } } if ( need Root Classes | | source Output | | stub Output ) { List Buffer < JC Class Decl > c defs = new List Buffer < > ( ) ; for ( JC Compilation Unit unit : roots ) { for ( List < JC Tree > defs = unit . defs ; defs . non Empty ( ) ; defs = defs . tail ) { if ( defs . head instanceof JC Class Decl ) c defs . append ( ( JC Class Decl ) defs . head ) ; } } root Classes = c defs . to List ( ) ; } for ( JC Compilation Unit unit : roots ) { input Files . add ( unit . sourcefile ) ; } return roots ; }",
    "label": 1
  },
  {
    "text_1": "performs db scan cluster analysis .",
    "text_2": "@ Override public List < Cluster < T > > cluster ( final Collection < T > points ) throws Null Argument Exception { Math Utils . check Not Null ( points ) ; final List < Cluster < T > > clusters = new Array List < Cluster < T > > ( ) ; final Map < Clust erable , Point Status > visited = new Hash Map < Clust erable , Point Status > ( ) ; for ( final T point : points ) { if ( visited . get ( point ) ! = null ) { continue ; } final List < T > neighbors = get Neighbors ( point , points ) ; if ( neighbors . size ( ) > = min Pts ) { final Cluster < T > cluster = new Cluster < T > ( ) ; clusters . add ( expand Cluster ( cluster , point , neighbors , points , visited ) ) ; } else { visited . put ( point , Point Status . NOISE ) ; } } return clusters ; }",
    "label": 1
  },
  {
    "text_1": "returns all the injected classes and them super interfaces .",
    "text_2": "private static Set < Type Element > find All Members Injec tors Recursively ( Collection < Type Element > members Injec tors ) { Set < Type Element > result = new Hash Set < > ( ) ; for ( Type Element element : members Injec tors ) { result . add All ( find All Members Injec tors Recursively ( element ) ) ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "parses payload argument from command line and returns the json .",
    "text_2": "protected String parse Payload ( String payload ) { String json = null ; if ( payload ! = null ) { try { json = ( payload . index Of ( STRING ) = = - NUM ) ? new String ( Files . read All Bytes ( Paths . get ( payload ) ) ) : payload ; } catch ( IO Exception e ) { log . fatal ( STRING + payload , e ) ; System . exit ( NUM ) ; } } return json ; }",
    "label": 1
  },
  {
    "text_1": "detached a persistent disk to specified vm .",
    "text_2": "public void detach Disk Async ( final String vm Id , Vm Disk Operation vm Disk Operation , final Future Callback < Task > response Callback ) throws IO Exception { String path = String . format ( STRING , get Base Path ( ) , vm Id ) ; create Object Async ( path , serialize Object As Json ( vm Disk Operation ) , response Callback ) ; }",
    "label": 1
  },
  {
    "text_1": "decoder identify has matched one or more specific types",
    "text_2": "void update For Decoder Type ID ( List < Decoder File > p List ) { decoder Box . set Model ( Decoder Index File . j Combo Box Model From List ( p List ) ) ; decoder Box . insert Item At ( STRING , NUM ) ; decoder Box . set Selected Index ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "renames the value of a nominal ( or string ) attribute value . this change only affects this dataset .",
    "text_2": "public void rename Attribute Value ( Attribute att , String val , String name ) { int v = att . index Of Value ( val ) ; if ( v = = - NUM ) { throw new Illegal Argument Exception ( val + STRING ) ; } rename Attribute Value ( att . index ( ) , v , name ) ; }",
    "label": 1
  },
  {
    "text_1": "deserialize the state of the object .",
    "text_2": "private void read Object ( final java . io . Object Input Stream in ) throws IO Exception , Class Not Found Exception { in equality Symbol = ( String ) in . read Object ( ) ; time Stamp = in . read Long ( ) ; }",
    "label": 1
  },
  {
    "text_1": "restore the properties associated with this preference on boot",
    "text_2": "public static void restore ( final Context context ) { Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; if ( Long Term Or bits . is Supported ( ) & & prefs . get Boolean ( KEY LOCATION TOGGLE , BOOL ) ) { save Download Data Wifi Only Pref ( context ) ; Alarm Manager am = ( Alarm Manager ) context . get System Service ( Context . ALARM SERVICE ) ; Intent intent = new Intent ( context , Lto Service . class ) ; Pending Intent pi = Pending Intent . get Service ( context , NUM , intent , Pending Intent . FLAG UPDATE CURRENT | Pending Intent . FLAG ONE SHOT ) ; long next Lto Download = System . current Time Millis ( ) + ( NUM * NUM * NUM ) ; am . set ( Alarm Manager . RTC , next Lto Download , pi ) ; } }",
    "label": 1
  },
  {
    "text_1": "insert element into collection . should the count of attempted slots reach the array size , declare that the element cannot be added ( either because of a poor hash function or because the array is full ) . if element already exists within collection , return its position . that is , no duplicates are allowed , yet we silently ignore requests to repeatedly add the same element into the collection .",
    "text_2": "@ Override public int insert ( String elem ) { int first Index = ( int ) ( elem . char At ( NUM ) - STRING ) ; int last Index = ( int ) ( elem . char At ( elem . length ( ) - NUM ) - STRING ) ; storage [ first Index * NUM + last Index ] = elem ; return NUM ; }",
    "label": 1
  },
  {
    "text_1": "removes the given connection record from the list of active connections associated with the object having the given identifier .",
    "text_2": "public void remove ( String identifier , Active Connection Record record ) { synchronized ( records ) { Set < Active Connection Record > connections = records . get ( identifier ) ; assert ( connections ! = null ) ; connections . remove ( record ) ; if ( connections . is Empty ( ) ) records . remove ( identifier ) ; } }",
    "label": 1
  },
  {
    "text_1": "are we running from a web start instance ?",
    "text_2": "public static boolean is Running Java Web Start ( ) { boolean has JNLP = BOOL ; try { Class . for Name ( STRING ) ; has JNLP = BOOL ; } catch ( Class Not Found Exception ex ) { has JNLP = BOOL ; } return has JNLP ; }",
    "label": 1
  },
  {
    "text_1": "returns a clone of the object .",
    "text_2": "protected Object clone Object ( Object obj ) { if ( obj = = null ) { return null ; } if ( obj instanceof String | | obj instanceof Boolean | | obj instanceof Byte | | obj instanceof Short | | obj instanceof Character | | obj instanceof Integer | | obj instanceof Long | | obj instanceof Float | | obj instanceof Double ) { return obj ; } if ( obj instanceof byte [ ] ) { byte [ ] body = ( byte [ ] ) obj ; byte [ ] data = new byte [ body . length ] ; System . arraycopy ( body , NUM , data , NUM , body . length ) ; return data ; } return Serialization Helper . deep Clone ( obj ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the value of multiplying the two numbers .",
    "text_2": "public static Number mul ( Number a , Number b ) { if ( is Floating Point ( a ) | | is Floating Point ( b ) ) { return a . double Value ( ) * b . double Value ( ) ; } else { return a . long Value ( ) * b . long Value ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "check for equality of two expression matcher objects .",
    "text_2": "@ Override public boolean equals ( final Object other ) { if ( this = = other ) { return BOOL ; } else if ( other = = null ) { return BOOL ; } else if ( other instanceof Expression Matcher ) { final Expression Matcher o = ( Expression Matcher ) other ; if ( type Matching ! = o . type Matching ) { return BOOL ; } else if ( exact Matching ! = o . exact Matching ) { return BOOL ; } else if ( similar Matching ! = o . similar Matching ) { return BOOL ; } else if ( case Insensitive ! = o . case Insensitive ) { return BOOL ; } else { return ( j oker Matching = = o . j oker Matching ) ; } } else { return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "turns a single method parameter into a string . to keep the functionality safe we truncate over ly long strings and ignore any exceptions .",
    "text_2": "protected String to String ( Object parameter ) { if ( parameter = = null ) { return NULL STR ; } try { String result = Misc . get As String ( parameter ) ; if ( result . length ( ) > DEFAULT ARG STRING MAX LENGTH ) { result = result . substring ( NUM , DEFAULT ARG STRING MAX LENGTH ) + DEFAULT MAX STRING ENDING ; } return result ; } catch ( Throwable e ) { return UNKNOWN ; } }",
    "label": 1
  },
  {
    "text_1": "return the previous url in the list ( relative to the current position ) and moves the index back to make this the now current position .",
    "text_2": "public String move Back ( ) { Check . is True ( current Index > NUM , STRING ) ; current Index - - ; return history . get ( current Index ) ; }",
    "label": 1
  },
  {
    "text_1": "this method works according to the specification of implemented class .",
    "text_2": "@ Override public void close ( ) throws IO Exception { if ( logger ! = null ) { logger . println ( STRING + socket was closed ) ; } if ( ! socket was closed ) { if ( handshake started ) { alert Protocol . alert ( Alert Protocol . WARNING , Alert Protocol . CLOSE NOTIFY ) ; try { output . write ( alert Protocol . wrap ( ) ) ; } catch ( IO Exception ex ) { } alert Protocol . set Processed ( ) ; } shutdown ( ) ; close Transport Layer ( ) ; socket was closed = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "parses the docu em nt element for this object .",
    "text_2": "private void parse Element ( Element element ) throws SAML NUM Exception { Assertion Factory assertion Factory = Assertion Factory . get Instance ( ) ; Protocol Factory proto Factory = Protocol Factory . get Instance ( ) ; request Id = element . get Attribute ( SAML NUM Constants . ID ) ; validate ID ( request Id ) ; version = element . get Attribute ( SAML NUM Constants . VERSION ) ; validate Version ( version ) ; String issue Instant Str = element . get Attribute ( SAML NUM Constants . ISSUE INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute ( SAML NUM Constants . DESTINATION ) ; consent = element . get Attribute ( SAML NUM Constants . CON SENT ) ; String not On Or After Str = element . get Attribute ( SAML NUM Constants . NOT ON OR AFTER ) ; validate Not On Or After Str ( not On Or After Str ) ; reason = element . get Attribute ( SAML NUM Constants . REASON ) ; String session Index Str = null ; Node List n List = element . get Child Nodes ( ) ; if ( ( n List ! = null ) & & ( n List . get Length ( ) > NUM ) ) { for ( int i = NUM ; i < n List . get Length ( ) ; i + + ) { Node child Node = n List . item ( i ) ; String c Name = child Node . get Local Name ( ) ; if ( c Name ! = null ) { if ( c Name . equals ( SAML NUM Constants . ISSUER ) ) { name ID = assertion Factory . create Issuer ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML NUM Constants . SIGNATURE ) ) { signature String = XML Utils . print ( ( Element ) child Node ) ; is Signed = BOOL ; } else if ( c Name . equals ( SAML NUM Constants . EXTENSIONS ) ) { extensions = proto Factory . create Extensions ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML NUM Constants . BASE ID ) ) { base Id = assertion Factory . create Base ID ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML NUM Constants . NAMEID ) ) { name Id = assertion Factory . create Name ID ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML NUM Constants . ENCRYP TE DID ) ) { encrypted Id = assertion Factory . create Encrypted ID ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML NUM Constants . SESSION INDEX ) ) { if ( ( session Index List = = null ) | | ( session Index List . is Empty ( ) ) ) { session Index List = new Array List ( ) ; } session Index Str = XML Utils . get Element String ( ( Element ) child Node ) ; session Index List . add ( session Index Str ) ; } } } validate Base I D or Name I D or Encrypted ID ( ) ; if ( ( session Index List ! = null ) & & ( ! session Index List . is Empty ( ) ) ) { session Index List = Collections . unmodifiable List ( session Index List ) ; } } }",
    "label": 1
  },
  {
    "text_1": "initializes a new slice with start and end value .",
    "text_2": "public Slice ( double start , double end , boolean visible ) { this . start = start ; this . end = end ; this . visible = visible ; }",
    "label": 1
  },
  {
    "text_1": "construct a user given an id , name , and email .",
    "text_2": "public User ( String id , String name , String email ) { this . id = id ; this . email = email ; this . name = name ; }",
    "label": 1
  },
  {
    "text_1": "determine property over a list of dock constraint objects",
    "text_2": "public static boolean can Tab ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Tab ( ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "create a node set dtm , and copy the members of the given dtm iterator into it .",
    "text_2": "public Node Set DTM ( Node Iterator iterator , X Path Context xctxt ) { super ( ) ; Node node ; m manager = xctxt . get DTM Manager ( ) ; while ( null ! = ( node = iterator . next Node ( ) ) ) { int handle = xctxt . get DTM Handle From Node ( node ) ; add Node In Doc Order ( handle , xctxt ) ; } }",
    "label": 1
  },
  {
    "text_1": "write an end of line to out .",
    "text_2": "public static void write Ln ( final Output Stream out ) throws IO Exception { out . write ( LS BYTES ) ; }",
    "label": 1
  },
  {
    "text_1": "readable if the jar is readable and the path refers to a file .",
    "text_2": "public boolean can Read ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry ! = null & & ! entry . is Directory ( ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; return BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "create a new graphic component . start and limit are indices into char l to v and levels . char sl to v and levels may be adopted .",
    "text_2": "public Graphic Component ( Graphic Attribute graphic , Decoration decorator , int [ ] chars Lto V , byte [ ] levels , int start , int limit , Affine Transform base Tx ) { if ( limit < = start ) { throw new Illegal Argument Exception ( STRING ) ; } this . graphic = graphic ; this . graphic Advance = graphic . get Advance ( ) ; this . decorator = decorator ; this . cm = create Core Metrics ( graphic ) ; this . base Tx = base Tx ; init Local Ordering ( chars Lto V , levels , start , limit ) ; }",
    "label": 1
  },
  {
    "text_1": "runs the test case .",
    "text_2": "public void test Create Document Type NUM ( ) throws Throwable { Document doc ; DOM Implementation dom Impl ; Document Type new Doc Type ; Document owner Document ; String qualified Name = STRING ; String public Id ; String system Id ; List < String > public Ids = new Array List < String > ( ) ; public Ids . add ( STRING ) ; public Ids . add ( STRING ) ; List < String > system Ids = new Array List < String > ( ) ; system Ids . add ( STRING ) ; system Ids . add ( STRING ) ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; for ( int index N NUM 005 D = NUM ; index N NUM 005 D < public Ids . size ( ) ; index N NUM 005 D + + ) { public Id = ( String ) public Ids . get ( index N NUM 005 D ) ; for ( int index N NUM 006 NUM = NUM ; index N NUM 006 NUM < system Ids . size ( ) ; index N NUM 006 NUM + + ) { system Id = ( String ) system Ids . get ( index N NUM 006 NUM ) ; new Doc Type = dom Impl . create Document Type ( qualified Name , public Id , system Id ) ; assert Not Null ( STRING , new Doc Type ) ; owner Document = new Doc Type . get Owner Document ( ) ; assert Null ( STRING , owner Document ) ; } } }",
    "label": 1
  },
  {
    "text_1": "create a new generator object with properties loaded from a file . if the file does not exist or any other exception occurs during the reading operation the default properties are used .",
    "text_2": "public Generator ( String prop File ) { try { Buffered Input Stream bi = null ; try { bi = new Buffered Input Stream ( new File Input Stream ( prop File ) ) ; props . load ( bi ) ; } finally { if ( bi ! = null ) { bi . close ( ) ; } } } catch ( Exception e ) { set Default Props ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds item to the set of values associated with the key ( null items are not added )",
    "text_2": "public boolean add ( K key , V item ) { Set < V > values = map . get ( key ) ; if ( values = = null ) { values = ( sorted ? new Tree Set < V > ( ) : new Hash Set < V > ( ) ) ; map . put ( key , values ) ; } if ( item = = null ) return BOOL ; return values . add ( item ) ; }",
    "label": 1
  },
  {
    "text_1": "delete a value stored in the project ' s datastore .",
    "text_2": "protected void delete Session Variables ( String session Id , String . . . var Names ) { if ( session Id . equals ( STRING ) ) { return ; } Key key = key Factory . new Key ( session Id ) ; Transaction transaction = datastore . new Transaction ( ) ; try { Entity state Entity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( state Entity ) ; String Builder del Names = new String Builder ( ) ; for ( String var Name : var Names ) { del Names . append ( var Name + STRING ) ; builder = builder . remove ( var Name ) ; } datastore . update ( builder . build ( ) ) ; } catch ( Null Pointer Exception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "finds the index of the given tab id .",
    "text_2": "private int index Of ( int tab Id ) { return m Tab Id List . index Of ( tab Id ) ; }",
    "label": 1
  },
  {
    "text_1": "first loads properties file from class path after that from current folder . so properties file in current folder is always overrides properties in classpath .",
    "text_2": "private void init Properties ( String file Properties Name ) { read From Class Path ( file Properties Name ) ; Path cur Dir Path = get File In Current Dir ( file Properties Name ) ; if ( Files . exists ( cur Dir Path ) ) { try ( Input Stream cur Folder = Files . new Input Stream ( cur Dir Path ) ) { if ( cur Folder ! = null ) { load ( cur Folder ) ; } } catch ( Exception e ) { throw new Runtime Exception ( STRING + file Properties Name , e ) ; } } }",
    "label": 1
  },
  {
    "text_1": "parses the generic signature of a class and creates the data structure representing the signature .",
    "text_2": "public void parse For Class ( Generic Declaration generic Decl , String signature ) { set Input ( generic Decl , signature ) ; if ( ! eof ) { parse Class Signature ( ) ; } else { if ( generic Decl instanceof Class ) { Class c = ( Class ) generic Decl ; this . formal Type Parameters = Empty Array . TYPE VARIABLE ; this . superclass Type = c . get Superclass ( ) ; Class < ? > [ ] interfaces = c . get Interfaces ( ) ; if ( interfaces . length = = NUM ) { this . interface Types = List Of Types . EMPTY ; } else { this . interface Types = new List Of Types ( interfaces ) ; } } else { this . formal Type Parameters = Empty Array . TYPE VARIABLE ; this . superclass Type = Object . class ; this . interface Types = List Of Types . EMPTY ; } } }",
    "label": 1
  },
  {
    "text_1": "a null - safe computation of the specified object ' s hash value . if the object reference is null , then this method returns 0 and will be consistent with the equal sig no ren ull equality comparison .",
    "text_2": "public static int hash Code ( final Object obj ) { return ( obj = = null ? NUM : obj . hash Code ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "disconnects the specified connection from the broker .",
    "text_2": "public void disconnect From Broker ( final Mqtt Async Connection connection ) { try { connection . disconnect ( new Mqtt Disconnection Result Handler ( ) ) ; } catch ( Spy Exception e ) { Platform . run Later ( new Mqtt Event Handler ( new Mqtt Disconnection Attempt Failure Event ( connection , e ) ) ) ; logger . error ( e . get Message ( ) , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "processes all the characters in a line .",
    "text_2": "protected String Builder process Line ( String next Element ) { String Builder sb = new String Builder ( INITIAL STRING SIZE ) ; for ( int j = NUM ; j < next Element . length ( ) ; j + + ) { char next Char = next Element . char At ( j ) ; process Character ( sb , next Char ) ; } return sb ; }",
    "label": 1
  },
  {
    "text_1": "adds a new label to the key binds list . this should be used in conjunction with adding a button in a 1 : 1 ratio . the new label will be added below the existing ones .",
    "text_2": "private J Label add Key bind Label ( J Panel panel , String label Text ) { Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . anchor = Grid Bag Constraints . WEST ; gbc . insets = new Insets ( NUM , NUM , NUM , NUM ) ; gbc . gridx = NUM ; gbc . gridy = key bind Label Grid Y Counter + + ; gbc . weightx = NUM ; J Label j lbl = new J Label ( label Text ) ; panel . add ( j lbl , gbc ) ; return j lbl ; }",
    "label": 1
  },
  {
    "text_1": "checks to see if the element key exists .",
    "text_2": "public boolean contains Key ( final Object e Key ) { return element Order . contains ( e Key ) ; }",
    "label": 1
  },
  {
    "text_1": "blur and transpose a block of argb pixels .",
    "text_2": "public static void convolve And Transpose ( Kernel kernel , int [ ] in Pixels , int [ ] out Pixels , int width , int height , boolean alpha , boolean pre multiply , boolean un pre multiply , int edge Action ) { float [ ] matrix = kernel . get Kernel Data ( null ) ; int cols = kernel . get Width ( ) ; int cols NUM = cols / NUM ; for ( int y = NUM ; y < height ; y + + ) { int index = y ; int io ffset = y * width ; for ( int x = NUM ; x < width ; x + + ) { float r = NUM , g = NUM , b = NUM , a = NUM ; int mo ffset = cols NUM ; for ( int col = - cols NUM ; col < = cols NUM ; col + + ) { float f = matrix [ mo ffset + col ] ; if ( f ! = NUM ) { int ix = x + col ; if ( ix < NUM ) { if ( edge Action = = CLAMP EDGES ) ix = NUM ; else if ( edge Action = = WRAP EDGES ) ix = ( x + width ) % width ; } else if ( ix > = width ) { if ( edge Action = = CLAMP EDGES ) ix = width - NUM ; else if ( edge Action = = WRAP EDGES ) ix = ( x + width ) % width ; } int rgb = in Pixels [ io ffset + ix ] ; int pa = ( rgb > > NUM ) & NUM ; int pr = ( rgb > > NUM ) & NUM ; int pg = ( rgb > > NUM ) & NUM ; int pb = rgb & NUM ; if ( pre multiply ) { float a NUM 55 = pa * ( NUM / NUM ) ; pr * = a NUM 55 ; pg * = a NUM 55 ; pb * = a NUM 55 ; } a + = f * pa ; r + = f * pr ; g + = f * pg ; b + = f * pb ; } } if ( un pre multiply & & a ! = NUM & & a ! = NUM ) { float f = NUM / a ; r * = f ; g * = f ; b * = f ; } int ia = alpha ? Pixel Utils . clamp ( ( int ) ( a + NUM ) ) : NUM ; int ir = Pixel Utils . clamp ( ( int ) ( r + NUM ) ) ; int ig = Pixel Utils . clamp ( ( int ) ( g + NUM ) ) ; int ib = Pixel Utils . clamp ( ( int ) ( b + NUM ) ) ; out Pixels [ index ] = ( ia < < NUM ) | ( ir < < NUM ) | ( ig < < NUM ) | ib ; index + = height ; } } }",
    "label": 1
  },
  {
    "text_1": "prints a string formated as in string . format ( ) .",
    "text_2": "public static void format ( String format , Object . . . args ) { if ( ! is Disabled ( ) ) { print ( String . format ( format , args ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a binary representation of this attribute .",
    "text_2": "public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; if ( ! is Type Valid ( type ) ) throw new Illegal State Exception ( ( ( int ) type ) + STRING ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) ] ; bin Value [ NUM ] = ( byte ) ( type > > NUM ) ; bin Value [ NUM ] = ( byte ) ( type & NUM ) ; bin Value [ NUM ] = ( byte ) ( get Data Length ( ) > > NUM ) ; bin Value [ NUM ] = ( byte ) ( get Data Length ( ) & NUM ) ; bin Value [ NUM ] = NUM ; bin Value [ NUM ] = get Family ( ) ; bin Value [ NUM ] = ( byte ) ( get Port ( ) > > NUM ) ; bin Value [ NUM ] = ( byte ) ( get Port ( ) & NUM ) ; if ( get Family ( ) = = ADDRESS FAMILY IPV NUM ) { System . arraycopy ( get Address Bytes ( ) , NUM , bin Value , NUM , NUM ) ; } else { System . arraycopy ( get Address Bytes ( ) , NUM , bin Value , NUM , NUM ) ; } return bin Value ; }",
    "label": 1
  },
  {
    "text_1": "if a search has been executed , appends a url - encoded string representation of the search criteria to the given stringbuilder , as a get parameter . the stringbuilder ' s contents are modified .",
    "text_2": "protected String Builder append Search String Param If Necessary ( String Builder sb ) { String search String Param = get Encoded Search String Param ( ) ; if ( search String Param ! = null ) { if ( sb . index Of ( STRING ) = = - NUM ) { sb . append ( STRING ) ; } else { sb . append ( STRING ) ; } sb . append ( search String Param ) ; } return sb ; }",
    "label": 1
  },
  {
    "text_1": "checks if the to search string contains the expression .",
    "text_2": "private boolean contains Expression ( String to Search , String expression ) { if ( to Search = = null ) { return BOOL ; } return to Search . equals ( expression ) | | to Search . index Of ( expression ) > = NUM ; }",
    "label": 1
  },
  {
    "text_1": "adds a listener which will be notified when the popup is opened .",
    "text_2": "public void add Popup Listener ( final Popup Listener listener ) { if ( ! popup Listeners . contains ( listener ) ) { popup Listeners . add ( listener ) ; } }",
    "label": 1
  },
  {
    "text_1": "starts a new query not related to a previous class query .",
    "text_2": "public < T extends Data Object > Joiner join ( Class < T > clazz , String alias ) { if ( ! j Classes . is Empty ( ) ) { throw new Joiner Exception ( STRING ) ; } J Class jc = new J Class ( clazz , alias , j Classes . size ( ) ) ; j Classes . add ( jc ) ; last J Class = jc ; alias Map . put ( alias , jc ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "finds the related rpc components for a given method : declaring type & peer type .",
    "text_2": "protected static Rpc Pair resolve Rpc Pair ( AST Node node , Peer Type Resolver peer Resolver ) { Method Declaration method Decl = AST Resolving . find Parent Method Declaration ( node ) ; Type Declaration type Decl = ( Type Declaration ) AST Resolving . find Ancestor ( node , AST Node . TYPE DECLARATION ) ; assert ( type Decl ! = null ) ; I Type dst Type = peer Resolver . get Peer Type ( type Decl ) ; if ( dst Type = = null ) { return null ; } Compilation Unit ast Root = AST Resolving . create Quick Fix AST ( dst Type . get Compilation Unit ( ) , null ) ; Type Declaration dst Type Decl = Java AST Utils . find Type Declaration ( ast Root , dst Type . get Fully Qualified Name ( STRING ) ) ; if ( dst Type Decl = = null ) { return null ; } return new Rpc Pair ( type Decl , method Decl , dst Type Decl ) ; }",
    "label": 1
  },
  {
    "text_1": "add the certificates and crls contained in the given certstore to the pool that will be included in the encoded signature block . note : this assumes the certstore will support null in the get methods .",
    "text_2": "public void add Certificates And CR Ls ( Cert Store cert Store ) throws Cert Store Exception , CMS Exception { certs . add All ( CMS Utils . get Certificates From Store ( cert Store ) ) ; crls . add All ( CMS Utils . get CR Ls From Store ( cert Store ) ) ; }",
    "label": 1
  },
  {
    "text_1": "see the general contract of the read fully method of datainput . bytes for this operation are read from the contained input stream .",
    "text_2": "public final void read Fully ( byte [ ] b , int off , int len ) throws java . io . IO Exception { if ( len < NUM ) { throw new Index Out Of Bounds Exception ( ) ; } int n = NUM ; while ( n < len ) { int count = read ( b , off + n , len - n ) ; if ( count < NUM ) { throw new EOF Exception ( ) ; } n + = count ; } }",
    "label": 1
  },
  {
    "text_1": "initialize the distributed leaf calculation reset i , j and compute ot s seed with seed 0",
    "text_2": "void init Leaf Calc ( byte [ ] seed NUM ) { this . i = NUM ; this . j = NUM ; byte [ ] dummy = new byte [ mdsize ] ; System . arraycopy ( seed NUM , NUM , dummy , NUM , seed . length ) ; this . seed = gmss Random . next Seed ( dummy ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if given permissions is registered in this manager .",
    "text_2": "boolean is Registered Permission ( Permission permission ) ;",
    "label": 1
  },
  {
    "text_1": "makes this object immutable .",
    "text_2": "public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }",
    "label": 1
  },
  {
    "text_1": "provides an opportunity to pause before executing the protocol .",
    "text_2": "protected boolean wait Before Execution ( ) throws Interrupted Exception { return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "updates the utility of each individual .",
    "text_2": "private void update Utility ( ) { for ( Individual individual : population ) { double old Fitness = individual . get Fitness ( ) ; double new Fitness = fitness ( individual . get Solution ( ) , ideal Point ) ; double relative Decrease = old Fitness - new Fitness ; if ( relative Decrease > NUM ) { individual . set Utility ( NUM ) ; } else { double utility = Math . min ( NUM , NUM * ( NUM + delta / NUM ) * individual . get Utility ( ) ) ; individual . set Utility ( utility ) ; } individual . set Fitness ( new Fitness ) ; } }",
    "label": 1
  },
  {
    "text_1": "updates the view to reflect changes in the period object",
    "text_2": "private void update Period ( ) { for ( int i = NUM ; i < m Conversion . size ( ) ; i + + ) { int date Type = m Conversion . key At ( i ) ; Time Period Slider slider = m Time Period Sliders . get ( date Type ) ; slider . set Value ( m Period . get ( m Conversion . value At ( i ) ) ) ; } m Time . set Text ( get Formatted Period ( ) ) ; m Duration = m Period . to Standard Duration ( ) ; do Validation ( ) ; }",
    "label": 1
  },
  {
    "text_1": "recupera de la base de datos el identificador y el nombre del usuario .",
    "text_2": "public Integer load Id Name Values ( Db Output Statement statement , Integer idx ) throws Exception { int index = idx . int Value ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING ) ; id = statement . get Long Integer ( index + + ) ; name = statement . get Short Text ( index + + ) ; return new Integer ( index ) ; }",
    "label": 1
  },
  {
    "text_1": "this function defines a protocol for handling substitution names that are \" special , \" i . e . , that have some property beyond just being substitutions . at the rule base db re ak iterator level , we have one special substitution name , \" < ignore > \" . subclasses can override this function to add more . any special processing that has to go on beyond that which is done by the normal substitution - processing code is done here .",
    "text_2": "protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) = = STRING ) { error ( STRING , start Pos , description ) ; } ignore Chars = Char Set . parse String ( replace With ) ; } }",
    "label": 1
  },
  {
    "text_1": "do a quick line - level diff on both strings , then re diff the parts for greater accuracy . this speedup can produce non - minimal diffs .",
    "text_2": "private Linked List < Diff > diff line Mode ( String text NUM , String text NUM , long deadline ) { Lines To Chars Result b = diff lines To Chars ( text NUM , text NUM ) ; text NUM = b . chars NUM ; text NUM = b . chars NUM ; List < String > line array = b . line Array ; Linked List < Diff > diffs = diff main ( text NUM , text NUM , BOOL , deadline ) ; diff chars To Lines ( diffs , line array ) ; diff cleanup Semantic ( diffs ) ; diffs . add ( new Diff ( Operation . EQUAL , STRING ) ) ; int count delete = NUM ; int count insert = NUM ; String text delete = STRING ; String text insert = STRING ; List Iterator < Diff > pointer = diffs . list Iterator ( ) ; Diff this Diff = pointer . next ( ) ; while ( this Diff ! = null ) { switch ( this Diff . operation ) { case INSERT : count insert + + ; text insert + = this Diff . text ; break ; case DELETE : count delete + + ; text delete + = this Diff . text ; break ; case EQUAL : if ( count delete > = NUM & & count insert > = NUM ) { pointer . previous ( ) ; for ( int j = NUM ; j < count delete + count insert ; j + + ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( Diff new Diff : diff main ( text delete , text insert , BOOL , deadline ) ) { pointer . add ( new Diff ) ; } } count insert = NUM ; count delete = NUM ; text delete = STRING ; text insert = STRING ; break ; } this Diff = pointer . has Next ( ) ? pointer . next ( ) : null ; } diffs . remove Last ( ) ; return diffs ; }",
    "label": 1
  },
  {
    "text_1": "pad a string from right .",
    "text_2": "public static String format ( String s , String col ) { String s1 = ( s + p add ) ; return s1 . substring ( NUM , Math . min ( col . length ( ) , s1 . length ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "read leading matching flags from the given text string and return the remaining text .",
    "text_2": "public String read Matching Flags ( String text ) { clear ( ) ; if ( text . starts With ( PM SEPARATOR ) ) { final String Tokenizer tok = new String Tokenizer ( text , PM SEPARATOR ) ; while ( tok . has More Tokens ( ) ) { final String flag = tok . next Token ( ) ; if ( flag . equals ( PM TYPE MATCH ) ) { type Matching = BOOL ; } else if ( flag . equals ( PM EXACT MATCH ) ) { exact Matching = BOOL ; } else if ( flag . equals ( PM SIMI LAR MATCH ) ) { similar Matching = BOOL ; } else if ( flag . equals ( PM IC ASE MATCH ) ) { case Insensitive = BOOL ; } else if ( flag . equals ( PM J OK ER MATCH ) ) { j oker Matching = BOOL ; } else { break ; } text = text . substring ( flag . length ( ) + NUM ) ; } if ( is Any Flag Set ( ) ) { text = text . substring ( NUM ) ; } } return text ; }",
    "label": 1
  },
  {
    "text_1": "updates entries using batched write - through .",
    "text_2": "@ Suppress Warnings ( { STRING , STRING } ) private Map < K , Entry Processor Result > update With Batch ( Grid Cache Operation op , Collection < ? extends K > keys , @ Nullable Iterable < ? > vals , @ Nullable Object [ ] invoke Args , @ Nullable Expiry Policy expiry Plc , Grid Cache Version ver , @ Nullable Cache Entry Predicate [ ] filter , boolean keep Binary , UUID subj Id , String task Name ) throws Ignite Checked Exception { List < Grid Cache Entry Ex > locked = lock Entries ( keys ) ; try { int size = locked . size ( ) ; Map < Object , Object > put Map = null ; Collection < Object > rmv Keys = null ; List < Cache Object > write Vals = null ; Map < K , Entry Processor Result > invoke Res Map = op = = TRANSFORM ? U . < K , Entry Processor Result > new Hash Map ( size ) : null ; List < Grid Cache Entry Ex > filtered = new Array List < > ( size ) ; Cache Partial Update Checked Exception err = null ; Iterator < ? > vals Iter = vals ! = null ? vals . iterator ( ) : null ; boolean intercept = ctx . config ( ) . get Interceptor ( ) ! = null ; for ( int i = NUM ; i < size ; i + + ) { Grid Cache Entry Ex entry = locked . get ( i ) ; Object val = vals Iter ! = null ? vals Iter . next ( ) : null ; if ( val = = null & & op ! = DELETE ) throw new Null Pointer Exception ( STRING ) ; try { try { if ( ! ctx . is All Locked ( entry , filter ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry + STRING + Arrays . to String ( filter ) + STRING ) ; continue ; } } catch ( Ignite Checked Exception e ) { if ( err = = null ) err = partial Update Exception ( ) ; err . add ( F . as List ( entry . key ( ) ) , e ) ; continue ; } if ( op = = TRANSFORM ) { ctx . kernal Context ( ) . resource ( ) . inject ( val , Grid Resource Ioc . Annotation Set . ENTRY PROCESSOR , ctx . name ( ) ) ; Entry Processor < Object , Object , Object > entry Processor = ( Entry Processor < Object , Object , Object > ) val ; Cache Object old = entry . inner Get ( null , null , BOOL , BOOL , BOOL , BOOL , BOOL , subj Id , entry Processor , task Name , null , keep Binary ) ; Object old Val = null ; Cache Invoke Entry < Object , Object > invoke Entry = new Cache Invoke Entry < > ( entry . key ( ) , old , entry . version ( ) , keep Binary , entry ) ; Cache Object updated ; Object updated Val = null ; Cache Invoke Result invoke Res = null ; try { Object computed = entry Processor . process ( invoke Entry , invoke Args ) ; updated Val = ctx . unwrap Temporary ( invoke Entry . get Value ( ) ) ; updated = ctx . to Cache Object ( updated Val ) ; if ( computed ! = null ) invoke Res = Cache Invoke Result . from Result ( ctx . unwrap Temporary ( computed ) ) ; } catch ( Exception e ) { invoke Res = Cache Invoke Result . from Error ( e ) ; updated = old ; } if ( invoke Res ! = null ) invoke Res Map . put ( ( K ) entry . key ( ) . value ( ctx . cache Object Context ( ) , BOOL ) , invoke Res ) ; if ( updated = = null ) { if ( intercept ) { Ignite Bi Tuple < Boolean , ? > interceptor Res = ctx . config ( ) . get Interceptor ( ) . on Before Remove ( new Cache Lazy Entry ( ctx , entry . key ( ) , invoke Entry . key ( ) , old , old Val , keep Binary ) ) ; if ( ctx . cancel Remove ( interceptor Res ) ) continue ; } if ( put Map ! = null ) { err = update Partial Batch ( filtered , ver , write Vals , put Map , null , expiry Plc , keep Binary , err , subj Id , task Name ) ; put Map = null ; write Vals = null ; filtered = new Array List < > ( ) ; } if ( rmv Keys = = null ) rmv Keys = new Array List < > ( size ) ; rmv Keys . add ( entry . key ( ) . value ( ctx . cache Object Context ( ) , BOOL ) ) ; } else { if ( intercept ) { Object interceptor Val = ctx . config ( ) . get Interceptor ( ) . on Before Put ( new Cache Lazy Entry ( ctx , entry . key ( ) , invoke Entry . get Key ( ) , old , old Val , keep Binary ) , updated Val ) ; if ( interceptor Val = = null ) continue ; updated = ctx . to Cache Object ( ctx . unwrap Temporary ( interceptor Val ) ) ; } if ( rmv Keys ! = null ) { err = update Partial Batch ( filtered , ver , null , null , rmv Keys , expiry Plc , keep Binary , err , subj Id , task Name ) ; rmv Keys = null ; filtered = new Array List < > ( ) ; } if ( put Map = = null ) { put Map = new Linked Hash Map < > ( size , NUM ) ; write Vals = new Array List < > ( size ) ; } put Map . put ( CU . value ( entry . key ( ) , ctx , BOOL ) , CU . value ( updated , ctx , BOOL ) ) ; write Vals . add ( updated ) ; } } else if ( op = = UPDATE ) { Cache Object cache Val = ctx . to Cache Object ( val ) ; if ( intercept ) { Cache Object old = entry . inner Get ( null , null , BOOL , ctx . load Previous Value ( ) , BOOL , BOOL , BOOL , subj Id , null , task Name , null , keep Binary ) ; Object interceptor Val = ctx . config ( ) . get Interceptor ( ) . on Before Put ( new Cache Lazy Entry ( ctx , entry . key ( ) , old , keep Binary ) , val ) ; if ( interceptor Val = = null ) continue ; cache Val = ctx . to Cache Object ( ctx . unwrap Temporary ( interceptor Val ) ) ; } if ( put Map = = null ) { put Map = new Linked Hash Map < > ( size , NUM ) ; write Vals = new Array List < > ( size ) ; } put Map . put ( CU . value ( entry . key ( ) , ctx , BOOL ) , CU . value ( cache Val , ctx , BOOL ) ) ; write Vals . add ( cache Val ) ; } else { assert op = = DELETE ; if ( intercept ) { Cache Object old = entry . inner Get ( null , null , BOOL , ctx . load Previous Value ( ) , BOOL , BOOL , BOOL , subj Id , null , task Name , null , keep Binary ) ; Ignite Bi Tuple < Boolean , ? > interceptor Res = ctx . config ( ) . get Interceptor ( ) . on Before Remove ( new Cache Lazy Entry ( ctx , entry . key ( ) , old , keep Binary ) ) ; if ( ctx . cancel Remove ( interceptor Res ) ) continue ; } if ( rmv Keys = = null ) rmv Keys = new Array List < > ( size ) ; rmv Keys . add ( entry . key ( ) . value ( ctx . cache Object Context ( ) , BOOL ) ) ; } filtered . add ( entry ) ; } catch ( Ignite Checked Exception e ) { if ( err = = null ) err = partial Update Exception ( ) ; err . add ( F . as List ( entry . key ( ) ) , e ) ; } catch ( Grid Cache Entry Removed Exception ignore ) { assert BOOL : STRING ; } } if ( put Map ! = null | | rmv Keys ! = null ) { err = update Partial Batch ( filtered , ver , write Vals , put Map , rmv Keys , expiry Plc , keep Binary , err , subj Id , task Name ) ; } else assert filtered . is Empty ( ) ; if ( err ! = null ) throw err ; return invoke Res Map ; } finally { unlock Entries ( locked ) ; } }",
    "label": 1
  },
  {
    "text_1": "reads a sequence of bytes from the stream .",
    "text_2": "public byte [ ] read Bytes ( final int count ) { int bytes To Read = count ; if ( bytes To Read < NUM ) bytes To Read = byte Stream . available ( ) ; byte [ ] bytes = new byte [ bytes To Read ] ; if ( current Bit Index > = NUM ) { for ( int i = NUM ; i < bytes To Read ; i + + ) { bytes [ i ] = ( byte ) read ( Byte . SIZE ) ; } } else { byte Stream . read ( bytes , NUM , bytes . length ) ; } return bytes ; }",
    "label": 1
  },
  {
    "text_1": "add the marker . important : markers added in a marker clusterer should not be added in the map overlays .",
    "text_2": "public void add ( Marker marker ) { m Items . add ( marker ) ; }",
    "label": 1
  },
  {
    "text_1": "pop a source from a user provided uriresolver , corresponding to the url popped from the m import stack .",
    "text_2": "Source pop Import Source ( ) { return ( Source ) m import Source Stack . pop ( ) ; }",
    "label": 1
  },
  {
    "text_1": "1 / 1 + exp ( - x )",
    "text_2": "public static double sigmoid ( double x ) { return NUM / ( NUM + Math . pow ( Math . E , - x ) ) ; }",
    "label": 1
  },
  {
    "text_1": "execute non query sql with selection args , will replace ? s with selection args .",
    "text_2": "public void exec Non Query ( String sql , String [ ] selection Args ) { for ( int i = NUM , count = selection Args . length ; i < count ; i + + ) sql = sql . replace First ( STRING , selection Args [ i ] ) ; Log Utils . d ( sql ) ; database . exec SQL ( sql ) ; }",
    "label": 1
  },
  {
    "text_1": "helper for non - writer usage .",
    "text_2": "public final String translate ( final Char Sequence input ) { if ( input = = null ) { return null ; } try { final String Writer writer = new String Writer ( input . length ( ) * NUM ) ; translate ( input , writer ) ; return writer . to String ( ) ; } catch ( final IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } }",
    "label": 1
  },
  {
    "text_1": "draws the line onto a graphics context .",
    "text_2": "public synchronized void draw ( final Graphics NUM D gfx , final float x , final float y ) { if ( ! is Empty ( ) ) { m text Layout . draw ( gfx , x , y ) ; for ( final C Highlighting highlighting : new Array List < C Highlighting > ( m highlighting ) ) { final double bp X = ( x + highlighting . get Start ( ) ) - NUM ; final double bp Y = ( y - m char Height ) + NUM ; final double bp W = highlighting . get End ( ) + NUM ; final double bp H = m char Height - NUM ; draw Highlighting ( gfx , bp X , bp Y , bp W , bp H , highlighting . get Color ( ) ) ; } } }",
    "label": 1
  },
  {
    "text_1": "modify the port with new port network id .",
    "text_2": "private void modify ( Storage Port port , String port Network Id ) { port . set Port Network Id ( port Network Id ) ; db Client . persist Object ( port ) ; modified Storage Ports List . add ( port ) ; }",
    "label": 1
  },
  {
    "text_1": "sets the given string to be used as the request content , decoding to bytes with the given charset .",
    "text_2": "public Simple Http Request Builder content ( String chars , Charset charset ) { return content ( chars . get Bytes ( charset ) ) ; }",
    "label": 1
  },
  {
    "text_1": "create driver task for task type",
    "text_2": "private Driver Task create Driver Task ( String task Type ) { String task ID = String . format ( STRING , HP NUM PAR Constants . DRIVER NAME , task Type , UUID . random UUID ( ) ) ; Driver Task task = new HP NUM PAR Driver Task ( task ID ) ; return task ; }",
    "label": 1
  },
  {
    "text_1": "read a 64bit long in le",
    "text_2": "public long read Long LE ( ) throws IO Exception { input Stream . read Fully ( work Space , NUM , NUM ) ; return ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) < < NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "compares the two objects handling nulls gracefully and performing numeric type coercion if required",
    "text_2": "public static int compare To ( Object left , Object right ) { return compare To With Equality Check ( left , right , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "add a fixed view to appear at the top of the list . if add header view is called more than once , the views will appear in the order they were added . views added using this call can take focus if they want . note : call this before calling set adapter . this is so listview can wrap the supplied cursor with one that will also account for header and footer views .",
    "text_2": "public void add Header View ( View v , Object data , boolean is Selectable ) { if ( m Adapter ! = null & & ! ( m Adapter instanceof Header View List Adapter ) ) { throw new Illegal State Exception ( STRING ) ; } Fixed View Info info = new Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Header View Infos . add ( info ) ; if ( m Adapter ! = null & & m Observer ! = null ) { m Observer . on Changed ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "write the specified number of indentation units to the writer .",
    "text_2": "private void write Units Of Indentation ( int i ) throws IO Exception { for ( ; i > NUM ; i - - ) { writer . write ( INDENTATION UNIT ) ; } }",
    "label": 1
  },
  {
    "text_1": "draws a triangle to indicate the presence of far out values .",
    "text_2": "protected void draw High Far Out ( double a Radius , Graphics NUM D g NUM , double xx , double m ) { double side = a Radius * NUM ; g NUM . draw ( new Line NUM D . Double ( xx - side , m + side , xx + side , m + side ) ) ; g NUM . draw ( new Line NUM D . Double ( xx - side , m + side , xx , m ) ) ; g NUM . draw ( new Line NUM D . Double ( xx + side , m + side , xx , m ) ) ; }",
    "label": 1
  },
  {
    "text_1": "write timestamps to outputstream .",
    "text_2": "public void write To ( final Packet Output Stream os ) { os . write ( Parameter Writer . QUOTE ) ; os . write ( date To Byte ( ) ) ; Parameter Writer . format Microseconds ( os , ts . get Nanos ( ) / NUM , fractional Seconds ) ; os . write ( Parameter Writer . QUOTE ) ; }",
    "label": 1
  },
  {
    "text_1": "print command line usage information to given stream .",
    "text_2": "public void print Usage ( Output Stream os ) { int count = NUM ; Print Stream out = UTF NUM . print Stream ( os ) ; for ( String option : option List ) { if ( option Groups . contains Key ( count ) ) { out . println ( STRING + option Groups . get ( count ) ) ; } count + + ; if ( un listed Options . contains ( option ) ) { continue ; } out . print ( STRING ) ; String Builder buf = new String Builder ( ) ; buf . append ( option ) ; if ( option Extra Part Synopsis Map . get ( option ) ! = null ) { String option Extra Part Synopsis = option Extra Part Synopsis Map . get ( option ) ; buf . append ( STRING ) ; buf . append ( option Extra Part Synopsis ) ; buf . append ( STRING ) ; } if ( requires Argument Set . contains ( option ) ) { buf . append ( STRING ) ; buf . append ( argument Description Map . get ( option ) ) ; buf . append ( STRING ) ; } print Field ( out , buf . to String ( ) , max Width + NUM ) ; out . println ( option Description Map . get ( option ) ) ; } out . flush ( ) ; }",
    "label": 1
  },
  {
    "text_1": "constructs an smb file representing a resource on an smb network such as a file or directory . see the description and examples of smb urls above .",
    "text_2": "public Smb File ( String url ) throws Malformed URL Exception { this ( new URL ( null , url , Handler . SMB HANDLER ) ) ; }",
    "label": 1
  },
  {
    "text_1": "handle the disallow : directive",
    "text_2": "private void handle Disallow ( Parse State state , Robot Token token ) { if ( state . is Skip Agents ( ) ) { return ; } state . set Finished Agent Fields ( BOOL ) ; if ( ! state . is Adding Rules ( ) ) { return ; } String path = token . get Data ( ) ; try { path = URL Decoder . decode ( path , STRING ) ; if ( path . length ( ) = = NUM ) { state . clear Rules ( ) ; } else { state . add Rule ( path , BOOL ) ; } } catch ( Exception e ) { report Warning ( STRING + path , state . get Url ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns whether the node is awake .",
    "text_2": "public boolean is Awake ( ) { return is Awake ; }",
    "label": 1
  },
  {
    "text_1": "determines whether the user fl ung the current item to delete it .",
    "text_2": "private Point F is Flin ging To Delete ( Drag Source source ) { if ( m Fling To Delete Drop Target = = null ) return null ; if ( ! source . supports Fling To Delete ( ) ) return null ; View Configuration config = View Configuration . get ( m Launcher ) ; m Velocity Tracker . compute Current Velocity ( NUM , config . get Scaled Maximum Fling Velocity ( ) ) ; if ( m Velocity Tracker . get Y Velocity ( ) < m Fling To Delete Threshold Velocity ) { Point F vel = new Point F ( m Velocity Tracker . get X Velocity ( ) , m Velocity Tracker . get Y Velocity ( ) ) ; Point F up Vec = new Point F ( NUM , - NUM ) ; float theta = ( float ) Math . acos ( ( ( vel . x * up Vec . x ) + ( vel . y * up Vec . y ) ) / ( vel . length ( ) * up Vec . length ( ) ) ) ; if ( theta < = Math . to Radians ( MAX FLING DEGREES ) ) { return vel ; } } return null ; }",
    "label": 1
  },
  {
    "text_1": "the pre main method will be executed before anything else .",
    "text_2": "public static void pre main ( String agent Args , Instrumentation inst ) { instrumentation = inst ; LOGGER . info ( STRING ) ; check For Correct Setup ( ) ; try { @ Suppress Warnings ( STRING ) Inspect It Class Loader class Loader = new Inspect It Class Loader ( new URL [ NUM ] ) ; Class < ? > agent Clazz = class Loader . load Class ( IN SPEC TI T AGENT ) ; Constructor < ? > constructor = agent Clazz . get Constructor ( File . class ) ; Object real Agent = constructor . new Instance ( get Inspect It Agent Jar File Location ( ) ) ; Agent . agent = ( I Agent ) real Agent ; preload Classes ( ) ; LOGGER . info ( STRING ) ; analyze Already Loaded Classes ( ) ; inst . add Transformer ( new Java Agent ( ) ) ; } catch ( Exception e ) { LOGGER . severe ( STRING ) ; e . print Stack Trace ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "reset the workspace view when changing workspaces . removes old views and creates all necessary new views .",
    "text_2": "public void reset Workspace ( ) { m Block Factory . clear Prior Block References ( ) ; m Root Blocks . clear ( ) ; m Stats . clear ( ) ; m Deleted Blocks . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "verify that the given certificate successfully handles and confirms the signature associated with this signer and , if a signing time attribute is available , that the certificate was valid at the time the signature was generated .",
    "text_2": "public boolean verify ( X509 Certificate cert , Provider sig Provider ) throws No Such Algorithm Exception , Certificate Expired Exception , Certificate Not Yet Valid Exception , CMS Exception { Time signing Time = get Signing Time ( ) ; if ( signing Time ! = null ) { cert . check Validity ( signing Time . get Date ( ) ) ; } return do Verify ( cert . get Public Key ( ) , sig Provider ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if the app has been installed on the system .",
    "text_2": "public static boolean is Installed ( Package Manager package Manager , String package Name ) { List < Package Info > packs = package Manager . get Installed Packages ( NUM ) ; for ( int i = NUM ; i < packs . size ( ) ; i + + ) { if ( Text Utils . equals ( packs . get ( i ) . package Name , package Name ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "invoked from native code",
    "text_2": "private static void stop GC ( ) { gc Should Loop = BOOL ; synchronized ( LOCK ) { LOCK . notify ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "gets the sin us of the angle .",
    "text_2": "private double sin ( double angle ) { while ( angle > = NUM ) { angle - = NUM ; } double value = angle / NUM * Math . PI ; return Math . sin ( value ) ; }",
    "label": 1
  },
  {
    "text_1": "makes the object immutable",
    "text_2": "public void make Immutable ( ) { }",
    "label": 1
  },
  {
    "text_1": "listen for changes to the active mouse mode and for any changes to the list of available mouse modes . if the active mouse mode is \" gestures \" , then the lat lon updates to the status line are deactivated .",
    "text_2": "public void property Change ( Property Change Event evt ) { String prop Name = evt . get Property Name ( ) ; if ( prop Name = = Map Bean . Cursor Property ) { fallback Map Bean Cursor = ( ( Cursor ) evt . get New Value ( ) ) ; } else { if ( prop Name = = Mouse Delegator . Active Mode Property ) { Map Mouse Mode mmm = ( Map Mouse Mode ) evt . get New Value ( ) ; set Reset Cursor ( mmm . get Mode Cursor ( ) ) ; } else if ( prop Name = = Map Bean . Layers Property ) { reset For Layers ( ( Layer [ ] ) evt . get New Value ( ) , ( Layer [ ] ) evt . get Old Value ( ) ) ; } else if ( prop Name ! = Map Bean . Projection Property ) { return ; } set All Labels ( fudge String ) ; } init Tool Tip ( ) ; }",
    "label": 1
  },
  {
    "text_1": "make a prettyp rin ted json text of this jsonobject . warning : this method assumes that the signal data structure is acyclical .",
    "text_2": "public String to String ( int indent Factor ) throws JSON Exception { return to String ( indent Factor , NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new set of group categories initialized from the given array of group categories",
    "text_2": "public Group Category Set ( Group Category [ ] categories ) { Assert . is Not Null ( categories ) ; f Content = new Array List ( categories . length ) ; for ( int i = NUM ; i < categories . length ; i + + ) { if ( ! f Content . contains ( categories [ i ] ) ) f Content . add ( categories [ i ] ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a footer view .",
    "text_2": "public void add Footer ( @ Non Null View view ) { if ( view = = null ) { throw new Illegal Argument Exception ( STRING ) ; } m Footers . add ( view ) ; }",
    "label": 1
  },
  {
    "text_1": "add a trace for a statistic of the given name",
    "text_2": "private void add Trace And Type ( String name ) { if ( traces Type . get ( name ) = = null ) { traces . add ( create Trace ( name , Trace Type . REAL ) ) ; traces Type . put ( name , Trace Type . REAL ) ; } else { traces . add ( create Trace ( name , traces Type . get ( name ) ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "construct a new instance with the specified detail string and exception .",
    "text_2": "Configuration Error ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }",
    "label": 1
  },
  {
    "text_1": "utility method to find the first invalid character as per rfc 2396 section 2 . this helps us prevent creating excessive objects in the encode ( ) methods since most strings will not be encoded .",
    "text_2": "static int first Illegal Character ( String source ) { for ( int i = NUM ; i < source . length ( ) ; i + + ) { if ( is Legal ( source . char At ( i ) ) = = BOOL ) { return i ; } } return - NUM ; }",
    "label": 1
  },
  {
    "text_1": "determines if an imageconsumer is on the list of consumers currently interested in data for this image .",
    "text_2": "public synchronized boolean is Consumer ( Image Consumer ic ) { return the Consumers . contains ( ic ) ; }",
    "label": 1
  },
  {
    "text_1": "validates if the host is part of a cluster on x iv system . uses initiators to find out the hosts",
    "text_2": "public boolean is Clustered Host ( Storage System storage , List < Initiator > initiators ) { return is Clustered Host ( storage , initiators , null ) ; }",
    "label": 1
  },
  {
    "text_1": "checks if the media type needs to be drm converted",
    "text_2": "public static boolean is Drm Convert Needed ( String mimetype ) { return MIMETYPE DRM MESSAGE . equals ( mimetype ) ; }",
    "label": 1
  },
  {
    "text_1": "remove all the money objects . called at zone change .",
    "text_2": "private void clear Money ( ) { money . clear ( ) ; update Money ( ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new resource and performs any initili zation required to manage the resource",
    "text_2": "protected Object create Resource ( ) throws Resource Unavailable Exception { Object resource = create ( ) ; freed . add ( resource ) ; num Created + + ; return ( resource ) ; }",
    "label": 1
  },
  {
    "text_1": "the method where a graphic , and an action to take on the graphic , arrives .",
    "text_2": "public void drawing Complete ( OM Graphic omg , OM Action action ) { if ( timer Button . is Selected ( ) ) { timer . restart ( ) ; } if ( omg instanceof OM Point ) { OM Point p = ( OM Point ) omg ; GL Point mp = new GL Point ( p . get Lat ( ) , p . get Lon ( ) , p . get Radius ( ) , BOOL ) ; mp . set Name ( STRING + ( point Count + + ) ) ; mp . set Stationary ( BOOL ) ; mp . show Palette ( ) ; points . put ( mp . get Name ( ) , mp ) ; manage Graphics ( ) ; } else if ( omg instanceof OM Poly ) { OM Poly poly = ( OM Poly ) omg ; Path GL Point p mp = new Path GL Point ( poly , NUM , BOOL ) ; p mp . set Name ( STRING + ( point Count + + ) ) ; p mp . show Palette ( ) ; points . put ( p mp . get Name ( ) , p mp ) ; manage Graphics ( ) ; } add Node Button . set Enabled ( BOOL ) ; add Path Button . set Enabled ( BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "wait for the listener invocation for up to the given number of milliseconds .",
    "text_2": "public void wait For Invocation ( long msec Wait , int number Of New Events ) { long start Time = System . current Time Millis ( ) ; while ( BOOL ) { if ( ( System . current Time Millis ( ) - start Time ) > msec Wait ) { throw new Runtime Exception ( STRING + number Of New Events + STRING + get New Data List Flattened ( ) . length ) ; } Event Bean [ ] events = get New Data List Flattened ( ) ; if ( events . length > = number Of New Events ) { return ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { return ; } } }",
    "label": 1
  },
  {
    "text_1": "wait for process termination",
    "text_2": "public void wait For ( ) { check Started ( ) ; try { if ( my Input Processor ! = null & & my Process ! = null ) { my Input Processor . process ( my Process . get Output Stream ( ) ) ; } } finally { wait For Process ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "formats the boolean array d .",
    "text_2": "public static String Builder format To ( String Builder buf , boolean [ ] d , String sep ) { if ( d = = null ) { return buf . append ( STRING ) ; } if ( d . length = = NUM ) { return buf ; } buf . append ( d [ NUM ] ) ; for ( int i = NUM ; i < d . length ; i + + ) { buf . append ( sep ) ; buf . append ( format ( d [ i ] ) ) ; } return buf ; }",
    "label": 1
  },
  {
    "text_1": "removes the ignored view .",
    "text_2": "public void remove Ignored View ( View v ) { m Ignored Views . remove ( v ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a boolean telling if this name valuelist has a record with this name",
    "text_2": "public boolean has Name Value ( String name ) { return name Value Map . contains Key ( name . to Lower Case ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "look up the given word in this trie . if a match is found , a tri enode is returned . this node is the root of a subtree containing all the matches to the query .",
    "text_2": "public Trie Node find ( String word ) { return ( word . length ( ) < NUM ? null : find ( word , root , NUM ) ) ; }",
    "label": 1
  },
  {
    "text_1": "removes the specified limit line from the axis .",
    "text_2": "public void remove Limit Line ( Limit Line l ) { m Limit Lines . remove ( l ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a required number of random bytes . the method overrides \" engine generate seed ( int ) \" in class secure random spi .",
    "text_2": "protected synchronized byte [ ] engine Generate Seed ( int num Bytes ) { byte [ ] my Bytes ; if ( num Bytes < NUM ) { throw new Negative Array Size Exception ( Integer . to String ( num Bytes ) ) ; } if ( num Bytes = = NUM ) { return Empty Array . BYTE ; } if ( my Random = = null ) { my Random = new SHA NUM PRNG Secure Random Impl ( ) ; my Random . engine Set Seed ( get Random Bytes ( DIGEST LENGTH ) ) ; } my Bytes = new byte [ num Bytes ] ; my Random . engine Next Bytes ( my Bytes ) ; return my Bytes ; }",
    "label": 1
  },
  {
    "text_1": "checks if token value is contained in list . this base implementation is able to deal with list types represented as sets ; subclasses may override this method to be able to deal with different list representations .",
    "text_2": "protected boolean check List ( String current Val , String token Value ) { if ( current Val = = null | | token Value = = null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! current Val . starts With ( STRING ) & & ! current Val . starts With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } boolean negation = current Val . starts With ( STRING ) ; String list Name = current Val . substring ( current Val . index Of ( STRING ) + NUM ) ; Object list Obj = list Map . get ( list Name ) ; if ( list Obj = = null ) return BOOL ; boolean contains ; if ( list Obj instanceof Set ) { Set < String > set = ( Set ) list Obj ; contains = set . contains ( token Value ) ; } else { throw new Illegal Argument Exception ( STRING + list Obj ) ; } return ! ( contains & & negation | | ! contains & & ! negation ) ; }",
    "label": 1
  },
  {
    "text_1": "description of the method",
    "text_2": "public void key Released ( Key Event e ) { if ( e . is Shift Down ( ) & & e . get Key Code ( ) = = NEXT THROTTLE KEY ) { request Focus For Next Frame ( ) ; } else if ( e . is Shift Down ( ) & & e . get Key Code ( ) = = PREV THROTTLE KEY ) { request Focus For Previous Frame ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds a new color to the colors array of the dataset .",
    "text_2": "public void add Color ( int color ) { if ( m Colors = = null ) m Colors = new Array List < Integer > ( ) ; m Colors . add ( color ) ; }",
    "label": 1
  },
  {
    "text_1": "the main program . takes path arguments , and prints the db it finds",
    "text_2": "public static void main ( String [ ] args ) throws Format Exception { Debug . init ( ) ; if ( args . length = = NUM ) { Debug . output ( STRING ) ; System . exit ( NUM ) ; } for ( int arg si = NUM ; arg si < args . length ; arg si + + ) { rootpath = args [ arg si ] ; Library Selection Table lst = new Library Selection Table ( rootpath ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + rootpath ) ; Debug . output ( STRING + lst . get Database Name ( ) ) ; } println ( STRING ) ; println ( STRING + rootpath ) ; println ( STRING + lst . get Database Description ( ) ) ; List < String > libraries = lst . get Library Names ( ) ; if ( Debug . debugging ( STRING ) ) { print ( STRING ) ; for ( String library Name : libraries ) { print ( library Name , STRING ) ; } println ( ) ; println ( ) ; } for ( String library Name : libraries ) { String prefix = lst . get Database Name ( ) + STRING + library Name ; println ( STRING + prefix ) ; print Library ( prefix , lst . get CAT ( library Name ) ) ; println ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "gets the number of children currently nested in this beancontext .",
    "text_2": "public int size ( ) { synchronized ( children ) { return children . size ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "run after both result completes exceptionally after exceptional completion of either source",
    "text_2": "public void test Run After Both exceptional Completion ( ) throws Throwable { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean f First : new boolean [ ] { BOOL , BOOL } ) for ( boolean fail First : new boolean [ ] { BOOL , BOOL } ) for ( Integer v NUM : new Integer [ ] { NUM , null } ) { final Completable Future < Integer > f = new Completable Future < > ( ) ; final Completable Future < Integer > g = new Completable Future < > ( ) ; final CF Exception ex = new CF Exception ( ) ; final Noop r NUM = new Noop ( m ) ; final Noop r NUM = new Noop ( m ) ; final Noop r3 = new Noop ( m ) ; final Completable Future < Integer > fst = f First ? f : g ; final Completable Future < Integer > snd = ! f First ? f : g ; final Callable < Boolean > complete NUM = fail First ? null : null ; final Callable < Boolean > complete NUM = fail First ? null : null ; final Completable Future < Void > h NUM = m . run After Both ( f , g , r NUM ) ; assert True ( complete NUM . call ( ) ) ; final Completable Future < Void > h NUM = m . run After Both ( f , g , r NUM ) ; check Incomplete ( h NUM ) ; check Incomplete ( h NUM ) ; assert True ( complete NUM . call ( ) ) ; final Completable Future < Void > h3 = m . run After Both ( f , g , r3 ) ; check Completed With Wrapped Exception ( h NUM , ex ) ; check Completed With Wrapped Exception ( h NUM , ex ) ; check Completed With Wrapped Exception ( h3 , ex ) ; r NUM . assert Not Invoked ( ) ; r NUM . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v NUM ) ; check Completed Exceptionally ( fail First ? fst : snd , ex ) ; } }",
    "label": 1
  },
  {
    "text_1": "searches for a xpath factory for a given uri in a meta - inf / services file .",
    "text_2": "private X Path Factory load From Services File ( String uri , String resource Name , Input Stream in ) { if ( debug ) debug Println ( STRING + resource Name ) ; Buffered Reader rd ; try { rd = new Buffered Reader ( new Input Stream Reader ( in , STRING ) , DEFAULT LINE LENGTH ) ; } catch ( java . io . Unsupported Encoding Exception e ) { rd = new Buffered Reader ( new Input Stream Reader ( in ) , DEFAULT LINE LENGTH ) ; } String factory Class Name ; X Path Factory result Factory = null ; while ( BOOL ) { try { factory Class Name = rd . read Line ( ) ; } catch ( IO Exception x ) { break ; } if ( factory Class Name ! = null ) { int hash Index = factory Class Name . index Of ( STRING ) ; if ( hash Index ! = - NUM ) { factory Class Name = factory Class Name . substring ( NUM , hash Index ) ; } factory Class Name = factory Class Name . trim ( ) ; if ( factory Class Name . length ( ) = = NUM ) { continue ; } try { X Path Factory found Factory = create Instance ( factory Class Name ) ; if ( found Factory . is Object Model Supported ( uri ) ) { result Factory = found Factory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } Io Utils . close Quietly ( rd ) ; return result Factory ; }",
    "label": 1
  },
  {
    "text_1": "returns a list of operations which should be performed , given the provided list of offers from mesos . the returned operations must be performed in the order in which they are provided .",
    "text_2": "public List < Offer Recommendation > evaluate ( List < Offer > offers ) { List < Offer Recommendation > recommendations = new Array List < Offer Recommendation > ( ) ; int offer Resource Count = NUM ; for ( Offer offer : offers ) { offer Resource Count + = offer . get Resources Count ( ) ; for ( Resource to Destroy : select Unexpected Resources ( expected Persistent Volume Ids , get Persistent Volumes By Id ( offer ) ) ) { recommendations . add ( new Destroy Offer Recommendation ( offer , to Destroy ) ) ; } } int destroy Recommendation Count = recommendations . size ( ) ; for ( Offer offer : offers ) { for ( Resource to Un reserve : select Unexpected Resources ( expected Reserved Resource Ids , get Reserved Resources By Id ( offer ) ) ) { recommendations . add ( new Un reserve Offer Recommendation ( offer , to Un reserve ) ) ; } } logger . info ( STRING , offers . size ( ) , offer Resource Count , destroy Recommendation Count , recommendations . size ( ) - destroy Recommendation Count ) ; return recommendations ; }",
    "label": 1
  },
  {
    "text_1": "select functionality test test select thre et ables ( ) . selects records from a table using union",
    "text_2": "public void test Select Union Itself ( ) throws SQL Exception { String sql = STRING + STRING + Database Creator . CUSTOM ERS TABLE + STRING + Database Creator . CUSTOM ERS TABLE + STRING + STRING + STRING ; Result Set result = statement . execute Query ( sql ) ; Hash Map < Integer , String > value = new Hash Map < Integer , String > ( ) ; value . put ( NUM , STRING ) ; value . put ( NUM , STRING ) ; value . put ( NUM , STRING ) ; while ( result . next ( ) ) { int key = result . get Int ( STRING ) ; String val = result . get String ( STRING ) ; assert True ( STRING , value . contains Key ( key ) ) ; assert Equals ( STRING , value . get ( key ) , val ) ; value . remove ( key ) ; } assert True ( STRING , value . is Empty ( ) ) ; result . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "add data at the current position .",
    "text_2": "public void put ( byte [ ] source , int index , int length ) { if ( m Buffer . capacity ( ) < ( m Length + length ) ) { expand Buffer ( m Length + length + ADDITIONAL BUFFER SIZE ) ; } m Buffer . put ( source , index , length ) ; m Length + = length ; }",
    "label": 1
  },
  {
    "text_1": "adds view to specified cache . creates a cache list if it is null .",
    "text_2": "private List < View > add View ( View view , List < View > cache ) { if ( cache = = null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }",
    "label": 1
  },
  {
    "text_1": "does a class name appear to designate an anonymous class ? only the name is analyzed . no classes are loaded or looked up .",
    "text_2": "public static boolean is Anonymous ( String class Name ) { int i = class Name . last Index Of ( STRING ) ; if ( i > = NUM & & + + i < class Name . length ( ) ) { while ( i < class Name . length ( ) ) { if ( ! Character . is Digit ( class Name . char At ( i ) ) ) { return BOOL ; } i + + ; } return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "the contents of an xml elt",
    "text_2": "public void characters ( char ch [ ] , int start , int length ) { if ( title Pending ) { title . append ( ch , start , length ) ; } else if ( desc Pending ) { desc . append ( ch , start , length ) ; } }",
    "label": 1
  },
  {
    "text_1": "method to create a user entry",
    "text_2": "private void create User ( SSO Token token , Persistent Object parent Obj , Map attributes , String profile Name ) throws UMS Exception , AM Entry Exists Exception , AM Exception { String org DN = get Organization DN ( internal Token , parent Obj . get DN ( ) ) ; String entry DN = get Naming Attribute ( AM Object . USER ) + STRING + profile Name + STRING + parent Obj . get DN ( ) ; attributes = call Back Helper . pre Process ( token , entry DN , org DN , null , attributes , Call Back Helper . CREATE , AM Object . USER , BOOL ) ; Attr Set attr Set = Common Utils . map To Attr Set ( attributes ) ; make Naming First ( attr Set , get Naming Attribute ( AM Object . USER ) , profile Name ) ; User Password Validation Helper plugin Impl = new User Password Validation Helper ( token , org DN ) ; try { plugin Impl . validate ( Common Utils . attr Set To Map ( attr Set ) ) ; } catch ( AM Exception ame ) { debug . error ( STRING + STRING , ame ) ; throw ame ; } Template Manager temp Mgr = Template Manager . get Template Manager ( ) ; Creation Template creation Temp = temp Mgr . get Creation Template ( STRING , new Guid ( org DN ) , Template Manager . SCOPE ANCE STOR S ) ; attr Set = combine O Cs ( creation Temp , attr Set ) ; Persistent Object user = new Persistent Object ( creation Temp , attr Set ) ; try { parent Obj . add Child ( user ) ; } catch ( Access Rights Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , e ) ; } throw new AM Exception ( token , STRING ) ; } catch ( Entry Already Exists Exception ee ) { if ( Compliance Services Impl . is Compliance User Deletion Enabled ( ) ) { compliance Impl . check If Deleted User ( token , user . get DN ( ) ) ; } if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , ee ) ; } throw new AM Entry Exists Exception ( token , STRING , ee ) ; } catch ( UMS Exception ue ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , ue ) ; } process Internal Exception ( token , ue , STRING ) ; } call Back Helper . post Process ( token , user . get DN ( ) , org DN , null , attributes , Call Back Helper . CREATE , AM Object . USER , BOOL ) ; AM User Entry Processed post Plugin = get User Post Plugin ( ) ; if ( post Plugin ! = null ) { Map attr Map = Common Utils . attr Set To Map ( attr Set ) ; post Plugin . process User Add ( token , user . get DN ( ) , attr Map ) ; } Email Notification Helper mailer Obj = new Email Notification Helper ( user . get DN ( ) ) ; mailer Obj . set User Create Notification List ( ) ; mailer Obj . send User Create Notification ( attributes ) ; }",
    "label": 1
  },
  {
    "text_1": "increase the image size ( dpi ) .",
    "text_2": "public void increase Dpi ( ) { if ( this . current Dpi Pos < ( this . dpi Sizes . length - NUM ) ) { + + this . current Dpi Pos ; } }",
    "label": 1
  },
  {
    "text_1": "returns the remainder of ' reader ' as a string , closing it when done .",
    "text_2": "public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) ! = - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "attempts to update the textfield value from the editor .",
    "text_2": "protected void update Us ( ) { try { set Text ( m Editor . get As Text ( ) ) ; } catch ( Illegal Argument Exception ex ) { } }",
    "label": 1
  },
  {
    "text_1": "computes the weighted mean of the given data set .",
    "text_2": "public static Vec mean Vector ( Data Set data Set ) { Dense Vector dv = new Dense Vector ( data Set . get Num Numerical Vars ( ) ) ; mean Vector ( dv , data Set ) ; return dv ; }",
    "label": 1
  },
  {
    "text_1": "executes a process and returns an object representing it .",
    "text_2": "public Process exec ( String [ ] tainted Command , String [ ] tainted Environment , File working Directory , boolean redirect Error Stream ) throws IO Exception { if ( tainted Command = = null ) { throw new Null Pointer Exception ( STRING ) ; } if ( tainted Command . length = = NUM ) { throw new Index Out Of Bounds Exception ( STRING ) ; } String [ ] command = tainted Command . clone ( ) ; String [ ] environment = tainted Environment ! = null ? tainted Environment . clone ( ) : null ; for ( int i = NUM ; i < command . length ; i + + ) { if ( command [ i ] = = null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } if ( environment ! = null ) { for ( int i = NUM ; i < environment . length ; i + + ) { if ( environment [ i ] = = null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } } File Descriptor in = new File Descriptor ( ) ; File Descriptor out = new File Descriptor ( ) ; File Descriptor err = new File Descriptor ( ) ; String working Path = ( working Directory = = null ) ? null : working Directory . get Path ( ) ; synchronized ( process References ) { int pid ; try { pid = exec ( command , environment , working Path , in , out , err , redirect Error Stream ) ; } catch ( IO Exception e ) { IO Exception wrapper = new IO Exception ( STRING + STRING + Arrays . to String ( command ) + STRING + working Directory + STRING + Arrays . to String ( environment ) ) ; wrapper . init Cause ( e ) ; throw wrapper ; } Process Impl process = new Process Impl ( pid , in , out , err ) ; Process Reference process Reference = new Process Reference ( process , reference Queue ) ; process References . put ( pid , process Reference ) ; process References . notify All ( ) ; return process ; } }",
    "label": 1
  },
  {
    "text_1": "returns the remote client ' s port .",
    "text_2": "@ Override public int port Remote ( ) { if ( channel ! = null ) { try { Socket Address addr = channel . get Remote Address ( ) ; return NUM ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return NUM ; } } else return NUM ; }",
    "label": 1
  },
  {
    "text_1": "check if the expected character exist at the given offset in the value .",
    "text_2": "private static boolean check Offset ( String value , int offset , char expected ) { return ( offset < value . length ( ) ) & & ( value . char At ( offset ) = = expected ) ; }",
    "label": 1
  },
  {
    "text_1": "closes the output writer .",
    "text_2": "public synchronized void close ( ) { try { writer . close ( ) ; } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "check for end matches while searching for item names .",
    "text_2": "private boolean search End Match ( final String item Name ) { for ( Map . Entry < String , Sentence > e : parsed Names . entry Set ( ) ) { Sentence parsed = e . get Value ( ) ; if ( item Name . ends With ( parsed . get Original Text ( ) ) | | item Name . ends With ( parsed . get Normalized ( ) ) ) { name = e . get Key ( ) ; return BOOL ; } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "parse an integer located between 2 given offsets in a string",
    "text_2": "private static int parse Int ( String value , int begin Index , int end Index ) throws Number Format Exception { if ( begin Index < NUM | | end Index > value . length ( ) | | begin Index > end Index ) { throw new Number Format Exception ( value ) ; } int i = begin Index ; int result = NUM ; int digit ; if ( i < end Index ) { digit = Character . digit ( value . char At ( i + + ) , NUM ) ; if ( digit < NUM ) { throw new Number Format Exception ( STRING + value . substring ( begin Index , end Index ) ) ; } result = - digit ; } while ( i < end Index ) { digit = Character . digit ( value . char At ( i + + ) , NUM ) ; if ( digit < NUM ) { throw new Number Format Exception ( STRING + value . substring ( begin Index , end Index ) ) ; } result * = NUM ; result - = digit ; } return - result ; }",
    "label": 1
  },
  {
    "text_1": "returns true if the parity shards contain the right data . this method may be significantly faster than the one above that does not use a temporary buffer .",
    "text_2": "public boolean is Parity Correct ( byte [ ] [ ] shards , int first Byte , int byte Count , byte [ ] temp Buffer ) { check Buffers And Sizes ( shards , first Byte , byte Count ) ; if ( temp Buffer . length < first Byte + byte Count ) { throw new Illegal Argument Exception ( STRING ) ; } byte [ ] [ ] to Check = new byte [ parity Shard Count ] [ ] ; System . arraycopy ( shards , data Shard Count , to Check , NUM , parity Shard Count ) ; return coding Loop . check Some Shards ( parity Rows , shards , data Shard Count , to Check , parity Shard Count , first Byte , byte Count , temp Buffer ) ; }",
    "label": 1
  },
  {
    "text_1": "returns true if we need the . sf file",
    "text_2": "public boolean need Signature File Bytes ( ) { return sf Bytes = = null ; }",
    "label": 1
  },
  {
    "text_1": "serializes the supplied object xml",
    "text_2": "public static String serialize ( Object to Serialize ) throws Exception { Class < ? > xstream Class ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] serialize Args Classes = new Class [ NUM ] ; Object [ ] serialize Args = new Object [ NUM ] ; java . lang . reflect . Method method Serialize ; String result ; xstream Class = Class . for Name ( STRING ) ; constructor = xstream Class . get Constructor ( ) ; xstream = constructor . new Instance ( ) ; serialize Args Classes [ NUM ] = Object . class ; serialize Args [ NUM ] = to Serialize ; method Serialize = xstream Class . get Method ( STRING , serialize Args Classes ) ; try { result = ( String ) method Serialize . invoke ( xstream , serialize Args ) ; } catch ( Exception ex ) { result = null ; } return result ; }",
    "label": 1
  },
  {
    "text_1": "submits task to execution pool",
    "text_2": "void submit ( Process And Display Image Task task ) { init Executors If Need ( ) ; task Executor For Cached Images . execute ( task ) ; }",
    "label": 1
  },
  {
    "text_1": "populates ( or reloads ) the data file with the text of the given content",
    "text_2": "public void read Data File ( String content ) throws Data File Exception { if ( content = = null | | content . length ( ) < = NUM ) throw new Illegal State Exception ( STRING ) ; Byte Array Input Stream bis = new Byte Array Input Stream ( content . get Bytes ( ) ) ; read Data File ( bis , null ) ; }",
    "label": 1
  },
  {
    "text_1": "returns the pure ( without the line delimiter ) length of this line .",
    "text_2": "int pure Length ( ) { return length - delimiter . length ( ) ; }",
    "label": 1
  },
  {
    "text_1": "mousereleased , final function . handles mouse released events . this function also detects liber al single clicks , and liber al double clicks .",
    "text_2": "@ Override final public void mouse Released ( Mouse Event e ) { if ( is Component Pressed Down ) { mouse Liber al Click ( e ) ; long now = System . current Time Millis ( ) ; long time Between Unused Clicks = now - last Unused Liber al Single Click Time Stamp ; if ( time Between Unused Clicks < = slowest Double Click Milliseconds ) { mouse Liber al Double Click ( e ) ; last Unused Liber al Single Click Time Stamp = NUM ; } else { last Unused Liber al Single Click Time Stamp = System . current Time Millis ( ) ; } } is Component Pressed Down = BOOL ; mouse Release ( e ) ; }",
    "label": 1
  },
  {
    "text_1": "clean means to remove the attack request , set the current points to zero and check the plugin state .",
    "text_2": "@ Override public void clean ( ) { set Current Points ( NUM ) ; check State ( ) ; }",
    "label": 1
  },
  {
    "text_1": "clears the pie segments list .",
    "text_2": "public void clear Pie Segments ( ) { m Pie Segment List . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "fills the list from pos up to the top of the list view .",
    "text_2": "private View fill Up ( int pos , int next Bottom ) { if ( DEBUG ) Log . i ( TAG , STRING + pos + STRING + next Bottom + M FIRST POSITION + m First Position ) ; View selected View = null ; final int end = m List Padding . top ; while ( next Bottom > end & & pos > = NUM ) { View temp = make Row ( pos , next Bottom , BOOL ) ; if ( temp ! = null ) { selected View = temp ; } next Bottom = m Reference View . get Top ( ) - m Vertical Spacing ; m First Position = pos ; pos - = m Num Columns ; } if ( m Stack From Bottom ) { m First Position = Math . max ( NUM , pos + NUM ) ; } return selected View ; }",
    "label": 1
  },
  {
    "text_1": "implements the trigger function for trigger able interface .",
    "text_2": "public void trigger ( Date time ) { task List . remove ( time ) ; }",
    "label": 1
  },
  {
    "text_1": "inject some data from data to target .",
    "text_2": "public static void inject To Target ( Object target , Bundle data ) { if ( target = = null | | data = = null ) return ; Parcel Injector injector ; try { injector = get Injector By Class ( target . get Class ( ) ) ; injector . inject Data To Target ( target , data ) ; } catch ( Exception e ) { throw new Runtime Exception ( String . format ( STRING , e . get Message ( ) ) , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "format a given object .",
    "text_2": "public String format ( Object obj , String Buffer to Append To ) throws Illegal Argument Exception { return format ( ( Date ) obj , to Append To ) ; }",
    "label": 1
  },
  {
    "text_1": "output a diagnostic message to a user - specified destination ( if the user has enabled diagnostic logging ) .",
    "text_2": "protected void log Diagnostic ( String msg ) { if ( is Diagnostics Enabled ( ) ) { log Raw Diagnostic ( diagnostic Prefix + msg ) ; } }",
    "label": 1
  },
  {
    "text_1": "raise an io exception for asyn cr hono us retransmission of responses",
    "text_2": "private void raise IO Exception ( String host , int port , String protocol ) { IO Exception Event io Error = new IO Exception Event ( this , host , port , protocol ) ; sip Provider . handle Event ( io Error , null ) ; set State ( SIP Dialog . TERMINATED STATE ) ; }",
    "label": 1
  },
  {
    "text_1": "validates a fully - qualified module name . module names are validated like fully - qualified java type names ; the package should be made up of lower - case segments that are valid java identifiers , and the name should be a camel - cased valid java identifier .",
    "text_2": "public static I Status validate Qualified Module Name ( String qualified Name ) { String pckg = Signature . get Qualifier ( qualified Name ) ; if ( ! Util . is Valid Package Name ( pckg ) ) { return Util . new Error Status ( STRING ) ; } return validate Simple Module Name ( Signature . get Simple Name ( qualified Name ) ) ; }",
    "label": 1
  },
  {
    "text_1": "handles tab selected event .",
    "text_2": "public void node Clicked ( Request Invocation Event event , int node ID ) { boolean forward To = BOOL ; String str Node Id = Integer . to String ( node ID ) ; if ( str Node Id . length ( ) > NUM ) { String prefix = str Node Id . substring ( NUM , NUM ) ; if ( prefix . equals ( AM Admin Constants . TAB AGENT PREFIX ) ) { set Page Session Attribute ( get Tracking Tab ID Name ( ) , Integer . to String ( node ID ) ) ; AM View Config am config = AM View Config . get Instance ( ) ; List list = am config . get Supported Agent Types ( get Model ( ) ) ; str Node Id = str Node Id . substring ( NUM ) ; int idx = Integer . parse Int ( str Node Id ) ; if ( idx < list . size ( ) ) { set Page Session Attribute ( PG SESSION AGENT TYPE , ( String ) list . get ( idx ) ) ; AM Post View Bean vb = ( AM Post View Bean ) get View Bean ( AM Post View Bean . class ) ; pass Pg Session Map ( vb ) ; vb . set Target View Bean URL ( STRING ) ; vb . forward To ( get Request Context ( ) ) ; forward To = BOOL ; } } } if ( ! forward To ) { try { AM View Bean Base vb = get Tab Node Associated View Bean ( STRING , node ID ) ; String tmp = ( String ) get Page Session Attribute ( AM Admin Constants . PREVIOUS REALM ) ; vb . set Page Session Attribute ( AM Admin Constants . PREVIOUS REALM , tmp ) ; tmp = ( String ) get Page Session Attribute ( AM Admin Constants . CURRENT REALM ) ; vb . set Page Session Attribute ( AM Admin Constants . CURRENT REALM , tmp ) ; tmp = ( String ) get Page Session Attribute ( AM Admin Constants . PREVIOUS TAB ID ) ; vb . set Page Session Attribute ( AM Admin Constants . PREVIOUS TAB ID , tmp ) ; unlock Page Trail For Sw apping ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { debug . error ( STRING , e ) ; forward To ( ) ; } } }",
    "label": 1
  },
  {
    "text_1": "creates default implementation of task distributor",
    "text_2": "public static Executor create Task Distributor ( ) { return Executors . new Cached Thread Pool ( create Thread Factory ( Thread . NORM PRIORITY , STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "adds the specified string to self .",
    "text_2": "public void add ( String string ) { elements . add ( string = = null ? Json Null . INSTANCE : new Json Primitive ( string ) ) ; }",
    "label": 1
  },
  {
    "text_1": "add a child node .",
    "text_2": "public void add Child ( Base Assembly Node child Node ) { child Node . parent Node = this ; child Nodes . add ( child Node ) ; }",
    "label": 1
  },
  {
    "text_1": "given a snapshot and a uri of its parent volume , look up any existing restore sessions and terminate them .",
    "text_2": "@ Override public void terminate Any Restore Sessions ( Storage System storage , Block Object from , URI volume , Task Completer task Completer ) throws Exception { Block Object block Object = Block Object . fetch ( db Client , volume ) ; Collection < CIM Object Path > sync Objects = null ; if ( storage . check If Vmax NUM ( ) ) { sync Objects = helper . get Settings Define State Paths ( storage , block Object , ( Block Snapshot ) from ) ; } else { sync Objects = get Restored Or Mixed State Sync Objects ( storage , block Object ) ; } for ( CIM Object Path sync Object : sync Objects ) { resume Snapshot ( storage , from , block Object , sync Object , task Completer ) ; } }",
    "label": 1
  },
  {
    "text_1": "prints the characters used to indent sql .",
    "text_2": "protected void print Indent ( String Builder ddl ) { ddl . append ( get Indent ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this test assumes unicode behavior where ' y ' and ' yyy ' don ' t truncate , which means that it will fail on the ri .",
    "text_2": "public void test Formatting Year ( ) { Format Tester test = new Format Tester ( ) ; Calendar cal = new Gregorian Calendar ( NUM , Calendar . JUN E , NUM , NUM , NUM , NUM ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , new Gregorian Calendar ( NUM , Calendar . JUN E , NUM ) , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , new Gregorian Calendar ( NUM , Calendar . JUN E , NUM ) , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , new Gregorian Calendar ( NUM , Calendar . JUN E , NUM ) , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; assert False ( test . tests Failed ) ; }",
    "label": 1
  },
  {
    "text_1": "parse the cache - control configuration parameter as a long integer , and set the filter expiry value , modulo the minimum and maximum expiry constraints . if the configuration parameter is not present , or not a valid long integer value , then no cache - control headers will be applied by the filter .",
    "text_2": "@ Override public void init ( Filter Config config ) throws Servlet Exception { try { expiry = Math . min ( Math . max ( MIN EXPIRY , Long . parse Long ( config . get Init Parameter ( CACHE CONTROL ) ) ) , MAX EXPIRY ) ; } catch ( Number Format Exception nfe ) { LOGGER . warn ( STRING + CACHE CONTROL + STRING , nfe ) ; expiry = null ; } }",
    "label": 1
  },
  {
    "text_1": "returns the values for the bean map .",
    "text_2": "public Collection < Object > values ( ) { Array List < Object > answer = new Array List < Object > ( read Methods . size ( ) ) ; for ( Iterator < Object > iter = value Iterator ( ) ; iter . has Next ( ) ; ) { answer . add ( iter . next ( ) ) ; } return Collections . unmodifiable List ( answer ) ; }",
    "label": 1
  },
  {
    "text_1": "parses , validates and computes normalized version of g day object",
    "text_2": "protected Date Time Data parse ( String str ) throws Schema Date Time Exception { Date Time Data date = new Date Time Data ( str , this ) ; int len = str . length ( ) ; if ( str . char At ( NUM ) ! = STRING | | str . char At ( NUM ) ! = STRING | | str . char At ( NUM ) ! = STRING ) { throw new Schema Date Time Exception ( STRING ) ; } date . year = YEAR ; date . month = MONTH ; date . day = parse Int ( str , NUM , NUM ) ; if ( DAY SIZE < len ) { if ( ! is Next Char UTC Sign ( str , DAY SIZE , len ) ) { throw new Schema Date Time Exception ( STRING ) ; } else { get Time Zone ( str , date , DAY SIZE , len ) ; } } validate Date Time ( date ) ; save Un normalized ( date ) ; if ( date . utc ! = NUM & & date . utc ! = STRING ) { normalize ( date ) ; } date . position = NUM ; return date ; }",
    "label": 1
  },
  {
    "text_1": "character copy of file using utf - 8 . if port is non - null , will be substituted any time \" test port \" is found .",
    "text_2": "private static void copy File ( File src , File dst , Integer port , boolean internal Compression ) throws IO Exception { Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( new File Input Stream ( src ) , Standard Charsets . UTF NUM ) ) ; Writer out = new Output Stream Writer ( new File Output Stream ( dst ) , Standard Charsets . UTF NUM ) ; for ( String line = in . read Line ( ) ; null ! = line ; line = in . read Line ( ) ) { if ( null ! = port ) line = line . replace ( STRING , port . to String ( ) ) ; line = line . replace ( STRING , internal Compression ? STRING : STRING ) ; out . write ( line ) ; } in . close ( ) ; out . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "resets the builder to its initial , empty state .",
    "text_2": "public Builder clear ( ) { locale Builder . clear ( ) ; return this ; }",
    "label": 1
  },
  {
    "text_1": "create a new axis label layout layout .",
    "text_2": "public Axis Label Layout ( String group , int axis , Valued Range Model values ) { this ( group , axis , values , null ) ; }",
    "label": 1
  },
  {
    "text_1": "test whether equals the two objects .",
    "text_2": "public static boolean is Same ( Object s1 , Object s2 ) { if ( s1 = = s2 ) return BOOL ; if ( X . is Empty ( s1 ) & & X . is Empty ( s2 ) ) return BOOL ; if ( s1 ! = null ) { return s1 . equals ( s2 ) ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "handle message already parsed into id , command and parameters .",
    "text_2": "private void handle Command ( int id , String command , String params ) { String origin Command = command Id . get ( id ) ; if ( origin Command = = null ) { origin Command = STRING ; } handler . handle Command ( id , command , params , origin Command ) ; if ( command . equals ( STRING ) ) { LOGGER . warning ( STRING + params ) ; } }",
    "label": 1
  },
  {
    "text_1": "formats time to hh : mm given integer hour and minute",
    "text_2": "String format Time ( int hour , int minute ) { String s = STRING ; String t = Integer . to String ( hour ) ; if ( t . length ( ) = = NUM ) { s = t + STRING ; } else if ( t . length ( ) = = NUM ) { s = STRING + t + STRING ; } t = Integer . to String ( minute ) ; if ( t . length ( ) = = NUM ) { s = s + t ; } else if ( t . length ( ) = = NUM ) { s = s + STRING + t ; } if ( s . length ( ) ! = NUM ) { s = STRING ; } return s ; }",
    "label": 1
  },
  {
    "text_1": "returns true is found published du al inetaddress for this node , and it matches with current configured",
    "text_2": "private boolean verify Published Dual Inet Address ( String node Id ) { Dual Inet Address dual Address = null ; Configuration config = query Configuration ( Constants . NODE DU AL IN E TA DDR CONFIG , node Id ) ; if ( config ! = null ) { dual Address = parse Inet Address Config ( config ) ; } if ( ( dual Address ! = null ) & & dual Address . equals ( inet Address Lookup Map . get Dual Inet Address ( ) ) ) { return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "pop the name at the top of the stack for a particular register",
    "text_2": "Operand pop ( Register s ) { Stack < Operand > stack = get ( s ) ; if ( stack = = null ) { throw new Optimizing Compiler Exception ( STRING ) ; } else { return stack . pop ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "blocking method that waits until a complete successfully or error signal is received or until a timeout occurs .",
    "text_2": "public final Test Subscriber < T > await ( Duration timeout ) { if ( cdl . get Count ( ) = = NUM ) { return this ; } try { if ( ! cdl . await ( timeout . to Millis ( ) , Time Unit . MILLISECONDS ) ) { throw new Assertion Error ( STRING ) ; } return this ; } catch ( Interrupted Exception ex ) { throw new Assertion Error ( STRING , ex ) ; } }",
    "label": 1
  },
  {
    "text_1": "initialize this factory via a set of key - value pairs .",
    "text_2": "@ Suppress Warnings ( STRING ) public Throwing Mock Token Filter Factory ( Map < String , String > args ) { super ( args ) ; String exception Class Name = args . get ( STRING ) ; if ( exception Class Name = = null ) { throw new Runtime Exception ( STRING ) ; } try { exception Class = ( Class < ? extends Runtime Exception > ) Class . for Name ( exception Class Name ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( e ) ; } }",
    "label": 1
  },
  {
    "text_1": "set the icons to paint the title pane decorations .",
    "text_2": "private void define Internal Frames ( UI Defaults d ) { d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Dimension UI Resource ( NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , STRING ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; if ( Platform Utils . is Mac ( ) ) { d . put ( STRING , new Color ( NUM ) ) ; } else { d . put ( STRING , new Color ( NUM ) ) ; } d . put ( STRING , new Color ( NUM ) ) ; d . put ( STRING , new Color ( NUM ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM ) ) ; String p = STRING ; String c = PAINTER PREFIX + STRING ; d . put ( p + STRING , new Derived Font ( STRING , NUM , BOOL , null ) ) ; d . put ( p + STRING , STRING ) ; d . put ( p + STRING , new Title Pane Window Focused State ( ) ) ; d . put ( p + STRING , new Internal Frame Window Focused State ( ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Frame And Root Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Frame And Root Painter . Which . BACKGROUND ENABLED WINDOW FOCUSED ) ) ; p = STRING ; d . put ( p + STRING , NUM ) ; p = STRING ; d . put ( p + STRING , d . get ( STRING ) ) ; d . put ( p + STRING , Color . BLACK ) ; }",
    "label": 1
  },
  {
    "text_1": "encodes a string into base 64 format . no blanks or line breaks are inserted .",
    "text_2": "public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }",
    "label": 1
  },
  {
    "text_1": "see iso 16022 : 2006 , 5 . 2 . 8 and annex c table c . 3",
    "text_2": "private static void decode Edi fact Segment ( Bit Source bits , String Builder result ) { do { if ( bits . available ( ) < = NUM ) { return ; } for ( int i = NUM ; i < NUM ; i + + ) { int edi fact Value = bits . read Bits ( NUM ) ; if ( edi fact Value = = NUM ) { int bits Left = NUM - bits . get Bit Offset ( ) ; if ( bits Left ! = NUM ) { bits . read Bits ( bits Left ) ; } return ; } if ( ( edi fact Value & NUM ) = = NUM ) { edi fact Value | = NUM ; } result . append ( ( char ) edi fact Value ) ; } } while ( bits . available ( ) > NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "hides the popup window .",
    "text_2": "public void hide Popup ( ) { show Pending = BOOL ; if ( popup ! = null ) { popup . hide ( ) ; popup = null ; } }",
    "label": 1
  },
  {
    "text_1": "test de busqu eda sun directory server con limit e",
    "text_2": "public void test Find Spring Sun Directory Server With Limit ( ) { Ldap Proxy proxy = get Ldap Sun Directory Server ( ) ; List result = null ; int limit = NUM ; try { result = proxy . find ( get Ldap Search VO ( STRING , limit , STRING , STRING , null , Ldap Scope Constants . SCOPE SUBTREE ) ) ; } catch ( Exception e ) { } assert Not Null ( result ) ; if ( result ! = null ) { assert Equals ( limit , result . size ( ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "create the empty search result .",
    "text_2": "private Movie Subtitle Chooser Model ( ) { name = BUNDLE . get String ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "inserts one element into another array .",
    "text_2": "@ Suppress Warnings ( { STRING } ) public static < T > T [ ] insert ( T [ ] dest , T src , int offset , Class component Type ) { T [ ] temp = ( T [ ] ) Array . new Instance ( component Type , dest . length + NUM ) ; System . arraycopy ( dest , NUM , temp , NUM , offset ) ; temp [ offset ] = src ; System . arraycopy ( dest , offset , temp , offset + NUM , dest . length - offset ) ; return temp ; }",
    "label": 1
  },
  {
    "text_1": "returns an indented string representation of this element and any contained child elements .",
    "text_2": "public String to String ( ) { return to Indented String ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "calculate the optimum minimum tick . override to change default behaviour",
    "text_2": "public void calc Min Tick ( ) { if ( min Data = = NUM ) min Tick = NUM ; else min Tick = Math . floor ( min Data / major Tick ) * major Tick ; }",
    "label": 1
  },
  {
    "text_1": "update tr l tables automatically ?",
    "text_2": "public boolean is Auto Update Tr l ( String Table Name ) { if ( super . is Multi Lingu al Document ( ) ) return BOOL ; if ( Table Name = = null ) return BOOL ; if ( Table Name . starts With ( STRING ) & & get AD Client ID ( ) = = NUM ) return BOOL ; return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "this method was generated by mybatis generator . this method corresponds to the database table group roles",
    "text_2": "public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }",
    "label": 1
  },
  {
    "text_1": "removes an existing value from the series .",
    "text_2": "public synchronized void remove ( int index ) { super . remove ( index ) ; double removed Value = m Value . remove ( index ) ; if ( removed Value = = m Min Value | | removed Value = = m Max Value ) { init Range ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "copy the bytes of the string into the given byte array .",
    "text_2": "public void copy Into ( int str Offset , byte [ ] bytes , int array Offset , int len ) { System . arraycopy ( m bytes , m offset + str Offset , bytes , array Offset , len ) ; }",
    "label": 1
  },
  {
    "text_1": "removes the indexes of the documents .",
    "text_2": "public void remove Documents ( List < Query > queries ) { Index Writer writer = get Writer ( ) ; for ( Query query : queries ) { try { writer . delete Documents ( query ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; close Writer ( writer ) ; throw new Runtime Exception ( e ) ; } } close Writer ( writer ) ; }",
    "label": 1
  },
  {
    "text_1": "build a finite point .",
    "text_2": "private Vector NUM D finite Or Null Point ( final double x ) { return Double . is Infinite ( x ) ? null : new Vector NUM D ( x ) ; }",
    "label": 1
  },
  {
    "text_1": "prints a double followed by a newline .",
    "text_2": "final public void print ( double v ) { try { out . print ( v ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }",
    "label": 1
  },
  {
    "text_1": "scipio : tries to see if the passed product or category can be integrated in the current / given trail . if it can , returns a list of tra ile lements that can be passed to update reque stand trail which will merge them together . if an appropriate list of trail elements can ' t be made ( a brand new one will be required ) , returns null . fixme : this still does not always produce the most appropriate default trail ; it only helps in some simple cases where current trail already contains the current product or category .",
    "text_2": "public static List < String > make Best Trail Elements For Trail ( Http Servlet Request request , Delegator delegator , String category Id , String product Id ) { List < String > trail = Category Worker . get Trail ( request ) ; List < String > trail Elements = null ; if ( category Id ! = null ) { if ( trail = = null | | trail . size ( ) < NUM ) { ; } else { List Iterator < String > li = trail . list Iterator ( trail . size ( ) ) ; while ( li . has Previous ( ) ) { String trail Cat Id = li . previous ( ) ; if ( category Id . equals ( trail Cat Id ) ) { trail Elements = Fast List . new Instance ( ) ; trail Elements . add ( category Id ) ; break ; } } if ( trail Elements = = null ) { li = trail . list Iterator ( trail . size ( ) ) ; while ( li . has Previous ( ) ) { String trail Cat Id = li . previous ( ) ; if ( Category Worker . is Category Child Of ( request , trail Cat Id , category Id ) ) { trail Elements = Fast List . new Instance ( ) ; trail Elements . add ( trail Cat Id ) ; trail Elements . add ( category Id ) ; break ; } } } } } else { if ( trail = = null | | trail . size ( ) < NUM ) { ; } else { List Iterator < String > li = trail . list Iterator ( trail . size ( ) ) ; while ( li . has Previous ( ) ) { String trail Cat Id = li . previous ( ) ; if ( Category Worker . is Category Contains Product ( request , trail Cat Id , product Id ) ) { trail Elements = Fast List . new Instance ( ) ; trail Elements . add ( trail Cat Id ) ; break ; } } } } return trail Elements ; }",
    "label": 1
  },
  {
    "text_1": "add an action to the history of the client",
    "text_2": "public void add Action ( String action ) { Object [ ] args = new String [ NUM ] ; Simple Date Format sdf = new Simple Date Format ( context . get String ( R . string . date Format ) ) ; args [ NUM ] = sdf . format ( new Date ( ) ) ; String timestamp = context . get String ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notify Listeners ( new Property Change Event ( this , Activity Constants . history Property , null , null ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this all - in - one method reads a message log from the given file and turns that into a list of mqtt message objects .",
    "text_2": "public static List < Base Mqtt Message > read And Convert Message Log ( final File selected File ) throws Spy Exception { final List < String > lines = File Utils . read File As Lines ( selected File ) ; logger . info ( STRING , lines . size ( ) , selected File . get Absolute File ( ) ) ; return process Message Log ( parse Message Log ( lines , null , NUM , NUM ) , null , NUM , NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "construct a key and iv ( if necessary ) suitable for use with a cipher .",
    "text_2": "public static Cipher Parameters make PBE Parameters ( PBE Key Spec key Spec , int type , int hash , int key Size , int iv Size ) { PBE Parameters Generator generator = make PBE Generator ( type , hash ) ; byte [ ] key ; Cipher Parameters param ; key = convert Password ( type , key Spec ) ; generator . init ( key , key Spec . get Salt ( ) , key Spec . get Iteration Count ( ) ) ; if ( iv Size ! = NUM ) { param = generator . generate Derived Parameters ( key Size , iv Size ) ; } else { param = generator . generate Derived Parameters ( key Size ) ; } for ( int i = NUM ; i ! = key . length ; i + + ) { key [ i ] = NUM ; } return param ; }",
    "label": 1
  },
  {
    "text_1": "converts to object array .",
    "text_2": "public static Character [ ] values Of ( char [ ] array ) { Character [ ] dest = new Character [ array . length ] ; for ( int i = NUM ; i < array . length ; i + + ) { dest [ i ] = Character . value Of ( array [ i ] ) ; } return dest ; }",
    "label": 1
  },
  {
    "text_1": "from each element of the set of locator reg objects that correspond to lookup services that have been discovered , this method extracts the service registrar reference and returns all of the references in an array of service registrar .",
    "text_2": "private Service Registrar [ ] build Service Registrar ( ) { int k = NUM ; Service Registrar [ ] prox ys = new Service Registrar [ discovered Locators . size ( ) ] ; Iterator iter = discovered Locators . iterator ( ) ; while ( iter . has Next ( ) ) { Locator Reg reg = ( Locator Reg ) iter . next ( ) ; prox ys [ k + + ] = reg . proxy ; } return prox ys ; }",
    "label": 1
  },
  {
    "text_1": "appends the string representation of the object to the buffer .",
    "text_2": "public Char Buffer append ( Object obj ) { return append ( String . value Of ( obj ) ) ; }",
    "label": 1
  },
  {
    "text_1": "display help for a topic . the name will be lower - cased and extended with the help file suffix , then displayed .",
    "text_2": "public boolean display Topic ( String name ) { String topic = null ; if ( name = = null ) topic = DEFAULT + FILE TYPE ; else topic = name . to Lower Case ( ) + FILE TYPE ; File help File = new File ( help Dir , topic ) ; return display ( help File ) ; }",
    "label": 1
  },
  {
    "text_1": "calculate the attack value based on range",
    "text_2": "@ Override protected int calc Attack Value ( ) { int av = NUM ; if ( b Direct ) { av = Math . min ( av + ( to Hit . get Mo S ( ) / NUM ) , av * NUM ) ; } if ( b Glan cing ) { av = ( int ) Math . floor ( av / NUM ) ; } av = ( int ) Math . floor ( get Brack eting Multiplier ( ) * av ) ; return av ; }",
    "label": 1
  },
  {
    "text_1": "search for the script file , doesn ' t bother if it is named precisely . tries in this order : - actual supplied name - name . groovy - name . g vy - name . gy - name . g sh",
    "text_2": "public static File search For Groovy Script File ( String input ) { String script File Name = input . trim ( ) ; File script File = new File ( script File Name ) ; String [ ] standard Extensions = { STRING , STRING , STRING , STRING } ; int i = NUM ; while ( i < standard Extensions . length & & ! script File . exists ( ) ) { script File = new File ( script File Name + standard Extensions [ i ] ) ; i + + ; } if ( ! script File . exists ( ) ) { script File = new File ( script File Name ) ; } return script File ; }",
    "label": 1
  },
  {
    "text_1": "removes all the existing annotations from the series .",
    "text_2": "public synchronized void clear Annotations ( ) { m Annotations . clear ( ) ; m String XY . clear ( ) ; }",
    "label": 1
  },
  {
    "text_1": "evaluates the cf 3 problem .",
    "text_2": "public static void CF NUM ( double [ ] x , double [ ] f , double [ ] c , int nx ) { int count NUM = NUM ; int count NUM = NUM ; double sum NUM = NUM ; double sum NUM = NUM ; double prod NUM = NUM ; double prod NUM = NUM ; double yj ; double pj ; double N = NUM ; double a = NUM ; for ( int j = NUM ; j < = nx ; j + + ) { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; pj = Math . cos ( NUM * yj * PI / Math . sqrt ( j + NUM ) ) ; if ( j % NUM = = NUM ) { sum NUM + = yj * yj ; prod NUM * = pj ; count NUM + + ; } else { sum NUM + = yj * yj ; prod NUM * = pj ; count NUM + + ; } } f [ NUM ] = x [ NUM ] + NUM * ( NUM * sum NUM - NUM * prod NUM + NUM ) / ( double ) count NUM ; f [ NUM ] = NUM - x [ NUM ] * x [ NUM ] + NUM * ( NUM * sum NUM - NUM * prod NUM + NUM ) / ( double ) count NUM ; c [ NUM ] = f [ NUM ] + f [ NUM ] * f [ NUM ] - a * Math . sin ( N * PI * ( f [ NUM ] * f [ NUM ] - f [ NUM ] + NUM ) ) - NUM ; }",
    "label": 1
  },
  {
    "text_1": "encodes a socks 5 request and writes it to the next filter so it can be sent to the proxy server .",
    "text_2": "private void write Request ( final Next Filter next Filter , final Socks Proxy Request request , int step ) { try { Io Buffer buf = null ; if ( step = = Socks Proxy Constants . SOCKS NUM GRE E TING STEP ) { buf = encode Initial Greeting Packet ( request ) ; } else if ( step = = Socks Proxy Constants . SOCKS NUM AUTH STEP ) { buf = encode Authentication Packet ( request ) ; if ( buf = = null ) { step = Socks Proxy Constants . SOCKS NUM REQUEST STEP ; } } if ( step = = Socks Proxy Constants . SOCKS NUM REQUEST STEP ) { buf = encode Proxy Request Packet ( request ) ; } buf . flip ( ) ; write Data ( next Filter , buf ) ; } catch ( Exception ex ) { close Session ( STRING , ex ) ; } }",
    "label": 1
  },
  {
    "text_1": "find the ' middle snake ' of a diff , split the problem in two and return the recursively constructed diff . see my ers 19 86 paper : an o ( nd ) difference algorithm and its variations .",
    "text_2": "protected Linked List < Diff > diff bisect ( String text NUM , String text NUM , long deadline ) { int text NUM length = text NUM . length ( ) ; int text NUM length = text NUM . length ( ) ; int max d = ( text NUM length + text NUM length + NUM ) / NUM ; int v offset = max d ; int v length = NUM * max d ; int [ ] v NUM = new int [ v length ] ; int [ ] v NUM = new int [ v length ] ; for ( int x = NUM ; x < v length ; x + + ) { v NUM [ x ] = - NUM ; v NUM [ x ] = - NUM ; } v NUM [ v offset + NUM ] = NUM ; v NUM [ v offset + NUM ] = NUM ; int delta = text NUM length - text NUM length ; boolean front = ( delta % NUM ! = NUM ) ; int k NUM start = NUM ; int k NUM end = NUM ; int k NUM start = NUM ; int k NUM end = NUM ; for ( int d = NUM ; d < max d ; d + + ) { if ( System . current Time Millis ( ) > deadline ) { break ; } for ( int k NUM = - d + k NUM start ; k NUM < = d - k NUM end ; k NUM + = NUM ) { int k NUM offset = v offset + k NUM ; int x NUM ; if ( k NUM = = - d | | ( k NUM ! = d & & v NUM [ k NUM offset - NUM ] < v NUM [ k NUM offset + NUM ] ) ) { x NUM = v NUM [ k NUM offset + NUM ] ; } else { x NUM = v NUM [ k NUM offset - NUM ] + NUM ; } int y NUM = x NUM - k NUM ; while ( x NUM < text NUM length & & y NUM < text NUM length & & text NUM . char At ( x NUM ) = = text NUM . char At ( y NUM ) ) { x NUM + + ; y NUM + + ; } v NUM [ k NUM offset ] = x NUM ; if ( x NUM > text NUM length ) { k NUM end + = NUM ; } else if ( y NUM > text NUM length ) { k NUM start + = NUM ; } else if ( front ) { int k NUM offset = v offset + delta - k NUM ; if ( k NUM offset > = NUM & & k NUM offset < v length & & v NUM [ k NUM offset ] ! = - NUM ) { int x NUM = text NUM length - v NUM [ k NUM offset ] ; if ( x NUM > = x NUM ) { return diff bisect Split ( text NUM , text NUM , x NUM , y NUM , deadline ) ; } } } } for ( int k NUM = - d + k NUM start ; k NUM < = d - k NUM end ; k NUM + = NUM ) { int k NUM offset = v offset + k NUM ; int x NUM ; if ( k NUM = = - d | | ( k NUM ! = d & & v NUM [ k NUM offset - NUM ] < v NUM [ k NUM offset + NUM ] ) ) { x NUM = v NUM [ k NUM offset + NUM ] ; } else { x NUM = v NUM [ k NUM offset - NUM ] + NUM ; } int y NUM = x NUM - k NUM ; while ( x NUM < text NUM length & & y NUM < text NUM length & & text NUM . char At ( text NUM length - x NUM - NUM ) = = text NUM . char At ( text NUM length - y NUM - NUM ) ) { x NUM + + ; y NUM + + ; } v NUM [ k NUM offset ] = x NUM ; if ( x NUM > text NUM length ) { k NUM end + = NUM ; } else if ( y NUM > text NUM length ) { k NUM start + = NUM ; } else if ( ! front ) { int k NUM offset = v offset + delta - k NUM ; if ( k NUM offset > = NUM & & k NUM offset < v length & & v NUM [ k NUM offset ] ! = - NUM ) { int x NUM = v NUM [ k NUM offset ] ; int y NUM = v offset + x NUM - k NUM offset ; x NUM = text NUM length - x NUM ; if ( x NUM > = x NUM ) { return diff bisect Split ( text NUM , text NUM , x NUM , y NUM , deadline ) ; } } } } } Linked List < Diff > diffs = new Linked List < Diff > ( ) ; diffs . add ( new Diff ( Operation . DELETE , text NUM ) ) ; diffs . add ( new Diff ( Operation . INSERT , text NUM ) ) ; return diffs ; }",
    "label": 1
  },
  {
    "text_1": "inserts the string representation of the long argument into this string buffer . the second argument is converted to a string as if by the method string . valueof , and the characters of that string are then inserted into this string buffer at the position indicated by offset . the offset argument must be greater than or equal to 0 , and less than or equal to the length of this string buffer .",
    "text_2": "public java . lang . String Builder insert ( int offset , long l ) { return insert ( offset , Long . to String ( l ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method was generated by mybatis generator . this method corresponds to the database table project todo status",
    "text_2": "public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) = = NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }",
    "label": 1
  },
  {
    "text_1": "executes a service operation .",
    "text_2": "public < V > Future < V > invoke ( String method , String path , Map < String , ? > arguments , Result Handler < V > result Handler ) { if ( method = = null ) { throw new Illegal Argument Exception ( ) ; } if ( path = = null ) { throw new Illegal Argument Exception ( ) ; } if ( arguments = = null ) { throw new Illegal Argument Exception ( ) ; } return executor Service . submit ( new Invocation Callback < > ( method , path , arguments , result Handler ) ) ; }",
    "label": 1
  },
  {
    "text_1": "convert an instance of the open type into the java type .",
    "text_2": "public abstract Object from Open Value ( Object open Value ) throws Invalid Object Exception ;",
    "label": 1
  },
  {
    "text_1": "call char method v : invoke a virtual method that returns a char value",
    "text_2": "private static char Call Char Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Char , BOOL ) ; return Reflection . unwrap Char ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }",
    "label": 1
  },
  {
    "text_1": "returns the number of elements in the partition .",
    "text_2": "@ Override public int num Elements ( ) throws Exception { if ( m zero R ! = null ) { return NUM ; } return m Tree . num Nodes ( ) ; }",
    "label": 1
  },
  {
    "text_1": "writes the message to the stream .",
    "text_2": "public void write ( Output Stream out ) throws Socks Exception , IO Exception { if ( data = = null ) { Socks NUM Message msg ; if ( addr Type = = SOCKS AT Y P DOMAINNAME ) msg = new Socks NUM Message ( command , host , port ) ; else { if ( ip = = null ) { try { ip = Inet Address . get By Name ( host ) ; } catch ( Unknown Host Exception uh ex ) { throw new Socks Exception ( Socks Constants . SOCKS JUST ERROR ) ; } } msg = new Socks NUM Message ( command , ip , port ) ; } data = msg . data ; } out . write ( data ) ; }",
    "label": 1
  },
  {
    "text_1": "flip bit ( int n ) inside a positive number",
    "text_2": "public void test Flip Bit Positive Inside NUM ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i + + ) { assert True ( res Bytes [ i ] = = r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "this method deals with the fact , that the decoding process doesn ' t always yield a single most likely value . the current error correction implementation doesn ' t deal with er as ures very well , so it ' s better to provide a value for these ambiguous codewords instead of treating it as an erasure . the problem is that we don ' t know which of the ambiguous values to choose . we try decode using the first value , and if that fails , we use another of the ambiguous values and try to decode again . this usually only happens on very hard to read and decode barcodes , so decoding the normal barcodes is not affected by this .",
    "text_2": "private static Decoder Result create Decoder Result From Ambiguous Values ( int ec Level , int [ ] codewords , int [ ] erasure Array , int [ ] ambiguous Indexes , int [ ] [ ] ambiguous Index Values ) throws Format Exception , Checksum Exception { int [ ] ambiguous Index Count = new int [ ambiguous Indexes . length ] ; int tries = NUM ; while ( tries - - > NUM ) { for ( int i = NUM ; i < ambiguous Index Count . length ; i + + ) { codewords [ ambiguous Indexes [ i ] ] = ambiguous Index Values [ i ] [ ambiguous Index Count [ i ] ] ; } try { return decode Codewords ( codewords , ec Level , erasure Array ) ; } catch ( Checksum Exception ignored ) { } if ( ambiguous Index Count . length = = NUM ) { throw Checksum Exception . get Checksum Instance ( ) ; } for ( int i = NUM ; i < ambiguous Index Count . length ; i + + ) { if ( ambiguous Index Count [ i ] < ambiguous Index Values [ i ] . length - NUM ) { ambiguous Index Count [ i ] + + ; break ; } else { ambiguous Index Count [ i ] = NUM ; if ( i = = ambiguous Index Count . length - NUM ) { throw Checksum Exception . get Checksum Instance ( ) ; } } } } throw Checksum Exception . get Checksum Instance ( ) ; }",
    "label": 1
  },
  {
    "text_1": "encode a long as a variable length array . this method is appropriate for unsigned integers . for signed integers , negative values will always consume 10 bytes , so it is recommended to use write signed vl instead . this is taken from the varint encoding in protob ufs ( bsd licensed ) . see https : / / developers . google . com / protocol - buffers / docs / encoding",
    "text_2": "public static void write Unsigned VL ( long data , Data Output out ) throws IO Exception { while ( BOOL ) { if ( ( data & ~ NUM ) = = NUM ) { out . write Byte ( ( int ) data ) ; return ; } else { out . write Byte ( ( ( int ) data & NUM ) | NUM ) ; data > > > = NUM ; } } }",
    "label": 1
  },
  {
    "text_1": "this method will form one single byte [ ] for all the high card dims .",
    "text_2": "public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null = = byte Buffer Arr | | byte Buffer Arr . length = = NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM ; short offset Len = ( short ) ( no Of Col * NUM + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index + + ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len + = no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index + + ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "connect to zk cluster . as long quorum of nodes are available , client can talk to a cluster . if connection drop , this implementation will continuously retry sleeping 5 seconds in between .",
    "text_2": "public synchronized void connect ( ) { if ( ! zk Connection . is Started ( ) ) { zk Connection . start ( ) ; } if ( String Utils . is Empty ( site Id ) ) { generate Site Id ( ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns a string representation of the system .",
    "text_2": "public String to String ( ) { String Buffer sb = new String Buffer ( ) ; char [ ] separator = { STRING , STRING } ; int n = rows ( ) ; int m = columns ( ) ; for ( int i = NUM ; i < n ; i + + ) { separator [ NUM ] = STRING ; for ( int j = NUM ; j < m ; j + + ) { sb . append ( separator ) ; sb . append ( components [ i ] [ j ] ) ; separator [ NUM ] = STRING ; } sb . append ( STRING ) ; sb . append ( STRING ) ; } return sb . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a mal forme dur lexception if any of the urls are invalid .",
    "text_2": "private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { synchronized ( path To UR Ls Cache ) { Object [ ] v = path To UR Ls Cache . get ( path ) ; if ( v ! = null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i + + ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference < String > ( path ) } ) ; } return urls ; }",
    "label": 1
  },
  {
    "text_1": "adapts a website ' s icon ( e . g . favicon or touch icon ) to the material design style guidelines for home screen icons . this involves adding some padding and rounding the corners .",
    "text_2": "@ Called By Native public static Bitmap create Home Screen Icon From Web Icon ( Context context , Bitmap web Icon ) { Activity Manager am = ( Activity Manager ) context . get System Service ( Context . ACTIVITY SERVICE ) ; int max Inner Size = Math . round ( am . get Launcher Large Icon Size ( ) * MAX INNER SIZE RATIO ) ; int inner Size = Math . min ( max Inner Size , Math . max ( web Icon . get Width ( ) , web Icon . get Height ( ) ) ) ; int padding = Math . round ( ICON PADDING RATIO * inner Size ) ; int outer Size = inner Size + NUM * padding ; Bitmap bitmap = null ; try { bitmap = Bitmap . create Bitmap ( outer Size , outer Size , Bitmap . Config . ARGB NUM ) ; } catch ( Out Of Memory Error e ) { Log . w ( TAG , STRING ) ; return web Icon ; } Canvas canvas = new Canvas ( bitmap ) ; Rect inner Bounds = new Rect ( padding , padding , outer Size - padding , outer Size - padding ) ; Paint paint = new Paint ( Paint . ANTI ALIAS FLAG ) ; paint . set Filter Bitmap ( BOOL ) ; canvas . draw Bitmap ( web Icon , null , inner Bounds , paint ) ; int corner Radius = Math . round ( ICON CORNER RADIUS RATIO * outer Size ) ; Path path = new Path ( ) ; path . set Fill Type ( Path . Fill Type . INVERSE WIN DING ) ; Rect F inner Bounds F = new Rect F ( inner Bounds ) ; path . add Round Rect ( inner Bounds F , corner Radius , corner Radius , Path . Direction . CW ) ; paint . set Xfermode ( new Porter Duff Xfermode ( Porter Duff . Mode . CLEAR ) ) ; canvas . draw Path ( path , paint ) ; return bitmap ; }",
    "label": 1
  },
  {
    "text_1": "event fired at the end of the document parse",
    "text_2": "@ Override public void end Document ( ) throws SAX Exception { if ( resource ! = null ) { resource . add All Resource ( js Vector ) ; for ( Object object : resource . get Resource Set ( ) ) { Resource r = ( Resource ) object ; if ( r . get Resource ( ) ! = null ) { parser . set Resource ( ( Resource ) r ) ; parser . run ( ) ; js Set . add ( parser . get Result ( ) ) ; } } } }",
    "label": 1
  },
  {
    "text_1": "inserts the specified element at the tail of this queue , waiting if necessary for space to become available .",
    "text_2": "public void put ( E e ) throws Interrupted Exception { if ( e = = null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; Node < E > node = new Node < E > ( e ) ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) = = capacity ) { not Full . await ( ) ; } enqueue ( node ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c = = NUM ) signal Not Empty ( ) ; }",
    "label": 1
  },
  {
    "text_1": "searches the authentication provider ( either ldap or ad ) based on the given search controls and required return attributes and return count limit .",
    "text_2": "@ Suppress Warnings ( STRING ) private List < List < Group Attribute > > search Auth Provider ( Filter query Builder , String [ ] return Attributes , final long count Limit , Attributes Mapper mapper , Validation Failure Reason [ ] failure Reason ) throws Size Limit Exceeded Exception { Search Controls group Search Controls = new Search Controls ( Search Controls . SUBTREE SCOPE , count Limit , search Controls . get Time Limit ( ) , return Attributes , search Controls . get Returning Obj Flag ( ) , search Controls . get Deref Link Flag ( ) ) ; List < List < Group Attribute > > query Group Results = null ; query Group Results = safe Ldap Search ( base DN , query Builder . encode ( ) , group Search Controls , mapper , failure Reason ) ; return query Group Results ; }",
    "label": 1
  },
  {
    "text_1": "returns true iff str . tolowercase ( ) . endswith ( end . tolowercase ( ) ) implementation is not creating extra strings .",
    "text_2": "public final static boolean ends With Ignore Case ( String str , String end ) { int str Length = str = = null ? NUM : str . length ( ) ; int end Length = end = = null ? NUM : end . length ( ) ; if ( end Length > str Length ) return BOOL ; for ( int i = NUM ; i < = end Length ; i + + ) { if ( Scanner Helper . to Lower Case ( end . char At ( end Length - i ) ) ! = Scanner Helper . to Lower Case ( str . char At ( str Length - i ) ) ) return BOOL ; } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "this method accompli shes rdbms - independent table exists check .",
    "text_2": "private boolean is Checkpoint Table Exists ( Connection conn ) { Statement st = null ; Result Set rs = null ; try { st = conn . create Statement ( ) ; rs = st . execute Query ( chk Tbl Exists Sql ) ; return BOOL ; } catch ( SQL Exception ignored ) { return BOOL ; } finally { U . close ( rs , log ) ; U . close ( st , log ) ; } }",
    "label": 1
  },
  {
    "text_1": "creates the section size formatter string depending on the size of the section .",
    "text_2": "private String to String ( final int size ) { if ( size < NUM ) { return String . format ( STRING , size ) ; } else if ( size < NUM * NUM ) { return String . format ( Locale . ENGLISH , STRING , NUM * size / NUM ) ; } else { return String . format ( Locale . ENGLISH , STRING , NUM * size / NUM / NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns true if the type was raw , that is , type arguments were not provided but instead inferred .",
    "text_2": "public boolean was Raw ( ) { return was Raw ; }",
    "label": 1
  },
  {
    "text_1": "runs when search results are retrieved .",
    "text_2": "void run Post Search ( int cnt Items ) ;",
    "label": 1
  },
  {
    "text_1": "tests behavior on off heap ed entries .",
    "text_2": "public void test Get ( ) throws Exception { Ignite Cache < Long , Long > cache = populate ( ) ; for ( long i = from ; i < to ; i + + ) { Long val = cache . get ( i ) ; assert Not Null ( val ) ; assert Equals ( i , val . long Value ( ) ) ; } assert Equals ( NUM , swapped Cnt . get ( ) ) ; assert Equals ( NUM , off hea ped Cnt . get ( ) ) ; assert Equals ( to - from , un sw aped Cnt . get ( ) + on hea ped Cnt . get ( ) ) ; check Entries ( cache ) ; assert Equals ( to - from , un sw aped Cnt . get ( ) + on hea ped Cnt . get ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "converts all separators to the windows separator of backslash .",
    "text_2": "public static String separators To Windows ( String path ) { if ( path = = null | | path . index Of ( UNIX SEPARATOR ) = = - NUM ) { return path ; } return path . replace ( UNIX SEPARATOR , WINDOWS SEPARATOR ) ; }",
    "label": 1
  },
  {
    "text_1": "determines if the url is pointing to a directory .",
    "text_2": "private static boolean is Directory ( URL url ) { String file = url . get File ( ) ; return ( file . length ( ) > NUM & & file . char At ( file . length ( ) - NUM ) = = STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "generates an input avro file containing the given records in the temporary directory and returns the full path of the file .",
    "text_2": "@ Suppress Warnings ( STRING ) private < T > String generate Test File ( String filename , List < T > elems , Avro Coder < T > coder , String codec ) throws IO Exception { File tmp File = tmp Folder . new File ( filename ) ; String path = tmp File . to String ( ) ; File Output Stream os = new File Output Stream ( tmp File ) ; Datum Writer < T > datum Writer = coder . create Datum Writer ( ) ; try ( Data File Writer < T > writer = new Data File Writer < > ( datum Writer ) ) { writer . set Codec ( Codec Factory . from String ( codec ) ) ; writer . create ( coder . get Schema ( ) , os ) ; for ( T elem : elems ) { writer . append ( elem ) ; } } return path ; }",
    "label": 1
  },
  {
    "text_1": "check to see if there are still any receiver threads for the given end - point",
    "text_2": "protected boolean has Receivers For ( Distributed Member end Point ) { synchronized ( this . receivers ) { for ( Iterator it = receivers . iterator ( ) ; it . has Next ( ) ; ) { Connection con = ( Connection ) it . next ( ) ; if ( end Point . equals ( con . get Remote Address ( ) ) ) { return BOOL ; } } } return BOOL ; }",
    "label": 1
  },
  {
    "text_1": "one result of the search consists of a new package .",
    "text_2": "public void accept Package ( char [ ] package Name ) { }",
    "label": 1
  },
  {
    "text_1": "examples of double and long predicates",
    "text_2": "private void speci alised Predicates ( ) { Double Predicate double Predicate = null ; Long Predicate long Predicate = null ; }",
    "label": 1
  },
  {
    "text_1": "as each segment is visited write out the appropriate line mapping .",
    "text_2": "@ Override public void visit ( Mapping m , int line , int col , int next Line , int next Col ) throws IO Exception { if ( previous Line ! = line ) { previous Column = NUM ; } if ( line ! = next Line | | col ! = next Col ) { if ( line < max Line ) { if ( previous Line = = line ) { out . append ( STRING ) ; } write Entry ( m , col ) ; previous Line = line ; previous Column = col ; } else { Preconditions . check State ( m = = null ) ; } } for ( int i = line ; i < = next Line & & i < max Line ; i + + ) { if ( i = = next Line ) { break ; } close Line ( BOOL ) ; open Line ( BOOL ) ; } }",
    "label": 1
  },
  {
    "text_1": "parse a comment string cursor is at a \" ( \" . leave cursor at )",
    "text_2": "public String comment ( ) throws Parse Exception { String Buffer retval = new String Buffer ( ) ; if ( look Ahead ( NUM ) ! = STRING ) return null ; consume ( NUM ) ; while ( BOOL ) { char next = get Next Char ( ) ; if ( next = = STRING ) { break ; } else if ( next = = STRING ) { throw new Parse Exception ( this . buffer + STRING , this . ptr ) ; } else if ( next = = STRING ) { retval . append ( next ) ; next = get Next Char ( ) ; if ( next = = STRING ) throw new Parse Exception ( this . buffer + STRING , this . ptr ) ; retval . append ( next ) ; } else { retval . append ( next ) ; } } return retval . to String ( ) ; }",
    "label": 1
  },
  {
    "text_1": "find the differences between two texts .",
    "text_2": "public Linked List < Diff > diff main ( String text NUM , String text NUM , boolean check lines ) { long deadline ; if ( Diff Timeout < = NUM ) { deadline = Long . MAX VALUE ; } else { deadline = System . current Time Millis ( ) + ( long ) ( Diff Timeout * NUM ) ; } return diff main ( text NUM , text NUM , check lines , deadline ) ; }",
    "label": 1
  },
  {
    "text_1": "returns a non - null path ending in \" / \" .",
    "text_2": "private static String mat chable Path ( String path ) { if ( path = = null ) { return STRING ; } else if ( path . ends With ( STRING ) ) { return path ; } else { return path + STRING ; } }",
    "label": 1
  },
  {
    "text_1": "returns all known urls which point to the specified resource .",
    "text_2": "@ Override public Enumeration < URL > find Resources ( final String name ) throws IO Exception { if ( name = = null ) { return null ; } Array List < URL > result = new Array List < URL > ( ) ; int n = NUM ; while ( BOOL ) { URL Handler handler = get Handler ( n + + ) ; if ( handler = = null ) { break ; } handler . find Resources ( name , result ) ; } return Collections . enumeration ( result ) ; }",
    "label": 1
  },
  {
    "text_1": "mean allocation : ( total application bytes used across all allocations for this slot size ) / slot sal located",
    "text_2": "public int mean Allocation ( ) { if ( m slot Allocations = = NUM ) return NUM ; return ( int ) ( m size Allocations / m slot Allocations ) ; }",
    "label": 1
  },
  {
    "text_1": "sets curl for this mesh .",
    "text_2": "public synchronized void curl ( Point F curl Pos , Point F curl Dir , double radius ) { if ( DRAW C URL POSITION ) { m Buf Curl Position Lines . position ( NUM ) ; m Buf Curl Position Lines . put ( curl Pos . x ) ; m Buf Curl Position Lines . put ( curl Pos . y - NUM ) ; m Buf Curl Position Lines . put ( curl Pos . x ) ; m Buf Curl Position Lines . put ( curl Pos . y + NUM ) ; m Buf Curl Position Lines . put ( curl Pos . x - NUM ) ; m Buf Curl Position Lines . put ( curl Pos . y ) ; m Buf Curl Position Lines . put ( curl Pos . x + NUM ) ; m Buf Curl Position Lines . put ( curl Pos . y ) ; m Buf Curl Position Lines . put ( curl Pos . x ) ; m Buf Curl Position Lines . put ( curl Pos . y ) ; m Buf Curl Position Lines . put ( curl Pos . x + curl Dir . x * NUM ) ; m Buf Curl Position Lines . put ( curl Pos . y + curl Dir . y * NUM ) ; m Buf Curl Position Lines . position ( NUM ) ; } m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } double curl Angle = Math . acos ( curl Dir . x ) ; curl Angle = curl Dir . y > NUM ? - curl Angle : curl Angle ; m Arr Temp Vertices . add All ( m Arr Rotated Vertices ) ; m Arr Rotated Vertices . clear ( ) ; for ( int i = NUM ; i < NUM ; + + i ) { Vertex v = m Arr Temp Vertices . remove ( NUM ) ; v . set ( m Rectangle [ i ] ) ; v . translate ( - curl Pos . x , - curl Pos . y ) ; v . rotate Z ( - curl Angle ) ; int j = NUM ; for ( ; j < m Arr Rotated Vertices . size ( ) ; + + j ) { Vertex v NUM = m Arr Rotated Vertices . get ( j ) ; if ( v . m Pos X > v NUM . m Pos X ) { break ; } if ( v . m Pos X = = v NUM . m Pos X & & v . m Pos Y > v NUM . m Pos Y ) { break ; } } m Arr Rotated Vertices . add ( j , v ) ; } int lines [ ] [ ] = { { NUM , NUM } , { NUM , NUM } , { NUM , NUM } , { NUM , NUM } } ; { Vertex v0 = m Arr Rotated Vertices . get ( NUM ) ; Vertex v NUM = m Arr Rotated Vertices . get ( NUM ) ; Vertex v NUM = m Arr Rotated Vertices . get ( NUM ) ; double dist NUM = Math . sqrt ( ( v0 . m Pos X - v NUM . m Pos X ) * ( v0 . m Pos X - v NUM . m Pos X ) + ( v0 . m Pos Y - v NUM . m Pos Y ) * ( v0 . m Pos Y - v NUM . m Pos Y ) ) ; double dist NUM = Math . sqrt ( ( v0 . m Pos X - v NUM . m Pos X ) * ( v0 . m Pos X - v NUM . m Pos X ) + ( v0 . m Pos Y - v NUM . m Pos Y ) * ( v0 . m Pos Y - v NUM . m Pos Y ) ) ; if ( dist NUM > dist NUM ) { lines [ NUM ] [ NUM ] = NUM ; lines [ NUM ] [ NUM ] = NUM ; } } m Vertices Count Front = m Vertices Count Back = NUM ; if ( DRAW SHADOW ) { m Arr Temp Shadow Vertices . add All ( m Arr Drop Shadow Vertices ) ; m Arr Temp Shadow Vertices . add All ( m Arr Self Shadow Vertices ) ; m Arr Drop Shadow Vertices . clear ( ) ; m Arr Self Shadow Vertices . clear ( ) ; } double curl Length = Math . PI * radius ; m Arr Scan Lines . clear ( ) ; if ( m Max Curl Splits > NUM ) { m Arr Scan Lines . add ( ( double ) NUM ) ; } for ( int i = NUM ; i < m Max Curl Splits ; + + i ) { m Arr Scan Lines . add ( ( - curl Length * i ) / ( m Max Curl Splits - NUM ) ) ; } m Arr Scan Lines . add ( m Arr Rotated Vertices . get ( NUM ) . m Pos X - NUM ) ; double scan Xmax = m Arr Rotated Vertices . get ( NUM ) . m Pos X + NUM ; for ( int i = NUM ; i < m Arr Scan Lines . size ( ) ; + + i ) { double scan Xmin = m Arr Scan Lines . get ( i ) ; for ( int j = NUM ; j < m Arr Rotated Vertices . size ( ) ; + + j ) { Vertex v = m Arr Rotated Vertices . get ( j ) ; if ( v . m Pos X > = scan Xmin & & v . m Pos X < = scan Xmax ) { Vertex n = m Arr Temp Vertices . remove ( NUM ) ; n . set ( v ) ; Array < Vertex > intersections = get Intersections ( m Arr Rotated Vertices , lines , n . m Pos X ) ; if ( intersections . size ( ) = = NUM & & intersections . get ( NUM ) . m Pos Y > v . m Pos Y ) { m Arr Output Vertices . add All ( intersections ) ; m Arr Output Vertices . add ( n ) ; } else if ( intersections . size ( ) < = NUM ) { m Arr Output Vertices . add ( n ) ; m Arr Output Vertices . add All ( intersections ) ; } else { m Arr Temp Vertices . add ( n ) ; m Arr Temp Vertices . add All ( intersections ) ; } } } Array < Vertex > intersections = get Intersections ( m Arr Rotated Vertices , lines , scan Xmin ) ; if ( intersections . size ( ) = = NUM ) { Vertex v1 = intersections . get ( NUM ) ; Vertex v NUM = intersections . get ( NUM ) ; if ( v1 . m Pos Y < v NUM . m Pos Y ) { m Arr Output Vertices . add ( v NUM ) ; m Arr Output Vertices . add ( v1 ) ; } else { m Arr Output Vertices . add All ( intersections ) ; } } else if ( intersections . size ( ) ! = NUM ) { m Arr Temp Vertices . add All ( intersections ) ; } while ( m Arr Output Vertices . size ( ) > NUM ) { Vertex v = m Arr Output Vertices . remove ( NUM ) ; m Arr Temp Vertices . add ( v ) ; boolean texture Front ; if ( i = = NUM ) { texture Front = BOOL ; m Vertices Count Front + + ; } else if ( i = = m Arr Scan Lines . size ( ) - NUM | | curl Length = = NUM ) { v . m Pos X = - ( curl Length + v . m Pos X ) ; v . m Pos Z = NUM * radius ; v . m Pen umbra X = - v . m Pen umbra X ; texture Front = BOOL ; m Vertices Count Back + + ; } else { double rot Y = Math . PI * ( v . m Pos X / curl Length ) ; v . m Pos X = radius * Math . sin ( rot Y ) ; v . m Pos Z = radius - ( radius * Math . cos ( rot Y ) ) ; v . m Pen umbra X * = Math . cos ( rot Y ) ; v . m Color Factor = ( float ) ( NUM + NUM * Math . sqrt ( Math . sin ( rot Y ) + NUM ) ) ; if ( v . m Pos Z > = radius ) { texture Front = BOOL ; m Vertices Count Back + + ; } else { texture Front = BOOL ; m Vertices Count Front + + ; } } if ( texture Front ! = m Flip Texture ) { v . m Tex X * = m Texture Rect Front . right ; v . m Tex Y * = m Texture Rect Front . bottom ; v . m Color = m Texture Page . get Color ( Curl Page . SIDE FRONT ) ; } else { v . m Tex X * = m Texture Rect Back . right ; v . m Tex Y * = m Texture Rect Back . bottom ; v . m Color = m Texture Page . get Color ( Curl Page . SIDE BACK ) ; } v . rotate Z ( curl Angle ) ; v . translate ( curl Pos . x , curl Pos . y ) ; add Vertex ( v ) ; if ( DRAW SHADOW & & v . m Pos Z > NUM & & v . m Pos Z < = radius ) { Shadow Vertex sv = m Arr Temp Shadow Vertices . remove ( NUM ) ; sv . m Pos X = v . m Pos X ; sv . m Pos Y = v . m Pos Y ; sv . m Pos Z = v . m Pos Z ; sv . m Pen umbra X = ( v . m Pos Z / NUM ) * - curl Dir . x ; sv . m Pen umbra Y = ( v . m Pos Z / NUM ) * - curl Dir . y ; sv . m Pen umbra Color = v . m Pos Z / radius ; int idx = ( m Arr Drop Shadow Vertices . size ( ) + NUM ) / NUM ; m Arr Drop Shadow Vertices . add ( idx , sv ) ; } if ( DRAW SHADOW & & v . m Pos Z > radius ) { Shadow Vertex sv = m Arr Temp Shadow Vertices . remove ( NUM ) ; sv . m Pos X = v . m Pos X ; sv . m Pos Y = v . m Pos Y ; sv . m Pos Z = v . m Pos Z ; sv . m Pen umbra X = ( ( v . m Pos Z - radius ) / NUM ) * v . m Pen umbra X ; sv . m Pen umbra Y = ( ( v . m Pos Z - radius ) / NUM ) * v . m Pen umbra Y ; sv . m Pen umbra Color = ( v . m Pos Z - radius ) / ( NUM * radius ) ; int idx = ( m Arr Self Shadow Vertices . size ( ) + NUM ) / NUM ; m Arr Self Shadow Vertices . add ( idx , sv ) ; } } scan Xmax = scan Xmin ; } m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } if ( DRAW SHADOW ) { m Buf Shadow Colors . position ( NUM ) ; m Buf Shadow Vertices . position ( NUM ) ; m Drop Shadow Count = NUM ; for ( int i = NUM ; i < m Arr Drop Shadow Vertices . size ( ) ; + + i ) { Shadow Vertex sv = m Arr Drop Shadow Vertices . get ( i ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos X ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Y ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos X + sv . m Pen umbra X ) ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos Y + sv . m Pen umbra Y ) ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; for ( int j = NUM ; j < NUM ; + + j ) { double color = SHADOW OUTER COLOR [ j ] + ( SHADOW INNER COLOR [ j ] - SHADOW OUTER COLOR [ j ] ) * sv . m Pen umbra Color ; m Buf Shadow Colors . put ( ( float ) color ) ; } m Buf Shadow Colors . put ( SHADOW OUTER COLOR ) ; m Drop Shadow Count + = NUM ; } m Self Shadow Count = NUM ; for ( int i = NUM ; i < m Arr Self Shadow Vertices . size ( ) ; + + i ) { Shadow Vertex sv = m Arr Self Shadow Vertices . get ( i ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos X ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Y ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos X + sv . m Pen umbra X ) ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos Y + sv . m Pen umbra Y ) ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; for ( int j = NUM ; j < NUM ; + + j ) { double color = SHADOW OUTER COLOR [ j ] + ( SHADOW INNER COLOR [ j ] - SHADOW OUTER COLOR [ j ] ) * sv . m Pen umbra Color ; m Buf Shadow Colors . put ( ( float ) color ) ; } m Buf Shadow Colors . put ( SHADOW OUTER COLOR ) ; m Self Shadow Count + = NUM ; } m Buf Shadow Colors . position ( NUM ) ; m Buf Shadow Vertices . position ( NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "start an ele me xslt function . verify that it is top level and that it has a name attribute with a namespace .",
    "text_2": "public void start Element ( Stylesheet Handler handler , String uri , String local Name , String raw Name , Attributes attributes ) throws SAX Exception { String msg = STRING ; if ( ! ( handler . get Elem Template Element ( ) instanceof Stylesheet ) ) { msg = STRING ; handler . error ( msg , new SAX Exception ( msg ) ) ; } super . start Element ( handler , uri , local Name , raw Name , attributes ) ; String val = attributes . get Value ( STRING ) ; int index Of Colon = val . index Of ( STRING ) ; if ( index Of Colon > NUM ) { } else { msg = STRING ; handler . error ( msg , new SAX Exception ( msg ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "the main function is a test , reads in a shape file ( with the . sh x and . dbf files ) and writes them back out .",
    "text_2": "public static void main ( String [ ] argv ) { Arg Parser ap = new Arg Parser ( STRING ) ; ap . add ( STRING , STRING , NUM ) ; if ( argv . length < NUM ) { ap . bail ( STRING , BOOL ) ; } ap . parse ( argv ) ; String [ ] files = ap . get Arg Values ( STRING ) ; if ( files ! = null & & files [ NUM ] ! = null ) { String shp = files [ NUM ] ; String dbf = null ; try { dbf = shp . substring ( NUM , shp . last Index Of ( STRING ) + NUM ) + PARAM DBF ; Dbf Table Model model = Dbf Table Model . get Dbf Table Model ( Prop Utils . get Resource Or File Or URL ( dbf ) ) ; Esri Graphic List list = Esri Graphic List . get Esri Graphic List ( Prop Utils . get Resource Or File Or URL ( shp ) , null , null ) ; logger . info ( list . get Description ( ) ) ; Esri Shape Export ese = new Esri Shape Export ( list , model , null ) ; ese . export ( ) ; } catch ( Malformed URL Exception mur le ) { logger . warning ( STRING + mur le . get Message ( ) ) ; } catch ( Null Pointer Exception npe ) { logger . warning ( STRING ) ; } catch ( Exception exception ) { logger . warning ( STRING + exception . get Message ( ) ) ; exception . print Stack Trace ( ) ; } } else { ap . bail ( STRING , BOOL ) ; } System . exit ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "wait until enough data ( key - value records ) has been consumed .",
    "text_2": "public static < K , V > List < Key Value < K , V > > wait Until Min Key Value Records Received ( Properties consumer Config , String topic , int expected Num Records , long wait Time ) throws Interrupted Exception { List < Key Value < K , V > > accum Data = new Array List < > ( ) ; long start Time = System . current Time Millis ( ) ; while ( BOOL ) { List < Key Value < K , V > > read Data = read Key Values ( topic , consumer Config ) ; accum Data . add All ( read Data ) ; if ( accum Data . size ( ) > = expected Num Records ) return accum Data ; if ( System . current Time Millis ( ) > start Time + wait Time ) throw new Assertion Error ( STRING + expected Num Records + STRING + accum Data . size ( ) + STRING + wait Time + STRING ) ; Thread . sleep ( Math . min ( wait Time , NUM ) ) ; } }",
    "label": 1
  },
  {
    "text_1": "parses a t md file",
    "text_2": "private void parse ( File tmd ) throws IO Exception { Random Access File f = new Random Access File ( tmd , STRING ) ; f . seek ( NUM ) ; this . signature Type = f . read Int ( ) ; f . read ( signature , NUM , NUM ) ; f . seek ( NUM ) ; f . read ( issuer , NUM , NUM ) ; f . seek ( NUM ) ; this . version = f . read Byte ( ) ; this . CAC RL Version = f . read Byte ( ) ; this . signer CRL Version = f . read Byte ( ) ; f . seek ( NUM ) ; this . system Version = f . read Long ( ) ; this . title ID = f . read Long ( ) ; this . title Type = f . read Int ( ) ; this . group ID = f . read Short ( ) ; f . seek ( NUM ) ; f . read ( reserved , NUM , NUM ) ; f . seek ( NUM ) ; this . access Rights = f . read Int ( ) ; this . title Version = f . read Short ( ) ; this . content Count = f . read Short ( ) ; this . boot Index = f . read Short ( ) ; f . seek ( NUM ) ; f . read ( SHA NUM , NUM , NUM ) ; f . seek ( NUM ) ; short index Offset ; short command Count ; for ( int i = NUM ; i < NUM ; i + + ) { f . seek ( NUM + ( NUM * i ) ) ; index Offset = f . read Short ( ) ; command Count = f . read Short ( ) ; byte [ ] buffer = new byte [ NUM ] ; f . read ( buffer , NUM , NUM ) ; this . content Infos [ i ] = new Content Info ( index Offset , command Count , buffer ) ; } this . contents = new Content [ content Count ] ; int ID ; short index ; short type ; long size ; for ( int i = NUM ; i < content Count ; i + + ) { f . seek ( NUM + ( NUM * i ) ) ; ID = f . read Int ( ) ; index = f . read Short ( ) ; type = f . read Short ( ) ; size = f . read Long ( ) ; byte [ ] buffer = new byte [ NUM ] ; f . read ( buffer , NUM , NUM ) ; this . contents [ i ] = new Content ( ID , index , type , size , buffer , this ) ; } if ( f . read ( cert NUM , NUM , NUM ) ! = NUM ) { Logger . log ( STRING ) ; } if ( f . read ( cert NUM , NUM , NUM ) ! = NUM ) { Logger . log ( STRING ) ; } f . close ( ) ; }",
    "label": 1
  },
  {
    "text_1": "write a string , compressed , if long enough",
    "text_2": "public void write String ( String str ) throws IO Exception { if ( str = = null ) write Int ( NUM ) ; else { if ( use Compression & & str . length ( ) > = Compressor . MIN SIZE FOR DEFL ATION ) { byte [ ] bytes = compressor . deflate String NUM Byte Array ( str ) ; write Int ( - bytes . length ) ; outs . write ( bytes , NUM , bytes . length ) ; position + = bytes . length ; } else { byte [ ] bytes = str . get Bytes ( STRING ) ; write Int ( bytes . length ) ; outs . write ( bytes , NUM , bytes . length ) ; position + = bytes . length ; } } }",
    "label": 1
  },
  {
    "text_1": "returns the string representing the object",
    "text_2": "public String to String ( ) { if ( val = = null ) return STRING ; if ( val instanceof Long | | val instanceof Integer ) { return Long . to String ( val . long Value ( ) ) ; } double d = val . double Value ( ) ; if ( Double . is Infinite ( d ) ) return ( d > NUM ) ? STRING : STRING ; if ( Double . is Na N ( d ) ) return STRING ; return Double . to String ( d ) ; }",
    "label": 1
  },
  {
    "text_1": "run - do the work",
    "text_2": "public final void run ( ) { if ( m start = = NUM ) m start = System . current Time Millis ( ) ; m can Continue = BOOL ; while ( m can Continue ) { if ( is Interrupted ( ) ) return ; m last Start = System . current Time Millis ( ) ; m working = BOOL ; try { m poll Count + + ; if ( can Do Work ( ) ) { m can Continue = do Work ( ) ; m count + + ; } } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } m working = BOOL ; long end = System . current Time Millis ( ) ; m time + = ( end - m last Start ) ; if ( is Interrupted ( ) ) return ; try { log . fine ( STRING + m sleep Seconds ) ; sleep ( m sleep Seconds * NUM ) ; } catch ( Interrupted Exception e1 ) { log . warning ( STRING + e1 . get Localized Message ( ) ) ; return ; } } }",
    "label": 1
  },
  {
    "text_1": "how long ago the stream was last online . if the stream was never seen as online this session , then a huge number will be returned .",
    "text_2": "public synchronized long last Online Ago ( ) { return ( System . current Time Millis ( ) - last Online ) / NUM ; }",
    "label": 1
  },
  {
    "text_1": "initialize the raster program .",
    "text_2": "private void init Raster Program ( ) { Int Buffer props = Buffer Utils . create Int Buffer ( NUM ) ; Int Buffer params = Buffer Utils . create Int Buffer ( NUM ) ; int uni forms Resource Index = gl Get Program Resource Index ( raster Program , GL UNIFORM BLOCK , STRING ) ; compute U bo Binding = params . get ( NUM ) ; props . put ( NUM , GL BUFFER BINDING ) ; gl Get Program Resource iv ( raster Program , GL UNIFORM BLOCK , uni forms Resource Index , props , null , params ) ; raster U bo Binding = params . get ( NUM ) ; }",
    "label": 1
  },
  {
    "text_1": "initialize this cipher with a key and iv .",
    "text_2": "public void init ( int mode , byte [ ] key , byte [ ] iv ) { context = Open Ssl Native . init ( context , mode , algorithm , padding , key , iv ) ; }",
    "label": 1
  },
  {
    "text_1": "copy the contents of the given inputstream into a new byte array . leaves the stream open when done .",
    "text_2": "public static byte [ ] copy To Byte Array ( Input Stream in ) throws IO Exception { Byte Array Output Stream out = new Byte Array Output Stream ( BUFFER SIZE ) ; copy ( in , out ) ; return out . to Byte Array ( ) ; }",
    "label": 1
  },
  {
    "text_1": "kill all the threads , and shutdown .",
    "text_2": "@ Override public void stop ( ) { for ( Thread thread : threads ) { thread . interrupt ( ) ; } try { for ( Thread thread : threads ) { thread . join ( ) ; } } catch ( Interrupted Exception e ) { } }",
    "label": 1
  },
  {
    "text_1": "makes a new buffer available either by allocating a new one or re - cycling an existing one .",
    "text_2": "private void need New Buffer ( int newcount ) { if ( current Buffer Index < buffers . size ( ) - NUM ) { filled Buffer Sum + = current Buffer . length ; current Buffer Index + + ; current Buffer = buffers . get ( current Buffer Index ) ; } else { int new Buffer Size ; if ( current Buffer = = null ) { new Buffer Size = newcount ; filled Buffer Sum = NUM ; } else { new Buffer Size = Math . max ( current Buffer . length < < NUM , newcount - filled Buffer Sum ) ; filled Buffer Sum + = current Buffer . length ; } current Buffer Index + + ; current Buffer = new byte [ new Buffer Size ] ; buffers . add ( current Buffer ) ; } }",
    "label": 1
  },
  {
    "text_1": "lists the available options",
    "text_2": "@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "write jar post resource",
    "text_2": "private void write Jar Post Resource ( String Builder sb , String path ) { sb . append ( STRING + JAR RESOURCE SET + STRING ) ; sb . append ( path . replace ( STRING , STRING ) ) ; }",
    "label": 1
  },
  {
    "text_1": "method for calculating bit e point for random & one direction options",
    "text_2": "private void calc B ite Point ( int center X , int center Y , float circle Edge X , float circle Edge Y , double bite Line , boolean is First B ite , boolean is Random B ite ) { double bite Percent ; if ( is First B ite ) { bite X = ( int ) circle Edge X ; bite Y = ( int ) circle Edge Y ; } else { bite Percent = bite Radius / bite Line ; if ( is Random B ite ) { bite Percent * = b ites Taken Map . get ( bite Direction ) ; } else { bite Percent * = ( num B ites For One Direction - num B ites For One Direction Left ) ; } bite X = Draw Utils . get Point Between Two Points ( circle Edge X , center X , bite Percent ) ; bite Y = Draw Utils . get Point Between Two Points ( circle Edge Y , center Y , bite Percent ) ; } }",
    "label": 1
  },
  {
    "text_1": "adds the given resource to the list of resources to be copied .",
    "text_2": "public void add Copy ( I Resource copy , Copy Arguments arguments ) { if ( f Copy = = null ) { f Copy = new Array List ( NUM ) ; f Copy Arguments = new Array List ( NUM ) ; } f Copy . add ( copy ) ; f Copy Arguments . add ( arguments ) ; add Copy Delta ( copy , arguments ) ; }",
    "label": 1
  },
  {
    "text_1": "remove view that has been added by add view to fa de list",
    "text_2": "public void remove View From Fade List ( View view ) { if ( m Fade View List ! = null & & view ! = null ) { m Fade View List . remove ( view ) ; } }",
    "label": 1
  },
  {
    "text_1": "append two arrays creating a new array for the result .",
    "text_2": "public static < A > A [ ] append ( final A [ ] a , final A [ ] b ) { final int alen = a . length ; final int blen = b . length ; final A [ ] res = Arrays . copy Of ( a , alen + blen ) ; System . arraycopy ( b , NUM , res , alen , blen ) ; return res ; }",
    "label": 1
  },
  {
    "text_1": "prints that a column is not nullable .",
    "text_2": "protected void write Column Not Nullable Stmt ( String Builder ddl ) { ddl . append ( STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "perform an asynchronous max operation",
    "text_2": "@ Override default Completable Future < Optional Int > max Int ( final To Int Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "append several int values onto the vector .",
    "text_2": "private void add Elements ( int value , int number Of Elements ) { if ( m first Free + number Of Elements < m blocksize ) for ( int i = NUM ; i < number Of Elements ; i + + ) { m map NUM [ m first Free + + ] = value ; } else { int index = m first Free > > > m SHIFT ; int offset = m first Free & m MASK ; m first Free + = number Of Elements ; while ( number Of Elements > NUM ) { if ( index > = m map . length ) { int newsize = index + m num blocks ; int [ ] [ ] new Map = new int [ newsize ] [ ] ; System . arraycopy ( m map , NUM , new Map , NUM , m map . length ) ; m map = new Map ; } int [ ] block = m map [ index ] ; if ( null = = block ) block = m map [ index ] = new int [ m blocksize ] ; int copied = ( m blocksize - offset < number Of Elements ) ? m blocksize - offset : number Of Elements ; number Of Elements - = copied ; while ( copied - - > NUM ) block [ offset + + ] = value ; + + index ; offset = NUM ; } } }",
    "label": 1
  },
  {
    "text_1": "gets the highest level",
    "text_2": "public static int max Level ( ) { return LEVELS - NUM ; }",
    "label": 1
  },
  {
    "text_1": "removes the given set of nodes and updates the internal data structures .",
    "text_2": "public void remove Nodes From Partition ( List < I Group Member Node > nodes To Remove ) { for ( final I Group Member Node node To Remove : nodes To Remove ) { if ( node To Remove ! = null ) { if ( ! non Optional Non Minus Nodes . remove ( node To Remove ) ) { if ( node To Remove . equals ( optional Or Minus ) ) { optional Or Minus = null ; } } } } recompute Definitely Produced ( ) ; }",
    "label": 1
  },
  {
    "text_1": "return this as a type parameter declaration or throw unsupportedoperationexception .",
    "text_2": "default Type Parameter Declaration as Type Parameter ( ) { throw new Unsupported Operation Exception ( String . format ( STRING , this ) ) ; }",
    "label": 1
  },
  {
    "text_1": "counts the size of a directory recursively ( sum of the length of all files ) .",
    "text_2": "public static Big Integer size Of Directory As Big Integer ( File directory ) { check Directory ( directory ) ; final File [ ] files = directory . list Files ( ) ; if ( files = = null ) { return Big Integer . ZERO ; } Big Integer size = Big Integer . ZERO ; for ( final File file : files ) { try { if ( ! is Symlink ( file ) ) { size = size . add ( Big Integer . value Of ( size Of ( file ) ) ) ; } } catch ( IO Exception ioe ) { } } return size ; }",
    "label": 1
  },
  {
    "text_1": "read an unsigned byte . note : returns an int , even though says byte ( non - javadoc )",
    "text_2": "@ Override public final int read Unsigned Byte ( ) throws IO Exception { return dis . read Unsigned Byte ( ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an enumeration describing the available options .",
    "text_2": "public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }",
    "label": 1
  },
  {
    "text_1": "x must be binary ; regressors must be continuous or binary .",
    "text_2": "public Result regress ( Discrete Variable x , List < Node > regressors ) { if ( ! binary ( x ) ) { throw new Illegal Argument Exception ( STRING ) ; } for ( Node node : regressors ) { if ( ! ( node instanceof Continuous Variable | | binary ( node ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } } double [ ] [ ] regressors = new double [ regressors . size ( ) ] [ get Rows ( ) . length ] ; for ( int j = NUM ; j < regressors . size ( ) ; j + + ) { int col = data Set . get Column ( regressors . get ( j ) ) ; double [ ] data Col = data Cols [ col ] ; for ( int i = NUM ; i < get Rows ( ) . length ; i + + ) { regressors [ j ] [ i ] = data Col [ get Rows ( ) [ i ] ] ; } } int [ ] target = new int [ get Rows ( ) . length ] ; int col = data Set . get Column ( data Set . get Variable ( x . get Name ( ) ) ) ; for ( int i = NUM ; i < get Rows ( ) . length ; i + + ) { target [ i ] = data Set . get Int ( get Rows ( ) [ i ] , col ) ; } List < String > regressor Names = new Array List < > ( ) ; for ( Node node : regressors ) { regressor Names . add ( node . get Name ( ) ) ; } return regress ( target , x . get Name ( ) , regressors , regressor Names ) ; }",
    "label": 1
  },
  {
    "text_1": "creates a new message from the type and the value .",
    "text_2": "public Message ( String type , double value ) { if ( ! VALID TYPES . contains ( type ) ) { throw new Illegal Argument Exception ( type + STRING + STRING ) ; } this . type = type ; this . value = value ; }",
    "label": 1
  },
  {
    "text_1": "insert functionality test test insert 1 ( ) . attempts to insert row into table with integrity checking",
    "text_2": "public void test Insert NUM ( ) throws SQL Exception { Database Creator . fill Parent Table ( conn ) ; Database Creator . fill FK Strict Table ( conn ) ; Database Creator . fill FK Cascade Table ( conn ) ; statement . execute ( STRING + Database Creator . F K STRICT TABLE + STRING ) ; statement . execute ( STRING + Database Creator . F K CASCADE TABLE + STRING ) ; }",
    "label": 1
  },
  {
    "text_1": "runs given tasks simultaneously and wait until they finish .",
    "text_2": "private void execute Tasks Simul ta ne ously With Barrier ( Runnable . . . tasks ) throws Interrupted Exception { Count Down Latch latch = new Count Down Latch ( tasks . length ) ; for ( Runnable task : tasks ) { executor . execute ( null ) ; } latch . await ( ) ; }",
    "label": 1
  },
  {
    "text_1": "create a integer arraylist from string arraylist",
    "text_2": "public static Array List < Integer > convert String Array To Integer Array ( List < String > array List ) { Array List < Integer > integers = new Array List < > ( ) ; for ( String str : array List ) { integers . add ( Integer . value Of ( str ) ) ; } return integers ; }",
    "label": 1
  },
  {
    "text_1": "rebuilds the menu according to the recent searches .",
    "text_2": "private void build Menu ( ) { set Visible ( BOOL ) ; remove All ( ) ; if ( recent Searches . get Length ( ) = = NUM ) { J Menu Item no Recent = new J Menu Item ( UI Manager . get String ( STRING ) ) ; no Recent . set Enabled ( BOOL ) ; add ( no Recent ) ; } else { J Menu Item recent = new J Menu Item ( UI Manager . get String ( STRING ) ) ; recent . set Enabled ( BOOL ) ; add ( recent ) ; for ( String search String : recent Searches . get Recent Searches ( ) ) { J Menu Item mi = new J Menu Item ( search String ) ; mi . add Action Listener ( this ) ; add ( mi ) ; } add Separator ( ) ; clear = new J Menu Item ( UI Manager . get String ( STRING ) ) ; clear . add Action Listener ( this ) ; add ( clear ) ; } }",
    "label": 1
  },
  {
    "text_1": "returns all the text in the given file .",
    "text_2": "public static String slurp File ( File file ) throws IO Exception { Reader r = new File Reader ( file ) ; return slurp Reader ( r ) ; }",
    "label": 1
  },
  {
    "text_1": "reads the response from adb after a command .",
    "text_2": "static Adb Response read Adb Response ( Socket Channel chan , boolean read Diag String ) throws Timeout Exception , IO Exception { Adb Response resp = new Adb Response ( ) ; byte [ ] reply = new byte [ NUM ] ; read ( chan , reply ) ; if ( is Okay ( reply ) ) { resp . okay = BOOL ; } else { read Diag String = BOOL ; resp . okay = BOOL ; } try { while ( read Diag String ) { byte [ ] len Buf = new byte [ NUM ] ; read ( chan , len Buf ) ; String len Str = reply To String ( len Buf ) ; int len ; try { len = Integer . parse Int ( len Str , NUM ) ; } catch ( Number Format Exception nfe ) { Log . w ( STRING , STRING + len Str + STRING + len Buf [ NUM ] + STRING + len Buf [ NUM ] + STRING + len Buf [ NUM ] + STRING + len Buf [ NUM ] ) ; Log . w ( STRING , STRING + reply To String ( reply ) ) ; break ; } byte [ ] msg = new byte [ len ] ; read ( chan , msg ) ; resp . message = reply To String ( msg ) ; Log . v ( STRING , STRING + reply To String ( reply ) + STRING + resp . message + STRING ) ; break ; } } catch ( Exception e ) { } return resp ; }",
    "label": 1
  },
  {
    "text_1": "finds the resources names present at this location and below on the classpath starting with this prefix and ending with this suffix .",
    "text_2": "private Set < String > find Resource Names ( String path , String prefix , String suffix ) throws IO Exception { Set < String > resource Names = find Resource Names From File System ( path , new File ( path ) ) ; return filter Resource Names ( resource Names , prefix , suffix ) ; }",
    "label": 1
  },
  {
    "text_1": "print the current time and a message to system out .",
    "text_2": "protected void print Time ( String s ) { Simple Date Format date Format = new Simple Date Format ( STRING ) ; println ( date Format . format ( new java . util . Date ( ) ) + STRING + s ) ; }",
    "label": 1
  },
  {
    "text_1": "create a horizontal bar chart with sample data in the range - 3 to + 3 .",
    "text_2": "private static J Free Chart create Chart ( ) { XY Series series NUM = new XY Series ( STRING ) ; series NUM . add ( NUM , NUM ) ; series NUM . add ( NUM , NUM ) ; series NUM . add ( NUM , NUM ) ; XY Dataset dataset = new XY Series Collection ( series NUM ) ; return Chart Factory . create Time Series Chart ( STRING , STRING , STRING , dataset , BOOL , BOOL , BOOL ) ; }",
    "label": 1
  },
  {
    "text_1": "start the health monitor",
    "text_2": "public void start ( ) { log . info ( STRING , this . name , this . frequency In Secs ) ; stopped = BOOL ; Thread dr Health Monitor Thread = new Thread ( this ) ; dr Health Monitor Thread . set Name ( this . name ) ; dr Health Monitor Thread . start ( ) ; }",
    "label": 1
  },
  {
    "text_1": "follow for this class or super - class for entity annotation .",
    "text_2": "public Class < ? > lookup Entity Class ( Class < ? > obj Class ) { for ( Class < ? > cls = obj Class ; cls ! = null ; cls = cls . get Superclass ( ) ) { if ( entity Bindings . contains Key ( cls ) | | cls . is Annotation Present ( Entity . class ) ) { return cls ; } } throw new Illegal Argument Exception ( STRING + obj Class ) ; }",
    "label": 1
  },
  {
    "text_1": "form all ngrams for a given word .",
    "text_2": "private static String [ ] form Grams ( String text , int ng ) { int len = text . length ( ) ; String [ ] res = new String [ len - ng + NUM ] ; for ( int i = NUM ; i < len - ng + NUM ; i + + ) { res [ i ] = text . substring ( i , i + ng ) ; } return res ; }",
    "label": 1
  },
  {
    "text_1": "checks if a point 2 d . double is inside the figure .",
    "text_2": "@ Override public boolean contains ( Point NUM D . Double p ) { Round Rectangle NUM D . Double r = ( Round Rectangle NUM D . Double ) round rect . clone ( ) ; double grow = Attribute Keys . get Perpendicular Hit Growth ( this ) ; r . x - = grow ; r . y - = grow ; r . width + = grow * NUM ; r . height + = grow * NUM ; r . arc width + = grow * NUM ; r . arch eight + = grow * NUM ; return r . contains ( p ) ; }",
    "label": 1
  },
  {
    "text_1": "adds a new email to this user",
    "text_2": "public void add Email ( Email Entity email ) { emails . add ( email ) ; }",
    "label": 1
  },
  {
    "text_1": "broker a - > broker b & & broker b - > broker a",
    "text_2": "public void test Topic Din am ically Included Behavior ( ) throws Exception { start All Brokers ( ) ; Destination dest = create Destination ( STRING , BOOL ) ; Message Consumer client A = create Consumer ( STRING , dest ) ; Message Consumer client B = create Consumer ( STRING , dest ) ; Thread . sleep ( NUM * NUM ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; Message Id List msgs A = get Consumer Messages ( STRING , client A ) ; msgs A . wait For Messages To Arrive ( MESSAGE COUNT ) ; assert Equals ( MESSAGE COUNT , msgs A . get Message Count ( ) ) ; Message Id List msgs B = get Consumer Messages ( STRING , client B ) ; msgs B . wait For Messages To Arrive ( MESSAGE COUNT ) ; assert Equals ( NUM , msgs B . get Message Count ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "register a new gas into gas registry .",
    "text_2": "public static Gas register ( Gas gas ) { if ( gas = = null ) { return null ; } registered G as ses . add ( gas ) ; return get Gas ( gas . get Name ( ) ) ; }",
    "label": 1
  },
  {
    "text_1": "returns an initialized ordered task using the specified identifier and array of steps .",
    "text_2": "public Ordered Task ( String identifier , Step . . . steps ) { this ( identifier , Arrays . as List ( steps ) ) ; }",
    "label": 1
  },
  {
    "text_1": "create image with name , id of button name and set m command onclick",
    "text_2": "private static img create Control Button Image ( String name , String js command , boolean enabled ) { String Buffer img Name = new String Buffer ( STRING + name ) ; if ( ! enabled ) img Name . append ( STRING ) ; img Name . append ( STRING ) ; img img = new img ( Mobile Env . get Image Directory ( img Name . to String ( ) ) , name ) ; if ( enabled ) img . set Alt ( Msg . get Msg ( AD Language , name ) ) ; img . set ID ( STRING ) ; if ( js command ! = null & & js command . length ( ) > NUM & & enabled ) { img . set On Click ( STRING + FORM NAME + STRING + M Command + STRING + name + STRING + js command ) ; } return img ; }",
    "label": 1
  },
  {
    "text_1": "convert an unsigned 32 - bit integer to a string .",
    "text_2": "private static String unsigned To String ( final int value ) { if ( value > = NUM ) { return Integer . to String ( value ) ; } else { return Long . to String ( ( ( long ) value ) & NUM ) ; } }",
    "label": 1
  },
  {
    "text_1": "below method will be used to add the statistics",
    "text_2": "public synchronized void record Statistics ( Query Statistic statistic ) { query Statistics . add ( statistic ) ; }",
    "label": 1
  },
  {
    "text_1": "append count characters from pattern onto out , repeating if necessary .",
    "text_2": "private static void repeat ( String pattern , int count , Appendable out ) throws IO Exception { while ( count > = pattern . length ( ) ) { out . append ( pattern ) ; count - = pattern . length ( ) ; } if ( count > NUM ) { out . append ( pattern , NUM , count ) ; } }",
    "label": 1
  },
  {
    "text_1": "convert a byte array to a string ; consistently uses \\ n line endings in java . the conversion is limited to the specified offset / length pair , and uses the requested charset to decode the bytes .",
    "text_2": "public static final String read String ( byte [ ] bytes , String charset ) throws IO Exception { return read String ( bytes , NUM , bytes . length , Charset . for Name ( charset ) ) ; }",
    "label": 1
  },
  {
    "text_1": "write byte array into a regular file",
    "text_2": "public static void write Plain File ( String file Path , byte [ ] content ) throws IO Exception { File Output Stream file Ouput Stream = new File Output Stream ( file Path ) ; file Ouput Stream . write ( content ) ; file Ouput Stream . close ( ) ; }",
    "label": 1
  }
]